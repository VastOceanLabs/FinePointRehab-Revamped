<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rhythm Reach — Comet Look (Immersive)</title>
  <meta name="description" content="Rhythm Reach with Comet-style settings and immersive start." />

  <!-- Base href for consistent imports -->
  <base href="/">

  <!-- Global styles -->
  <link rel="stylesheet" href="/css/tokens.css" />
  <link rel="stylesheet" href="/css/base.css" />
  <link rel="stylesheet" href="/css/components.css" />

  <style>
    dialog::backdrop{background:rgba(0,0,0,.5);}
    :root {
      --hud-height: 64px;
      --pad-gap: 12px;
      --pad-radius: 14px;
    }

    body {
      background: radial-gradient(1200px 800px at 10% 10%, rgba(255,255,255,0.05), transparent 60%),
                  radial-gradient(1000px 600px at 90% 30%, rgba(255,255,255,0.06), transparent 60%),
                  var(--bg, #0b1020);
      min-height: 100svh;
      overflow: hidden;
    }

    /* Screen switching */
    .screen { display: none; }
    .screen.active { display: block; }

    /* Header */
    header.site-header {
      position: sticky;
      top: 0;
      z-index: 30;
      backdrop-filter: blur(6px);
      background: color-mix(in oklab, var(--panel-bg, rgba(255,255,255,0.06)) 90%, transparent);
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    header .wrap {
      display: flex; align-items: center; gap: .75rem; padding: .75rem 1rem;
    }
    .home-link { text-decoration: none; }
    .home-link .chev { margin-right: .25rem; }
    .title { font-size: clamp(18px, 2.2vw, 22px); font-weight: 600; }

    /* Settings layout (Comet-style) */
    .settings-wrap {
      display: grid;
      grid-template-columns: minmax(280px, 360px) 1fr;
      gap: 16px;
      padding: 16px;
      max-width: 1200px;
      margin: 0 auto;
    }
    @media (max-width: 860px) {
      .settings-wrap {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      border: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
    }
    .panel h2 { margin: 0 0 10px 0; font-size: 1.1rem; }
    .panel p { opacity: .9; }

    .fieldset { display: grid; gap: 12px; }
    .field {
      display: grid; gap: 6px;
    }
    .field label {
      font-weight: 600; font-size: .95rem;
    }
    .field .hint { font-size: .85rem; opacity: .8; }

    .actions {
      display: flex; gap: 10px; flex-wrap: wrap; margin-top: 12px;
    }
    .btn {
      display: inline-flex; align-items: center; justify-content: center;
      padding: .7rem 1rem; border-radius: 999px; border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
      cursor: pointer; user-select: none; text-decoration: none;
      font-weight: 600;
    }
    .btn:hover { filter: brightness(1.05); }
    .btn-primary {
      border-color: color-mix(in oklab, var(--brand-blue, #8ab4f8) 60%, white 0%);
      background: linear-gradient(180deg, color-mix(in oklab, var(--brand-blue, #8ab4f8) 24%, transparent), rgba(255,255,255,.02));
    }
    .btn-ghost { background: transparent; }

    /* Game Screen */
    #gameScreen {
      position: fixed; inset: 0;
      display: grid; grid-template-rows: var(--hud-height) 1fr;
      background: inherit;
      z-index: 100;
    }
    .hud {
      display: grid; grid-template-columns: 1fr auto; align-items: center;
      padding: 8px 12px; gap: 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: color-mix(in oklab, rgba(10,16,32,0.6) 70%, transparent);
      backdrop-filter: blur(6px);
    }
    .stats { display: flex; gap: 16px; align-items: center; font-variant-numeric: tabular-nums; }
    .stat { opacity: .95; }
    .hud-actions { display: flex; gap: 10px; }

    /* Grid play area */
    .play-area {
      position: relative; display: grid; place-items: center;
      padding: 14px;
    }
    .grid9 {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--pad-gap);
      width: min(90vw, 720px);
      aspect-ratio: 1 / 1;
      touch-action: manipulation;
    }
    .pad {
      border-radius: var(--pad-radius);
      border: 1px solid rgba(255,255,255,.1);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow: inset 0 2px 8px rgba(0,0,0,.3);
      display: grid; place-items: center;
      font-size: clamp(18px, 5.2vw, 32px);
      font-weight: 700;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      position: relative;
    }
    .pad:active { filter: brightness(1.15); }
    .pad.show {
      outline: 3px solid color-mix(in oklab, var(--brand-aqua, #80e6ff) 70%, white 0%);
      box-shadow: 0 0 22px rgba(128,230,255,.45), inset 0 2px 10px rgba(0,0,0,.35);
    }

    /* Pause overlay */
    .pause-overlay {
      position: absolute; inset: 0; display: grid; place-items: center;
      background: color-mix(in oklab, #000 55%, transparent);
      opacity: 0; pointer-events: none; transition: opacity .2s ease;
    }
    .pause-overlay.active { opacity: 1; pointer-events: auto; }
    .pause-card {
      background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px; padding: 18px; text-align: center; min-width: 260px;
      box-shadow: 0 14px 24px rgba(0,0,0,.4);
    }

    /* Accessibility helpers */
    .sr-only {
      position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
      overflow: hidden; clip: rect(0,0,0,0); border: 0;
    }

    /* Size mapping via "Comet Size" choice */
    .size-large .grid9 { width: min(92vw, 820px); }
    .size-medium .grid9 { width: min(90vw, 680px); }
    .size-small .grid9 { width: min(88vw, 560px); }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="wrap">
      <a class="home-link btn btn-ghost" href="/" aria-label="Back to home"><span class="chev">←</span> Home</a>
      <div class="title">Rhythm Reach</div>
      <div style="margin-left:auto;opacity:.8;font-size:.9rem">Comet-style settings • Immersive start</div>
    </div>
  </header>

  <!-- SETTINGS SCREEN (Comet-style) -->
  <main id="settingsScreen" class="screen active">
    <div class="settings-wrap">
      <section class="panel" aria-labelledby="settings-title">
        <h2 id="settings-title">Settings</h2>
        <div class="fieldset">
          <div class="field">
            <label for="duration">Session Duration (minutes)</label>
            <input id="duration" type="number" min="1" max="30" value="2" />
            <div class="hint">How long the session runs. Timer shows as mm:ss in the HUD.</div>
          </div>

          <div class="field">
            <label for="size">Comet Size</label>
            <select id="size">
              <option value="large">Large</option>
              <option value="medium" selected>Medium</option>
              <option value="small">Small</option>
            </select>
            <div class="hint">Controls the grid pad size visually.</div>
          </div>

          <div class="field">
            <label for="speed">Comet Speed</label>
            <select id="speed">
              <option value="slow">Slow</option>
              <option value="medium" selected>Medium</option>
              <option value="fast">Fast</option>
            </select>
            <div class="hint">Maps to sequence playback speed.</div>
          </div>

          <div class="field">
            <label for="spawn">Spawn Rate</label>
            <select id="spawn">
              <option value="slow">Slow (2s)</option>
              <option value="med">Medium (1.5s)</option>
              <option value="fast">Fast (1s)</option>
              <option value="vfast">Very Fast (0.5s)</option>
            </select>
            <div class="hint">Delay between sequences (after you complete one).</div>
          </div>
        </div>

        <div class="actions">
          <button id="startBtn" class="btn btn-primary" type="button">Start</button>
          <button id="pauseBtnSettings" class="btn btn-ghost" type="button" disabled>Pause</button>
          <button id="restartBtnSettings" class="btn btn-ghost" type="button" disabled>Restart</button>
        </div>
      </section>

      <section class="panel" aria-labelledby="howto-title">
        <h2 id="howto-title">How to play</h2>
        <p>Watch the pads light up in a sequence, then repeat the pattern. Each round adds one more step. Earn more points by keeping a long streak and completing rounds quickly.</p>
        <ul>
          <li>Tap pads 1–9 (or press keys 1–9).</li>
          <li>Use <strong>Pause</strong> to take a break; <strong>Exit</strong> returns you to this screen.</li>
          <li>Session ends when the timer reaches 0.</li>
        </ul>
      </section>
    </div>
  </main>

  <!-- GAME SCREEN (immersive fullscreen) -->
  <section id="gameScreen" class="screen" aria-hidden="true">
    <div class="hud">
      <div class="stats">
        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">Personal Best: <span id="best">0</span></div>
        <div class="stat">Time: <span id="time">00:00</span></div>
      </div>
      <div class="hud-actions">
        <button id="pauseBtn" class="btn btn-ghost" type="button" aria-pressed="false">Pause</button>
        <button id="exitBtn" class="btn btn-ghost" type="button">Exit</button>
      </div>
    </div>

    <div class="play-area size-medium" id="playArea">
      <div class="grid9" id="grid" role="application" aria-label="Rhythm grid">
        <!-- 9 pads -->
        <button class="pad" data-id="1">1</button>
        <button class="pad" data-id="2">2</button>
        <button class="pad" data-id="3">3</button>
        <button class="pad" data-id="4">4</button>
        <button class="pad" data-id="5">5</button>
        <button class="pad" data-id="6">6</button>
        <button class="pad" data-id="7">7</button>
        <button class="pad" data-id="8">8</button>
        <button class="pad" data-id="9">9</button>
      </div>

      <div id="pauseOverlay" class="pause-overlay" aria-hidden="true">
        <div class="pause-card">
          <h3>Paused</h3>
          <p>Tap Resume to continue.</p>
          <div class="actions" style="justify-content:center;">
            <button id="resumeBtn" class="btn btn-primary">Resume</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- End Modal (simple, inline) -->
  <dialog id="endModal" aria-labelledby="endTitle">
    <form method="dialog" class="panel" style="min-width: min(520px, 92vw);">
      <h2 id="endTitle">Session Complete</h2>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-block:10px;">
        <div class="field"><label>Final Score</label><div id="finalScore"><strong>0</strong></div></div>
        <div class="field"><label>Level Reached</label><div id="finalLevel"><strong>0</strong></div></div>
        <div class="field"><label>Best Streak</label><div id="finalStreak"><strong>0</strong></div></div>
        <div class="field"><label>Time Played</label><div id="finalTime"><strong>00:00</strong></div></div>
      </div>
      <div class="actions" style="justify-content:flex-end;">
        <button id="newSessionBtn" class="btn btn-primary">Start New Session</button>
        <button id="closeSummaryBtn" class="btn btn-ghost">Close</button>
      </div>
    </form>
  </dialog>

  <script>
    // ===== Utilities =====
    const qs = (sel, el = document) => el.querySelector(sel);
    const qsa = (sel, el = document) => [...el.querySelectorAll(sel)];
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

    function fmtTime(ms) {
      const total = Math.max(0, Math.floor(ms / 1000));
      const m = String(Math.floor(total / 60)).padStart(2, '0');
      const s = String(total % 60).padStart(2, '0');
      return \`\${m}:\${s}\`;
    }

    const screens = {
      settings: qs('#settingsScreen'),
      game: qs('#gameScreen')
    };

    function showScreen(which) {
      Object.values(screens).forEach(s => s.classList.remove('active'));
      if (which === 'settings') {
        screens.settings.classList.add('active');
        screens.settings.removeAttribute('aria-hidden');
        screens.game.setAttribute('aria-hidden', 'true');
      } else {
        screens.game.classList.add('active');
        screens.game.removeAttribute('aria-hidden');
        screens.settings.setAttribute('aria-hidden', 'true');
      }
    }

    // ===== Elements =====
    const durationEl = qs('#duration');
    const sizeEl     = qs('#size');
    const speedEl    = qs('#speed');
    const spawnEl    = qs('#spawn');
    const playArea   = qs('#playArea');
    const gridEl     = qs('#grid');
    const pads       = qsa('.pad', gridEl);

    const scoreEl = qs('#score');
    const bestEl  = qs('#best');
    const timeEl  = qs('#time');

    const startBtn           = qs('#startBtn');
    const pauseBtn           = qs('#pauseBtn');
    const exitBtn            = qs('#exitBtn');
    const pauseBtnSettings   = qs('#pauseBtnSettings');
    const restartBtnSettings = qs('#restartBtnSettings');
    const pauseOverlay       = qs('#pauseOverlay');
    const resumeBtn          = qs('#resumeBtn');

    const endModal = qs('#endModal');
    const finalScore  = qs('#finalScore');
    const finalLevel  = qs('#finalLevel');
    const finalStreak = qs('#finalStreak');
    const finalTime   = qs('#finalTime');
    const newSessionBtn = qs('#newSessionBtn');
    const closeSummaryBtn = qs('#closeSummaryBtn');

    // State
    let running = false;
    let paused = false;
    let sequence = [];
    let userIndex = 0;
    let level = 0;
    let score = 0;
    let best = Number(localStorage.getItem('RR_best') || 0);
    bestEl.textContent = String(best);

    let sessionEndAt = 0;
    let timeTimer = null;
    let spawnDelay = 1500; // based on spawn select

    // Map "Comet" speed to playback ms per pad
    function padMsFromSpeed(speed) {
      switch (speed) {
        case 'slow':   return 700;
        case 'fast':   return 350;
        default:       return 500;
      }
    }
    function spawnMsFromOption(opt) {
      switch (opt) {
        case 'slow':  return 2000;
        case 'fast':  return 1000;
        case 'vfast': return 500;
        default:      return 1500; // med
      }
    }

    // Fullscreen helpers
    async function goFullscreen() {
      try {
        await document.documentElement.requestFullscreen();
        if (screen.orientation && screen.orientation.lock) {
          try { await screen.orientation.lock('portrait-primary'); } catch {}
        }
      } catch {}
    }
    async function exitFullscreen() {
      try {
        if (document.fullscreenElement) await document.exitFullscreen();
      } catch {}
    }

    // ===== Game logic =====
    function resetGameState() {
      running = false;
      paused = false;
      sequence = [];
      userIndex = 0;
      level = 0;
      score = 0;
      scoreEl.textContent = '0';
      timeEl.textContent = '00:00';
      pauseOverlay.classList.remove('active');
      pauseOverlay.setAttribute('aria-hidden', 'true');
      pauseBtn.setAttribute('aria-pressed', 'false');
    }

    function applySizeClass(size) {
      playArea.classList.remove('size-large','size-medium','size-small');
      playArea.classList.add(\`size-\${size}\`);
    }

    function updateTimer() {
      const remaining = sessionEndAt - Date.now();
      timeEl.textContent = fmtTime(remaining);
      if (remaining <= 0) {
        clearInterval(timeTimer);
        endSession();
      }
    }

    async function startSession() {
      if (startBtn.disabled) return; startBtn.disabled = true;
      // read settings
      const mins = clamp(parseInt(durationEl.value || '2', 10), 1, 30);
      const size = sizeEl.value;
      const speed = speedEl.value;
      const spawn = spawnEl.value;

      applySizeClass(size);
      spawnDelay = spawnMsFromOption(spawn);
      const padMs = padMsFromSpeed(speed);

      resetGameState();
      running = true;

      // switch to game screen and go immersive
      showScreen('game');
      await goFullscreen();

      // set timer
      sessionEndAt = Date.now() + mins * 60 * 1000;
      timeTimer = setInterval(updateTimer, 250);
      updateTimer();

      // kick off first level
      setTimeout(() => nextLevel(padMs), 400);
    }

    function endSession() {
      startBtn.disabled = false;
      running = false;
      paused = false;
      clearInterval(timeTimer);

      // Update best
      if (score > best) {
        best = score;
        localStorage.setItem('RR_best', String(best));
        bestEl.textContent = String(best);
      }

      finalScore.innerHTML  = '<strong>' + score + '</strong>';
      finalLevel.innerHTML  = '<strong>' + level + '</strong>';
      finalStreak.innerHTML = '<strong>' + Math.max(0, level - 1) + '</strong>';
      const playedMs = Math.max(0, (parseInt(durationEl.value||'2',10)*60*1000) - Math.max(0, sessionEndAt - Date.now()));
      finalTime.innerHTML = '<strong>' + fmtTime(playedMs) + '</strong>';

      try { endModal.showModal(); } catch { alert(`Session Complete\nScore: ${score}\nLevel: ${level}`); exitToSettings(); }
    }

    function pauseToggle(force) {
      if (!running) return;
      paused = (typeof force === 'boolean') ? force : !paused;
      pauseOverlay.classList.toggle('active', paused);
      pauseOverlay.setAttribute('aria-hidden', String(!paused));
      pauseBtn.setAttribute('aria-pressed', String(paused));
    }

    async function exitToSettings() {
      startBtn.disabled = false;
      running = false;
      paused = false;
      clearInterval(timeTimer);
      try { if (screen.orientation && screen.orientation.unlock) screen.orientation.unlock(); } catch {}
      await exitFullscreen();
      endModal.close?.();
      showScreen('settings');
    }

    function flashPad(id, ms) {
      const pad = pads.find(p => p.dataset.id === String(id));
      if (!pad) return;
      pad.classList.add('show');
      setTimeout(() => pad.classList.remove('show'), ms * 0.8);
    }

    async function playSequence(seq, msPer) {
      for (const id of seq) {
        if (!running) return;
        while (paused) { await new Promise(r => setTimeout(r, 60)); }
        flashPad(id, msPer);
        await new Promise(r => setTimeout(r, msPer));
      }
    }

    function nextLevel(msPer) {
      if (!running) return;
      level += 1;
      // extend sequence
      const next = Math.floor(Math.random() * 9) + 1;
      sequence.push(next);
      userIndex = 0;
      // play
      playSequence(sequence, msPer).then(() => {
        // ready for user input
      });
    }

    function handleUserPress(id) {
      if (!running || paused) return;
      const expect = sequence[userIndex];
      if (id === expect) {
        userIndex += 1;
        score += 10;
        scoreEl.textContent = String(score);
        if (userIndex >= sequence.length) {
          // completed level
          setTimeout(() => {
            const msPer = padMsFromSpeed(speedEl.value);
            nextLevel(msPer);
          }, spawnDelay);
        }
      } else {
        // mistake: small penalty
        score = Math.max(0, score - 5);
        scoreEl.textContent = String(score);
        userIndex = 0; // retry current sequence from start
      }
    }

    // ===== Event wiring =====
    startBtn.addEventListener('click', startSession);
    pauseBtn.addEventListener('click', () => pauseToggle());
    resumeBtn.addEventListener('click', () => pauseToggle(false));
    exitBtn.addEventListener('click', exitToSettings);

    // also wire disabled settings actions (for parity/UX)
    pauseBtnSettings.addEventListener('click', () => pauseToggle());
    restartBtnSettings.addEventListener('click', () => {
      if (!document.fullscreenElement) return;
      // restart = exit to settings then start again with same values
      const mins = durationEl.value, size = sizeEl.value, speed = speedEl.value, spawn = spawnEl.value;
      exitToSettings().then(() => {
        durationEl.value = mins; sizeEl.value = size; speedEl.value = speed; spawnEl.value = spawn;
        startSession();
      });
    });

    // Pads
    pads.forEach(p => {
      p.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        handleUserPress(parseInt(p.dataset.id, 10));
      }, { passive: false });
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (endModal.open) return;
      if (e.key === 'p' || e.key === 'P') {
        pauseToggle();
      } else if (e.key === 'Escape') {
        if (endModal.open) endModal.close(); else exitToSettings();
      } else if (/^[1-9]$/.test(e.key)) {
        handleUserPress(parseInt(e.key, 10));
      }
    });

    // End modal actions
    newSessionBtn.addEventListener('click', (e) => {
      e.preventDefault();
      endModal.close();
      startSession();
    });
    closeSummaryBtn.addEventListener('click', (e) => {
      e.preventDefault();
      endModal.close();
      exitToSettings();
    });

    // Clean up fullscreen state if the user swipes away
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement && screens.game.classList.contains('active')) {
        // if fullscreen exits unexpectedly, go back to settings to avoid odd states
        exitToSettings();
      }
    });
  </script>
</body>
</html>
