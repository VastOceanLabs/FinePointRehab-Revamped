<!DOCTYPE html>
<html lang="en">
<head>
  <!-- BUILD: Rhythm Reach unified lighting (fixed) — 2025-09-14 -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rhythm Reach | Fine Point Rehab</title>
  <meta name="description" content="Repeat the rhythm pattern by...tapping the pads. Mobile-first, accessible therapy exercise." />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- Design system -->
  <link rel="stylesheet" href="/css/tokens.css">
  <link rel="stylesheet" href="/css/base.css">
  <link rel="stylesheet" href="/css/components.css">
  <link rel="stylesheet" href="/css/exercises.css">

  <style>
    body {
      background:
        radial-gradient(ellipse at 20% 30%, rgba(40,20,80,0.4) 0%, transparent 40%),
        radial-gradient(ellipse at 80% 70%, rgba(20,40,80,0.3) 0%, transparent 40%),
        radial-gradient(ellipse at 50% 50%, rgba(10,20,40,0.5) 0%, transparent 70%),
        linear-gradient(180deg, #0a0e1a 0%, #1a1f3a 50%, #0f1524 100%);
      min-height: 100dvh;
    }

    header.app-header {
      position: sticky; top: 0; z-index: 100; display: flex; align-items: center; gap: var(--space-4);
      padding: var(--space-3) var(--space-4);
      background: linear-gradient(180deg, rgba(8,12,26,0.90) 0%, rgba(8,12,26,0.55) 100%);
      -webkit-backdrop-filter: blur(16px); backdrop-filter: blur(16px);
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .home-pill { display:inline-flex; align-items:center; gap:.5rem; border:1px solid rgba(255,255,255,0.08); padding:.5rem .75rem; border-radius:999px; background: rgba(20,30,50,0.6); color:#cfe3ff; text-decoration:none; font-weight:600; transition: transform var(--duration-fast) var(--easing), box-shadow var(--duration-fast) var(--easing); }
    .home-pill:hover { transform: translateY(-1px); box-shadow: var(--shadow); }
    header.app-header h1 { color:#e6f2ff; font-size: var(--font-size-2xl); margin:0; letter-spacing:.2px; }
    .spacer { flex:1; }

    main { display:grid; grid-template-columns: 1fr; gap: var(--space-4); padding: var(--space-4); max-width: 1200px; margin: 0 auto; }
    @media (min-width: 900px){
      main { grid-template-columns: 360px 1fr; align-items:start; }
    }

    .card { background: linear-gradient(180deg, rgba(22,28,50,0.85) 0%, rgba(16,20,38,0.85) 100%); border:1px solid rgba(255,255,255,0.08); border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.35); overflow:hidden; }
    .card h2 { margin:0; padding: var(--space-3) var(--space-4); font-size: var(--font-size-xl); color:#e8f1ff; border-bottom:1px solid rgba(255,255,255,0.06); background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0)); }
    .card .content { padding: var(--space-4); color:#d7e4ff; }
    .muted { color: #a9b7d9; }

    .hud-row { display:flex; flex-wrap:wrap; gap: var(--space-3); align-items:center; }
    .hud-pill { background: rgba(18,26,48,0.8); border:1px solid rgba(255,255,255,0.07); border-radius: 999px; padding:.5rem .75rem; color:#e8f1ff; font-weight:600; min-width: 90px; text-align:center; }

    .pb-box { display:grid; grid-template-columns: 1fr auto; align-items:center; gap: var(--space-2); background: rgba(18,26,48,0.6); border:1px solid rgba(255,255,255,0.08); border-radius: 12px; padding:.75rem .9rem; }
    .pb-box .label { color:#a9b7d9; font-size:.9rem; }
    .pb-box .value { color:#e8f1ff; font-weight:700; font-size:1.1rem; }

    .grid { display:grid; grid-template-columns: repeat(3, minmax(72px, 1fr)); gap: clamp(10px, 3vw, 16px); justify-items: center; align-items: center; max-width: 520px; margin: 0 auto; }
    .pad { width: 100%; aspect-ratio: 1; border-radius: 16px; border:1px solid rgba(255,255,255,0.1);
      background: radial-gradient(120% 120% at 30% 30%, rgba(120,150,255,0.18) 0%, rgba(120,150,255,0.08) 40%, rgba(20,26,46,0.9) 70%), linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0));
      box-shadow: inset 0 0 0 1px rgba(140,170,255,0.15), 0 8px 18px rgba(0,0,0,0.35);
      position: relative; overflow:hidden; cursor:pointer; transition: transform var(--duration-fast) var(--easing), box-shadow var(--duration-fast) var(--easing), border-color var(--duration-fast) var(--easing);
      display:grid; place-items:center; color:#cfe3ff; font-weight:700; letter-spacing:.4px;
    }
    .pad::after { content:""; position:absolute; inset:-20%; opacity:0; pointer-events:none;
      background: radial-gradient(120% 120% at 50% 50%, rgba(120,170,255,0.40) 0%, rgba(120,170,255,0.22) 35%, rgba(120,170,255,0.06) 65%, transparent 75%);
      filter: blur(10px); transform: scale(0.92); transition: opacity var(--duration-fast) var(--easing), transform var(--duration-fast) var(--easing);
    }
    .pad.glow { border-color: rgba(150, 190, 255, 0.85); box-shadow: inset 0 0 0 1px rgba(160,190,255,0.45), 0 0 0 2px rgba(120,170,255,0.12), 0 10px 24px rgba(60,100,200,0.55); }
    .pad.glow::after { opacity:1; transform: scale(1); }
    .pad.wrong { box-shadow: inset 0 0 0 1px rgba(255,120,120,0.7), 0 10px 22px rgba(255,60,60,0.45); border-color: rgba(255,140,140,0.9); }
    .pad:active { transform: translateY(1px); }

    .controls { display:grid; gap: var(--space-3); }
    .controls label { display:grid; gap:.5rem; color:#cfe3ff; }
    .controls input, .controls select, .controls button { width:100%; }

    .btn-primary { appearance:none; border:none; border-radius: 12px; padding: .8rem 1rem; font-weight: 800; letter-spacing:.3px; cursor:pointer;
      background: linear-gradient(180deg, #4cc0ff, #1a7fd0); color:#001225; box-shadow: 0 10px 22px rgba(0,80,160,0.45), inset 0 1px 0 rgba(255,255,255,0.35);
      transition: transform var(--duration-fast) var(--easing), filter var(--duration-fast) var(--easing);
    }
    .btn-primary:hover { transform: translateY(-1px); filter: brightness(1.03); }
    .btn-ghost { background: transparent; color:#d7e4ff; border:1px solid rgba(255,255,255,0.12); border-radius: 12px; padding:.7rem 1rem; font-weight:700; }

    .help { color:#a9b7d9; line-height:1.5; }

    /* Screens */
    [data-screen]{ display:none; }
    [data-screen].active{ display:block; }

  </style>
</head>
<body>
  <header class="app-header">
    <a href="/" class="home-pill">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M3 9.5L12 3l9 6.5V21a1 1 0 0 1-1 1h-5v-6H9v6H4a1 1 0 0 1-1-1V9.5Z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round"/></svg>
      Home
    </a>
    <h1>Rhythm Reach</h1>
    <div class="spacer"></div>
  </header>

  <main>
    <!-- Left: Settings -->
    <section class="card" id="settings-screen" data-screen>
      <h2>Settings</h2>
      <div class="content controls">
        <div class="pb-box" aria-live="polite">
          <div class="label">Personal Best</div>
          <div class="value"><span id="best">0</span></div>
        </div>

        <label>
          <span>Starting length</span>
          <input id="startLen" type="number" min="1" max="9" value="3" inputmode="numeric">
        </label>

        <label>
          <span>Show speed</span>
          <select id="speed">
            <option value="slow">Slow</option>
            <option value="med" selected>Medium</option>
            <option value="fast">Fast</option>
          </select>
        </label>

        <label>
          <span>Round gap (ms)</span>
          <select id="roundGap">
            <option value="1200">1200</option>
            <option value="1500" selected>1500</option>
            <option value="2000">2000</option>
          </select>
        </label>

        <button class="btn-primary" id="start">Start</button>

        <div class="help">
          <p><strong>How to play:</strong> Watch the glowing tiles. After the sequence finishes, repeat it by tapping the same tiles in order.</p>
          <p>The tiles glow the same way during playback and when you tap them yourself, so feedback is consistent and easy to read.</p>
        </div>
      </div>
    </section>

    <!-- Right: Game -->
    <section class="card active" id="game-screen" data-screen>
      <h2>Game</h2>
      <div class="content">
        <div class="hud-row" style="margin-bottom: var(--space-4);">
          <div class="hud-pill">Score: <span id="score">0</span></div>
          <div class="hud-pill">Best: <span id="pb">0</span></div>
          <div class="hud-pill">Time: <span id="time">00:00</span></div>
          <div class="spacer"></div>
          <button class="btn-ghost" id="pause">Pause</button>
          <button class="btn-ghost" id="end">End</button>
        </div>

        <div class="grid" id="grid" aria-label="Rhythm pads">
          <button class="pad" data-idx="1" aria-label="Pad 1">1</button>
          <button class="pad" data-idx="2" aria-label="Pad 2">2</button>
          <button class="pad" data-idx="3" aria-label="Pad 3">3</button>
          <button class="pad" data-idx="4" aria-label="Pad 4">4</button>
          <button class="pad" data-idx="5" aria-label="Pad 5">5</button>
          <button class="pad" data-idx="6" aria-label="Pad 6">6</button>
          <button class="pad" data-idx="7" aria-label="Pad 7">7</button>
          <button class="pad" data-idx="8" aria-label="Pad 8">8</button>
          <button class="pad" data-idx="9" aria-label="Pad 9">9</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Utilities
    const sleep = (ms) => new Promise(res => { const t = setTimeout(()=>{activeTimeouts.delete(t); res();}, ms); activeTimeouts.add(t); });
    function clearAllTimers(){ activeTimeouts.forEach(t=>clearTimeout(t)); activeTimeouts.clear(); }

    let playbackToken = 0;

    // Elements
    const pads = Array.from(document.querySelectorAll('.pad'));
    const grid = document.getElementById('grid');

    const startBtn = document.getElementById('start');
    const pauseBtn = document.getElementById('pause');
    const endBtn = document.getElementById('end');

    const startLenInput = document.getElementById('startLen');
    const speedSelect = document.getElementById('speed');
    const roundGapSelect = document.getElementById('roundGap');

    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const pbSettingEl = document.getElementById('pb');
    const timeEl = document.getElementById('time');

    const activeTimeouts = new Set();

    // Screens
    function setScreen(which){
      document.querySelectorAll('[data-screen]').forEach(el => el.classList.remove('active'));
      document.getElementById(which + '-screen').classList.add('active');
    }

    // Pad lighting (single source of truth)
    const Light = (() => {
      let lit = null;       // current lit pad index (1..9) or null
      let to = null;        // single timeout for auto-off

      function off(){
        if(to){ clearTimeout(to); to = null; }
        if(lit !== null){
          const el = pads[lit-1]; if(el) el.classList.remove('glow');
          lit = null;
        }
      }
      function on(idx, duration){
        // switch atomically: off previous, on new
        off();
        const el = pads[idx-1]; if(!el) return;
        lit = idx;
        el.classList.add('glow');
        to = setTimeout(() => { to = null; off(); }, Math.max(60, Number(duration)||0));
      }
      function isLit(){ return lit !== null; }
      return { on, off, isLit };
    })();

    // Wrong feedback (kept as class with short timeout)
    function wrongPad(idx){
      const el = pads[idx-1]; if(!el) return;
      el.classList.add('wrong');
      const t = setTimeout(()=>{ el.classList.remove('wrong'); activeTimeouts.delete(t); }, 280);
      activeTimeouts.add(t);
    }

    function readPB(){
      const v = Number(localStorage.getItem(LS_KEY) || '0');
      best = isFinite(v) ? v : 0; bestEl.textContent = best; pbSettingEl.textContent = best;
    }
    function writePB(v){
      localStorage.setItem(LS_KEY, String(v));
      readPB();
    }

    // Game state
    const LS_KEY = 'FPR_v1_rhythm_best';
    let running = false, paused = false, playback = false;
    let score = 0, best = 0, rounds = 0;
    let seq = [], userIndex = 0;

    // Timer
    let timerId = null, startTs = 0;
    function startTimer(minutes){
      if(timerId){ clearInterval(timerId); timerId=null; }
      startTs = Date.now();
      timerId = setInterval(() => {
        const s = Math.floor((Date.now()-startTs)/1000);
        const mm = String(Math.floor(s/60)).padStart(2,'0');
        const ss = String(s%60).padStart(2,'0');
        timeEl.textContent = `${mm}:${ss}`;
      }, 200);
    }
    function stopTimer(){ if(timerId){ clearInterval(timerId); timerId=null; } }

    // Timings
    function playbackTimings(){
      const speed = speedSelect.value; let glow = 550, gap = 220;
      if(speed === 'slow'){ glow = 700; gap = 300; }
      if(speed === 'med'){ glow = 550; gap = 220; }
      if(speed === 'fast'){ glow = 380; gap = 160; }
      return { glow, gap };
    }

    // Playback loop – ONLY this controls .glow during sequence
    async function playSequence(){
      const myToken = ++playbackToken; playback = true;

      // ensure clean slate
      Light.off(); clearAllPadStates();

      const { glow, gap } = playbackTimings();
      const roundDelay = Number(roundGapSelect.value) || 1500;

      await sleep(roundDelay);
      if(myToken !== playbackToken || !running){ playback = false; return; }

      for(let i=0;i<seq.length;i++){
        // pause handling
        while(paused && myToken === playbackToken && running){ await sleep(50); }
        if(myToken !== playbackToken || !running) break;

        const idx = seq[i];
        Light.on(idx, glow);          // turn on one pad
        await sleep(glow + gap);      // wait ON + GAP before next
        if(myToken !== playbackToken || !running) break;
      }

      // make absolutely sure no light remains on
      Light.off();

      playback = false; userIndex = 0;
    }

    // Session control
    function resetSessionState(){
      running = false; paused = false; playback = false; ++playbackToken;
      stopTimer(); clearAllTimers(); Light.off(); clearAllPadStates();
      score = 0; rounds = 0; seq = []; userIndex = 0;
      scoreEl.textContent = '0'; timeEl.textContent = '00:00';
    }

    async function startSession(){
      resetSessionState(); readPB();

      const startLen = clamp(Number(startLenInput.value)||3, 1, 9);
      for(let i=0;i<startLen;i++) seq.push(randPad());

      running = true; setScreen('game'); startTimer(minutesInput.value);
      await playSequence();
    }

    function endSession(){
      if(!running && !paused) return;
      running = false; paused = false; playback = false; ++playbackToken;
      stopTimer(); Light.off(); clearAllPadStates();
      if(score > best){ writePB(score); }
      setScreen('settings');
    }

    function togglePause(){
      if(!running) return;
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      grid.classList.toggle('open', paused);
    }
    function exitFlow(){
      if(running || paused){ endSession(); }
      else { clearAllTimers(); Light.off(); clearAllPadStates(); setScreen('settings'); }
    }

    // Extra safety: if page hides or visibility changes, stop playback lighting
    document.addEventListener('visibilitychange', () => {
      if(document.hidden){ Light.off(); }
    });

    // Helpers
    function randPad(){ return 1 + Math.floor(Math.random()*9); }
    function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }
    function clearAllPadStates(){ pads.forEach(p => { p.classList.remove('glow','wrong'); }); }

    // User input – identical visual timing to playback
    function onUserPad(idx){
      if(!running || paused || playback) return;
      const expected = seq[userIndex];
      if(idx === expected){
        // Use the same Light system with a longer, more visible duration for user feedback
        Light.on(idx, playbackTimings().glow); // Increased from 200ms to 300ms for better visibility
        if(navigator.vibrate){ try{ navigator.vibrate(15); }catch(e){} }
        
        score += 10; scoreEl.textContent = String(score);
        userIndex++;
        if(userIndex >= seq.length){
          // next round - add a small delay before starting new sequence
          setTimeout(() => { Light.off(); clearAllPadStates();
            rounds++; seq.push(randPad());
            playSequence();
          }, 500);
        }
      } else {
        wrongPad(idx);
        score = Math.max(0, score - 5); scoreEl.textContent = String(score);
        userIndex = 0;
      }
    }

    // Bindings
    const minutesInput = { value: 9999 }; // no round timer limit; keep simple
    pads.forEach(p => p.addEventListener('click', e => onUserPad(Number(p.dataset.idx))));
    startBtn.addEventListener('click', startSession);
    endBtn.addEventListener('click', endSession);
    pauseBtn.addEventListener('click', togglePause);

    // Init
    readPB(); setScreen('settings');
  </script>
</body>
</html>
