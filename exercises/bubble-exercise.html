<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Bubble Tap — Fine Point Rehab</title>

  <!-- Global tokens & components -->
  <link rel="stylesheet" href="/css/tokens.css">
  <link rel="stylesheet" href="/css/base.css">
  <link rel="stylesheet" href="/css/components.css">

  <style>
    :root{
      --vh: 1vh;
      --bg-1:#070b16; --bg-2:#0f1630; --bg-3:#0b1024;
      --accent: var(--brand-aqua, #6fd3f5);
      --accent-2: #9ae6ff;
      --radius: 14px;
      --panel: rgba(10,16,36,.9);
      --panel-border: rgba(255,255,255,.08);
      --text: #eaf6ff;
      --good: #8ff5b2;
    }
    body{ margin:0; color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 25%, rgba(70,30,120,.35), transparent 60%),
        radial-gradient(900px 700px at 75% 65%, rgba(20,120,160,.28), transparent 55%),
        linear-gradient(180deg, var(--bg-1) 0%, var(--bg-2) 50%, var(--bg-3) 100%);
      min-height: calc(var(--vh) * 100);
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
    }
    body.playing { overflow: hidden; }
    body.playing header.app { display: none; }

    header.app{
      position: sticky; top:0; z-index: 50;
      padding:12px 16px; display:flex; gap:12px; align-items:center;
      background: linear-gradient(180deg, rgba(8,12,26,.9), rgba(8,12,26,.55));
      border-bottom: 1px solid rgba(255,255,255,.06);
      backdrop-filter: blur(6px);
    }
    header .home { text-decoration:none; color:var(--text); font-weight:700;
      border:1px solid rgba(255,255,255,.18); border-radius:999px; padding:8px 12px; }
    header h1{ margin:0; font-size: clamp(18px,3vw,24px); }

    .layout{ display:grid; grid-template-columns: 1fr; gap:16px; padding:16px; height:auto; }
    .panel{ background: var(--panel); border: 1px solid var(--panel-border); border-radius: var(--radius);
            box-shadow: 0 10px 40px rgba(0,0,0,.35); padding:16px; }
    .panel h2{ margin:0 0 12px 0; font-size: clamp(18px,3vw,22px); }
    .desc{ margin-bottom:12px; background: rgba(111,211,245,.08);
           border-left: 4px solid rgba(111,211,245,.7); padding:10px; border-radius:8px; font-size:14px; line-height:1.5; }

    /* Stats on settings (shows PB) */
    .stats-row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-bottom:12px; }
    .metric{ flex:0 0 auto; display:flex; flex-direction:column; align-items:center; justify-content:center;
             text-align:center; padding:8px 12px; border:1px solid rgba(255,255,255,.12); border-radius:12px;
             background: rgba(255,255,255,.05); min-width:110px; }
    .v{ font-weight:900; font-size:18px; color:#bfe6ff; text-shadow: 0 0 6px rgba(150,220,255,.5); line-height:1.1; }
    .t{ font-size:11px; opacity:.9; margin-top:3px; }

    .group{ margin-bottom:12px; }
    .label{ display:block; margin-bottom:6px; font-weight:700; letter-spacing:.2px; }
    select, input[type="number"]{
      width:100%; padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,.2);
      background: rgba(5,10,26,.8); color:var(--text); font-size:16px;
    }
    select:focus, input[type="number"]:focus{
      outline:none; border-color: rgba(111,211,245,.9); box-shadow: 0 0 0 2px rgba(111,211,245,.25);
    }
    .btn{
      min-height:46px; border:1px solid rgba(111,211,245,.35); background: rgba(111,211,245,.12);
      color:var(--text); border-radius:10px; font-weight:800; letter-spacing:.2px; cursor:pointer; transition:.2s;
    }
    .btn:hover:not(:disabled){ background: rgba(111,211,245,.22); transform: translateY(-1px); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }
    .btn-primary{ background: rgba(111,211,245,.95); color:#07101e; border-color: rgba(111,211,245,1); }
    .btn-primary:hover:not(:disabled){ background: rgba(111,211,245,1); box-shadow: 0 6px 18px rgba(111,211,245,.45); }
    .btn-ghost{ background: transparent; border:1px solid rgba(255,255,255,.15); }

    /* Game column – hidden until playing */
    #gameCol{ display:none; position:relative; padding:0; overflow:hidden; }
    body.playing #gameCol{ display:block; }
    body.playing #settings{ display:none; }

    .hud{
      position:sticky; top:0; z-index:5; display:flex; gap:8px; align-items:center; justify-content:space-between;
      padding:10px; background: linear-gradient(180deg, rgba(6,10,22,.88), rgba(6,10,22,.55)); border-bottom:1px solid rgba(255,255,255,.06);
    }
    .hud .metrics{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .chip{ display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:92px;
           border:1px solid rgba(255,255,255,.18); border-radius:10px; padding:6px 10px; background: rgba(255,255,255,.06); }
    .chip .v{ font-size:16px; font-weight:800; color:#c9ecff; }
    .chip .t{ font-size:11px; opacity:.9; }

    .hud .controls{ display:flex; gap:8px; }
    .stage-wrap{ position:relative; width:100%; height: calc(var(--vh) * 100); }

    /* Bubble game surface (DOM-based) */
    .game-surface{ position:relative; width:100%; height:100%; overflow:hidden; }
    #bubble{
      position:absolute; width:80px; height:80px; border-radius:50%;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(111,211,245,.35) 40%, rgba(20,80,150,.35) 70%, rgba(10,20,40,.25) 100%),
        radial-gradient(120px 120px at 70% 80%, rgba(255,255,255,.25), transparent 60%);
      box-shadow:
        0 0 0 1px rgba(255,255,255,.15) inset,
        0 12px 30px rgba(111,211,245,.35),
        inset 0 0 22px rgba(255,255,255,.6);
      transform: translate(-50%, -50%);
      touch-action: none;
      animation: bubblePulse 2.2s ease-in-out infinite;
    }
    #bubble.spawn {
      animation: bubbleSpawn .18s ease-out, bubblePulse 2.2s ease-in-out infinite;
    }
    @keyframes bubbleSpawn{
      from{ transform: translate(-50%, -50%) scale(.6); opacity:.0; filter: blur(2px); }
      to  { transform: translate(-50%, -50%) scale(1); opacity:1; filter: blur(0); }
    }
    @keyframes bubblePulse{
      0%,100%{ filter: drop-shadow(0 0 0 rgba(111,211,245,.0)); }
      50%    { filter: drop-shadow(0 0 12px rgba(111,211,245,.45)); }
    }

    /* Points popup */
    .points{
      position:absolute; transform: translate(-50%, -50%);
      font-weight:900; font-size:18px;
      color: var(--good); text-shadow: 0 0 10px rgba(143,245,178,.45);
      pointer-events:none; z-index:7;
      animation: floatUp 700ms ease-out forwards;
    }
    @keyframes floatUp{
      from{ opacity:0; transform: translate(-50%, -50%) translateY(6px) scale(.9); }
      20% { opacity:1; }
      to  { opacity:0; transform: translate(-50%, -50%) translateY(-36px) scale(1.05); }
    }

    /* Ripple effect */
    .ripple{
      position:absolute; transform: translate(-50%, -50%);
      width:10px; height:10px; border-radius:50%;
      border:2px solid var(--accent-2); opacity:.6;
      animation: ripple 600ms ease-out forwards;
      pointer-events:none; z-index:6;
    }
    @keyframes ripple{
      from{ opacity:.7; transform: translate(-50%, -50%) scale(.8); }
      to  { opacity:0; transform: translate(-50%, -50%) scale(8); }
    }

    /* Finger guide (guided mode) */
    .finger-guide{
      position:absolute; left:0; right:0; bottom:0; padding:12px; z-index:6;
      display:none;
    }
    .finger-guide .card{
      margin:0 auto; max-width:720px; border:1px solid rgba(255,255,255,.18); border-radius:12px;
      background: rgba(0,0,0,.35); padding:12px;
    }
    .fingers{ display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap; }
    .fingers .chip{
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      width:56px; height:56px; border-radius:50%;
      border:1px solid rgba(255,255,255,.18); background: rgba(255,255,255,.06);
      font-weight:800;
    }
    .fingers .chip .tiny{ font-size:10px; opacity:.9; margin-top:2px; font-weight:600; }
    .fingers .chip.active{
      border-color: var(--accent-2);
      box-shadow: 0 0 0 3px rgba(111,211,245,.25), 0 0 18px rgba(111,211,245,.45) inset;
      background: rgba(111,211,245,.12);
    }
    .guide-title{ text-align:center; font-weight:700; margin-bottom:8px; }

    /* Completion modal */
    .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:20;
            background: rgba(0,0,0,.45); backdrop-filter: blur(4px); }
    .modal.open{ display:flex; }
    .modal .card{ width:min(560px, 92vw); border:1px solid rgba(255,255,255,.18); border-radius:14px;
                  background: var(--panel); padding:16px; }

    @media (min-width: 920px){
      .layout{ grid-template-columns: 1fr 1.2fr; align-items:start; }
      body:not(.playing) #settings{ grid-column: 1 / -1; }
    }
  </style>
</head>
<body>
  <header class="app" role="banner" aria-label="Exercise header">
    <a class="home" href="/" aria-label="Back to Home">← Home</a>
    <h1>Bubble Tap</h1>
  </header>

  <main class="layout">
    <!-- SETTINGS -->
    <aside id="settings" class="panel" aria-label="Settings">
      <h2>Settings</h2>
      <div class="desc"><strong>How to play:</strong> tap the bubble as soon as it appears. Smaller bubbles are harder (more points). Use finger mode for single-finger training if needed.</div>

      <!-- Stats (PB shown on settings) -->
      <div class="stats-row" role="region" aria-label="Player stats">
        <div class="metric" aria-live="polite">
          <div id="pbSettings" class="v">0</div>
          <div class="t">Personal Best</div>
        </div>
      </div>

      <div class="group">
        <label class="label" for="dur">Session Duration (minutes)</label>
        <input id="dur" type="number" min="0.5" step="0.5" max="10" value="2" inputmode="decimal" />
      </div>

      <div class="group">
        <label class="label" for="size">Bubble Size</label>
        <select id="size">
          <option value="large">Large (Easier)</option>
          <option value="medium" selected>Medium</option>
          <option value="small">Small (Harder)</option>
        </select>
      </div>

      <div class="group">
        <label class="label" for="fingerMode">Finger Mode</label>
        <select id="fingerMode">
          <option value="any" selected>Any finger</option>
          <option value="single">Single finger (guided)</option>
        </select>
        <div id="singleFingerWrap" class="desc" style="display:none; margin-top:8px;">
          <strong>Guided mode:</strong> follow the highlighted finger chips at the bottom.
        </div>
      </div>

      <button id="startBtn" class="btn btn-primary" type="button" aria-label="Start session">Start</button>
    </aside>

    <!-- GAME COLUMN (hidden until playing) -->
    <section id="gameCol" class="panel" aria-label="Game">
      <!-- HUD -->
      <div class="hud" role="region" aria-label="In-game HUD">
        <div class="metrics">
          <div class="chip"><div id="score" class="v">0</div><div class="t">Score</div></div>
          <div class="chip"><div id="pb" class="v">0</div><div class="t">PB</div></div>
          <div class="chip"><div id="time" class="v">00:00</div><div class="t">Time</div></div>
        </div>
        <div class="controls">
          <button id="pauseBtn" class="btn btn-ghost" type="button" aria-label="Pause">Pause</button>
          <button id="exitBtn" class="btn btn-ghost" type="button" aria-label="Exit to settings">Exit</button>
        </div>
      </div>

      <!-- Play surface -->
      <div class="stage-wrap">
        <div id="surface" class="game-surface" aria-label="Play area">
          <div id="bubble" role="button" aria-label="Bubble" tabindex="0"></div>

          <!-- Guided finger UI -->
          <div id="fingerGuide" class="finger-guide" aria-live="polite">
            <div class="card">
              <div class="guide-title">Tap with the highlighted finger</div>
              <div class="fingers" id="fingersRow">
                <!-- Chips will be filled by JS -->
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Completion Modal -->
  <div id="done" class="modal" role="dialog" aria-modal="true" aria-labelledby="doneTitle" aria-describedby="doneDesc">
    <div class="card">
      <h2 id="doneTitle" style="margin:0 0 8px 0;">Session Complete</h2>
      <p id="doneDesc" style="margin:0 0 12px 0;">Nice work! Here are your results:</p>
      <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px;">
        <div class="metric"><div id="fScore" class="v">0</div><div class="t">Score</div></div>
        <div class="metric"><div id="fTaps" class="v">0</div><div class="t">Taps</div></div>
        <div class="metric"><div id="fAcc" class="v">0%</div><div class="t">Accuracy</div></div>
        <div class="metric"><div id="fAvg" class="v">0ms</div><div class="t">Avg RT</div></div>
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="newSession" class="btn btn-primary" type="button">Start New Session</button>
        <a class="btn btn-ghost" href="/" aria-label="Home">Home</a>
      </div>
    </div>
  </div>

  <script type="module">
    // ===== Helpers =====
    const $ = sel => document.querySelector(sel);
    const el = (tag, cls, text) => {
      const e = document.createElement(tag);
      if(cls) e.className = cls;
      if(text!=null) e.textContent = text;
      return e;
    };

    // DOM
    const settingsEl = $('#settings');
    const gameCol = $('#gameCol');
    const surface = $('#surface');
    const bubbleEl = $('#bubble');
    const fingerGuide = $('#fingerGuide');
    const fingersRow = $('#fingersRow');
    const startBtn = $('#startBtn');
    const pauseBtn = $('#pauseBtn');
    const exitBtn = $('#exitBtn');
    const timeEl = $('#time');
    const scoreEl = $('#score');
    const pbEl = $('#pb');
    const pbSettingsEl = $('#pbSettings');
    const doneModal = $('#done');
    const fScore = $('#fScore'), fTaps = $('#fTaps'), fAcc = $('#fAcc'), fAvg = $('#fAvg');
    const newSessionBtn = $('#newSession');

    // Settings inputs
    const durIn = $('#dur'), sizeSel = $('#size'), fmSel = $('#fingerMode'), singleWrap = $('#singleFingerWrap');

    // Storage & modules (graceful fallbacks)
    const EXERCISE_ID = 'bubble_tap';
    const NullEnhancement = { initializeExercise(){}, handleSessionComplete(){} };
    const NullAudio = { play(){}, click(){}, miss(){} };
    const storageFallback = {
      get:(k, def)=>{ try { return JSON.parse(localStorage.getItem(k)) ?? def; } catch { return def; } },
      set:(k,v)=>{ try { localStorage.setItem(k, JSON.stringify(v)); } catch {} }
    };
    let storage = storageFallback, audio = NullAudio, sessionEnhancement = NullEnhancement;
    let recordSession = (id, diff, score)=>{}, checkAndUnlockAchievements = ()=>{}, markExerciseTried = ()=>{};
    let starfield = null, initUtils = ()=>{};

    try {
      const u = await import('/js/utils.js');
      storage = u.storage ?? storage;
      starfield = u.starfield ?? starfield;
      initUtils = u.initUtils ?? initUtils;
      audio = u.audio ?? audio;
    } catch {}
    try {
      const s = await import('/js/session-enhancement.js');
      sessionEnhancement = s.sessionEnhancement ?? sessionEnhancement;
    } catch {}
    try {
      const p = await import('/js/progress.js');
      recordSession = p.recordSession ?? recordSession;
    } catch {}
    try {
      const a = await import('/js/achievements.js');
      checkAndUnlockAchievements = a.checkAndUnlockAchievements ?? checkAndUnlockAchievements;
      markExerciseTried = a.markExerciseTried ?? markExerciseTried;
    } catch {}

    // ===== Geometry & fullscreen =====
    function setVH(){ document.documentElement.style.setProperty('--vh', (window.innerHeight*0.01)+'px'); }
    setVH(); addEventListener('resize', setVH); addEventListener('orientationchange', setVH);

    async function enterImmersive(){
      document.body.classList.add('playing');
      try { await document.documentElement.requestFullscreen?.(); } catch {}
    }
    async function exitImmersive(){
      document.body.classList.remove('playing');
      try { await document.exitFullscreen?.(); } catch {}
    }

    // ===== Session state =====
    let isActive = false, isPaused = false;
    let taps = 0, misses = 0, score = 0, totalRT = 0;
    let sessionDurationMs = 2 * 60 * 1000, timeRemaining = sessionDurationMs;
    let bubbleSizePx = 80;
    let fingerMode = 'any';
    let lastSpawn = 0, bubbleVisible = false, bubbleSpawnTime = 0;

    const BUBBLE_SIZES = { large: 120, medium: 80, small: 56 };

    // Guided fingers
    const FINGERS = [
      { key:'T', name:'Thumb' },
      { key:'I', name:'Index' },
      { key:'M', name:'Middle' },
      { key:'R', name:'Ring' },
      { key:'L', name:'Little' },
    ];
    let fingerIdx = -1;

    function buildFingerChips(){
      fingersRow.innerHTML = '';
      FINGERS.forEach((f,i) => {
        const chip = el('div', 'chip');
        chip.append(el('div', '', f.key));
        chip.append(el('div', 'tiny', f.name));
        chip.dataset.idx = i;
        fingersRow.append(chip);
      });
    }
    function highlightFinger(i){
      [...fingersRow.children].forEach(ch => ch.classList.toggle('active', Number(ch.dataset.idx) === i));
    }

    function msToClock(ms){
      const s = Math.max(0, Math.floor(ms/1000));
      const m = Math.floor(s/60);
      const rem = s % 60;
      return String(m).padStart(2,'0')+':'+String(rem).padStart(2,'0');
    }

    function updateHUD(){
      timeEl.textContent = msToClock(timeRemaining);
      scoreEl.textContent = String(score);
      const pb = storage.get('PB_'+EXERCISE_ID, 0) || 0;
      pbEl.textContent = String(pb);
      pbSettingsEl.textContent = String(pb);
    }

    function showFingerGuide(show){ fingerGuide.style.display = show ? 'block' : 'none'; }

    function spawnBubble(){
      const rect = surface.getBoundingClientRect();
      const x = Math.random() * (rect.width - bubbleSizePx) + bubbleSizePx/2;
      const y = Math.random() * (rect.height - bubbleSizePx) + bubbleSizePx/2;
      bubbleEl.style.left = x+'px'; bubbleEl.style.top = y+'px';
      bubbleEl.style.width = bubbleSizePx+'px'; bubbleEl.style.height = bubbleSizePx+'px';
      bubbleVisible = true;
      bubbleSpawnTime = performance.now();
      bubbleEl.classList.remove('spawn'); void bubbleEl.offsetWidth; bubbleEl.classList.add('spawn');

      // Cycle finger prompt in guided mode
      if(fingerMode === 'single'){
        fingerIdx = (fingerIdx + 1) % FINGERS.length;
        highlightFinger(fingerIdx);
      }
    }

    function hideBubble(){ bubbleVisible = false; bubbleEl.style.left = '-9999px'; bubbleEl.style.top = '-9999px'; }

    function showPoints(x, y, pts){
      const p = el('div', 'points', `+${pts}`);
      p.style.left = x + 'px'; p.style.top = y + 'px';
      surface.append(p);
      p.addEventListener('animationend', () => p.remove());
    }
    function ripple(x, y){
      const r = el('div', 'ripple');
      r.style.left = x + 'px'; r.style.top = y + 'px';
      surface.append(r);
      r.addEventListener('animationend', () => r.remove());
    }

    // Input handlers
    bubbleEl.addEventListener('pointerdown', (ev) => {
      if(!isActive || isPaused || !bubbleVisible) return;
      const rt = performance.now() - bubbleSpawnTime;
      const pts = Math.max(1, Math.round(1500/Math.max(200, rt)));
      taps++; score += pts; totalRT += rt;
      showPoints(parseFloat(bubbleEl.style.left), parseFloat(bubbleEl.style.top), pts);
      ripple(parseFloat(bubbleEl.style.left), parseFloat(bubbleEl.style.top));
      hideBubble();
      audio.click?.();
    });
    bubbleEl.addEventListener('keydown', (e) => {
      if(e.key === ' ' || e.key === 'Enter'){
        e.preventDefault();
        bubbleEl.dispatchEvent(new PointerEvent('pointerdown'));
      }
    });
    surface.addEventListener('pointerdown', (e) => {
      if(!isActive || isPaused) return;
      if(e.target !== bubbleEl){ misses++; audio.miss?.(); }
    }, { passive:true });

    // Timer/loop with real delta
    let rafId = 0, prevTs = 0;
    function loop(now){
      if(!isActive) return;
      const dt = prevTs ? (now - prevTs) : 16;
      prevTs = now;
      if(!isPaused){
        timeRemaining -= dt;
        if(timeRemaining <= 0){ endSession(); return; }
        if(!bubbleVisible && (now - lastSpawn) > 450){
          spawnBubble(); lastSpawn = now;
        }
      }
      updateHUD();
      rafId = requestAnimationFrame(loop);
    }

    // ===== Controls =====
    function startSession(){
      // Read settings
      const durMin = Math.max(0.5, parseFloat(durIn.value || '2'));
      sessionDurationMs = durMin * 60 * 1000;
      timeRemaining = sessionDurationMs;
      bubbleSizePx = BUBBLE_SIZES[sizeSel.value] ?? 80;
      fingerMode = fmSel.value;
      showFingerGuide(fingerMode === 'single');

      // Reset
      isActive = true; isPaused = false; pauseBtn.textContent = 'Pause';
      taps = 0; misses = 0; score = 0; totalRT = 0;
      fingerIdx = -1;
      if(fingerMode === 'single'){ buildFingerChips(); }
      hideBubble(); updateHUD();

      // UI
      enterImmersive();
      requestAnimationFrame(ts => { lastSpawn = prevTs = ts; rafId = requestAnimationFrame(loop); });

      try { sessionEnhancement.initializeExercise?.('bubble_tap'); } catch {}
      try { markExerciseTried(EXERCISE_ID); } catch {}
    }

    function pauseSession(){
      if(!isActive) return;
      isPaused = !isPaused;
      pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
    }

    function exitToSettings(){
      if(isActive) { isActive = false; cancelAnimationFrame(rafId); }
      prevTs = 0;
      hideBubble();
      exitImmersive();
      pauseBtn.textContent = 'Pause';
      doneModal.classList.remove('open');
    }

    function endSession(){
      isActive = false; cancelAnimationFrame(rafId);
      prevTs = 0;
      hideBubble(); exitImmersive();

      const total = taps + misses;
      const acc = total > 0 ? Math.round((taps/total)*100) : 0;
      const avg = taps > 0 ? Math.round(totalRT / taps) : 0;

      fScore.textContent = String(score);
      fTaps.textContent = String(taps);
      fAcc.textContent = acc + '%';
      fAvg.textContent = avg + 'ms';

      // PB
      const prev = storage.get('PB_'+EXERCISE_ID, 0) || 0;
      if(score > prev){ storage.set('PB_'+EXERCISE_ID, score); }

      // Progress + achievements
      try { recordSession(EXERCISE_ID, (sizeSel.value||'medium'), score); } catch {}
      try { checkAndUnlockAchievements(); } catch {}

      doneModal.classList.add('open');
      try { sessionEnhancement.handleSessionComplete?.('bubble_tap', { score, taps, acc, avg }); } catch {}
    }

    // Buttons
    startBtn.addEventListener('click', () => { doneModal.classList.remove('open'); startSession(); });
    pauseBtn.addEventListener('click', pauseSession);
    exitBtn.addEventListener('click', exitToSettings);
    newSessionBtn.addEventListener('click', () => { doneModal.classList.remove('open'); startSession(); });

    // Settings interactivity
    fmSel.addEventListener('change', () => { singleWrap.style.display = fmSel.value === 'single' ? '' : 'none'; });
    singleWrap.style.display = (fmSel.value === 'single') ? '' : 'none';

    // Modal UX: backdrop click + Esc
    doneModal.addEventListener('click', (e) => { if(e.target === doneModal){ doneModal.classList.remove('open'); } });
    addEventListener('keydown', (e) => { if(e.key === 'Escape') doneModal.classList.remove('open'); });

    // Init
    updateHUD();
    (async () => {
      try { await initUtils?.({ starfieldTarget: surface }); } catch {}
      const tryStarfield = () => {
        if(surface.clientHeight > 0){ try { starfield?.(surface); } catch {} }
        else { requestAnimationFrame(tryStarfield); }
      };
      tryStarfield();
    })();

    // Global hook
    window.endSession = function(score, difficulty='medium'){
      try { recordSession(EXERCISE_ID, difficulty, score); } catch {}
      try { checkAndUnlockAchievements(); } catch {}
    };
  </script>
</body>
</html>
