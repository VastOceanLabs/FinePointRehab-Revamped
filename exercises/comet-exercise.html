// 1) Replace refreshGeometry() with this hardened version
function refreshGeometry(){
  const W = canvas.width / DPR, H = canvas.height / DPR;
  const hudRect = hud ? hud.getBoundingClientRect() : { height: 60 };
  // Reserve HUD height only when playing
  const reservedTop = document.body.classList.contains('playing') ? Math.max(48, Math.ceil(hudRect.height) + 12) : 0;
  playArea.x0 = 0;
  playArea.y0 = reservedTop;
  // Ensure a minimum play height so spawns never compute NaN
  const minPlayH = 120;
  playArea.w = W;
  playArea.h = Math.max(minPlayH, H - playArea.y0);
}

// 2) Replace toImmersive() with this (just ensures layout settle)
function toImmersive(){
  document.body.classList.add('playing');
  window.scrollTo({ top: 0 }); // keep it simple; no custom behavior
  // best-effort fullscreen; ignore failures
  try {
    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen({ navigationUI: 'hide' });
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  } catch {}
}

// 3) Replace startSession() with this deferred-start version
function startSession(){
  const mins = parseFloat(durIn.value);
  durationMs = Number.isFinite(mins) && mins>0 ? mins*60*1000 : 120000;
  timeLeft = durationMs; setTimerBar();

  toImmersive();

  // Defer geometry+loop by one frame so HUD has a real height
  requestAnimationFrame(() => {
    fit();          // recompute canvas backing store
    refreshGeometry();

    running = true; paused = false;
    score = 0; taps = 0; misses = 0; totalRT = 0;
    scoreEl.textContent = '0';
    hueBase = (160 + Math.random()*60);

    pauseBtn.disabled = false;
    restartBtn.disabled = false;
    pauseBtn.textContent = 'Pause';

    lastTick = performance.now();
    lastSpawn = -1e9;          // force immediate spawn window open
    spawnComet();               // guarantee at least one comet is visible
    requestAnimationFrame(loop);
  });
}

// 4) Replace spawnComet() with this (extra guards)
function spawnComet(){
  // If playArea isn't ready, bail and try next frame
  if (playArea.w <= 0 || playArea.h <= 0) return;

  const r = sizeMap[sizeSel.value];
  const spd = speedMap[spdSel.value] * (.85 + Math.random()*.4);
  const {x,y,tx,ty} = spawnOppositeEdge();

  let vx = tx - x, vy = ty - y;
  const len = Math.hypot(vx,vy) || 1; vx/=len; vy/=len;

  const hue = (hueBase + Math.random()*60) % 360;
  comets.push({ x, y, vx, vy, r, spd, hue, born: now(), trail: [] });
}
