<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Trace &amp; Reveal — Fine Point Rehab</title>

  <style>
    :root{
      --vh: 1vh;
      --bg1:#070b16; --bg2:#0f1630; --bg3:#0b1024;
      --accent:#6fd3f5; --panel:rgba(10,16,36,.9); --bd:rgba(255,255,255,.08); --text:#eaf6ff;
      --radius:14px;
    }
    html,body{height:100%}
    body{
      margin:0; color:var(--text); font:15px/1.5 system-ui, Segoe UI, Inter, -apple-system, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1200px 800px at 20% 25%, rgba(70,30,120,.35), transparent 60%),
        radial-gradient(900px 700px at 75% 65%, rgba(20,120,160,.28), transparent 55%),
        linear-gradient(180deg,var(--bg1) 0%, var(--bg2) 50%, var(--bg3) 100%);
      min-height: calc(var(--vh) * 100);
      touch-action: manipulation;
    }
    header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg, rgba(6,10,24,.85), rgba(6,10,24,.55));border-bottom:1px solid var(--bd);backdrop-filter: blur(6px)}
    header .wrap{display:flex;gap:12px;align-items:center;padding:10px 16px}
    .layout{display:grid;grid-template-columns:min(420px,36vw) 1fr;gap:16px;max-width:1280px;margin:0 auto;padding:16px}
    @media (max-width:900px){.layout{grid-template-columns:1fr}}
    .panel{background:var(--panel);border:1px solid var(--bd);border-radius:var(--radius);box-shadow:0 12px 28px rgba(0,0,0,.35),inset 0 0 40px rgba(0,0,0,.25)}
    .desc{font-size:13px;opacity:.95;background:linear-gradient(180deg, rgba(6,10,24,.65), rgba(6,10,24,.35));border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:10px;margin:10px 0 14px}
    .group{margin-bottom:12px}.label{display:block;margin:0 0 6px;font-weight:700}
    select,input[type=number]{width:100%;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.2);background:rgba(5,10,26,.8);color:var(--text);font-size:16px}
    select:focus,input[type=number]:focus{outline:none;border-color:rgba(111,211,245,.9);box-shadow:0 0 0 2px rgba(111,211,245,.25)}
    .btn{min-height:46px;border:1px solid rgba(111,211,245,.35);background:rgba(111,211,245,.12);color:var(--text);border-radius:10px;font-weight:800;letter-spacing:.2px;cursor:pointer;transition:.2s}
    .btn:hover:not(:disabled){background:rgba(111,211,245,.22);transform:translateY(-1px)}
    .btn-primary{background:rgba(111,211,245,.95);color:#07101e;border-color:rgba(111,211,245,1)}
    .btn-primary:hover:not(:disabled){background:rgba(111,211,245,1);box-shadow:0 6px 18px rgba(111,211,245,.45)}
    .hud{display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:8px 10px;margin-bottom:10px;background:rgba(8,14,36,.85);border:1px solid var(--bd);border-radius:var(--radius);box-shadow:0 6px 16px rgba(0,0,0,.35)}
    .metric{display:grid;grid-template-rows:auto auto;min-width:110px}
    .v{font-weight:900;font-size:20px;color:#d7f2ff;text-shadow:0 0 8px rgba(160,220,255,.7)}
    .t{font-size:11px;opacity:.9;margin-top:2px}
    .actions{margin-left:auto;display:flex;gap:8px}
    .frame{position:relative;border-radius:var(--radius);overflow:hidden;border:1px solid var(--bd);box-shadow:inset 0 0 40px rgba(0,0,0,.35);background: radial-gradient(60% 45% at 50% 40%, rgba(80,160,200,.12), transparent 68%)}
    .stage-wrap{position:relative;width:100%;aspect-ratio:1/1}
    canvas.stage{position:absolute;inset:0;width:100%;height:100%;display:block;background:transparent;touch-action:none}
    #guide{pointer-events:none}
    #ink{pointer-events:none}
    body.playing .layout{grid-template-columns:1fr;padding:0;height:calc(var(--vh) * 100)}
    body.playing #settings{display:none}
    .hidden{display:none !important}
    :focus-visible{outline:3px solid rgba(111,211,245,.85);outline-offset:2px}
    #errbar{position:fixed;left:0;right:0;bottom:0;background:#400;color:#fff;font:13px/1.4 system-ui;padding:8px 12px;display:none;z-index:9999}
  </style>
</head>
<body>
<header><div class="wrap"><h1>Trace &amp; Reveal</h1><div style="flex:1"></div></div></header>
<div id="errbar"></div>

<main class="layout">
  <aside id="settings" class="panel" style="padding:16px" aria-label="Settings">
    <h2>Settings</h2>
    <div class="desc">
      <strong>How to play:</strong> Trace the dotted line to reveal the shape. Hit the coverage target before time runs out.
      Press <strong>Space</strong> to pause, <strong>Esc</strong> to exit.
    </div>
    <div class="group">
      <label class="label" for="dur">Session Duration (minutes)</label>
      <input id="dur" type="number" min="0.5" step="0.5" max="30" value="2" inputmode="decimal" />
    </div>
    <div class="group">
      <label class="label" for="difficulty">Difficulty</label>
      <select id="difficulty">
        <option value="easy">Easy (lines &amp; zigzags)</option>
        <option value="medium" selected>Medium (basic shapes)</option>
        <option value="hard">Hard (clean complex shapes)</option>
      </select>
      <div id="covHint" class="t" aria-live="polite" style="margin-top:6px">Coverage target: 85%</div>
    </div>
    <button id="start" class="btn btn-primary" type="button">Start</button>
  </aside>

  <section aria-label="Game">
    <div class="hud">
      <div class="metric" aria-live="polite"><div id="doneCount" class="v">0</div><div class="t">Completed</div></div>
      <div class="metric" aria-live="polite"><div id="covNow"   class="v">0%</div><div class="t">Coverage</div></div>
      <div class="metric" aria-live="polite"><div id="time"     class="v">00:00</div><div class="t">Time</div></div>
      <div class="actions">
        <button id="pauseHud" class="btn" type="button" aria-label="Pause or resume">Pause</button>
        <button id="exitHud"  class="btn" type="button" aria-label="Exit to results">Exit</button>
      </div>
    </div>

    <div class="frame panel" style="padding:8px">
      <div class="stage-wrap">
        <!-- Order: hidden -> mask -> fx -> ink -> guide -->
        <canvas id="hidden" class="stage" aria-hidden="true"></canvas>
        <canvas id="mask"   class="stage" aria-hidden="true"></canvas>
        <canvas id="fx"     class="stage" aria-hidden="true"></canvas>
        <canvas id="ink"    class="stage" aria-hidden="true"></canvas>
        <canvas id="guide"  class="stage" aria-label="Trace guide"></canvas>
      </div>
    </div>
  </section>
</main>

<div id="done" class="hidden" role="dialog" aria-modal="true" style="position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.6);backdrop-filter:blur(4px)">
  <div class="panel" style="padding:20px;max-width:min(520px,92vw)">
    <h2 style="color:var(--accent);margin:0 0 8px">Session Complete</h2>
    <p><strong>Shapes completed:</strong> <span id="finalShapes">0</span></p>
    <p><strong>Best coverage:</strong> <span id="finalCov">0%</span></p>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="again" class="btn btn-primary">Start New Session</button>
      <button id="close" class="btn">Close</button>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  const errbar = document.getElementById("errbar");
  window.addEventListener("error", (e) => {
    errbar.style.display = "block";
    errbar.textContent = "Script error: " + (e.message || "") + (e.filename ? " — " + e.filename + ":" + e.lineno : "");
  });

  const setVH = () => document.documentElement.style.setProperty("--vh", (window.innerHeight * 0.01) + "px");
  setVH(); addEventListener("resize", setVH); addEventListener("orientationchange", setVH);

  const startBtn = document.getElementById("start");
  const durInput = document.getElementById("dur");
  const diffSelect = document.getElementById("difficulty");
  const covHint = document.getElementById("covHint");
  const timeV = document.getElementById("time");
  const doneV = document.getElementById("doneCount");
  const covNowV = document.getElementById("covNow");
  const pauseBtn = document.getElementById("pauseHud");
  const exitBtn  = document.getElementById("exitHud");
  const donePane = document.getElementById("done");
  const againBtn = document.getElementById("again");
  const closeBtn = document.getElementById("close");

  const hidden = document.getElementById("hidden");
  const mask   = document.getElementById("mask");
  const fx     = document.getElementById("fx");
  const ink    = document.getElementById("ink");
  const guide  = document.getElementById("guide");
  const gh = hidden.getContext("2d");
  const gm = mask.getContext("2d");
  const gx = fx.getContext("2d");
  const gi = ink.getContext("2d");
  const gg = guide.getContext("2d");
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  let playing = false;
  let paused = false;
  let remainingMs = 0;
  let timeLoop = 0;

  let shapesDone = 0;
  let bestCov = 0;

  let subs = [];  // current multi-subpath shape: [{points, closed, strokePx}]

  let samples = [];
  let hits = 0;
  let grid = null;
  let cellSize = 16;

  const brush = 28;
  let requiredCov = 85;

  const bags = { easy: [], medium: [], hard: [] };

  const fmt = (ms) => {
    const s = Math.max(0, Math.ceil(ms / 1000));
    const mm = String(Math.floor(s / 60)).padStart(2, "0");
    const ss = String(s % 60).padStart(2, "0");
    return mm + ":" + ss;
  };

  const applyDifficulty = () => {
    requiredCov = diffSelect.value === "easy" ? 70 : (diffSelect.value === "hard" ? 95 : 85);
    covHint.textContent = "Coverage target: " + requiredCov + "%";
  };
  diffSelect.addEventListener("change", applyDifficulty);
  applyDifficulty();

  const resizeStage = () => {
    const wrap = fx.parentElement.getBoundingClientRect();
    const size = Math.max(10, Math.floor(wrap.width));
    [hidden, mask, fx, ink, guide].forEach((c) => {
      c.width = Math.floor(size * DPR);
      c.height = Math.floor(size * DPR);
      c.style.width = size + "px";
      c.style.height = size + "px";
    });
    gi.lineCap = "round"; gi.lineJoin = "round";
    gi.strokeStyle = "rgba(111,211,245,0.95)";
    gi.lineWidth = Math.max(3, Math.round(brush * DPR * 0.5));

    cellSize = Math.max(8, Math.round(brush * DPR * 0.8));

    if (playing) { newShape(); } else { drawIdleGuide(); }
  };
  new ResizeObserver(resizeStage).observe(fx.parentElement);

  const drawIdleGuide = () => {
    gg.clearRect(0, 0, guide.width, guide.height);
    gg.save();
    gg.scale(DPR, DPR);
    gg.fillStyle = "rgba(255,255,255,.06)";
    gg.fillRect(0, 0, guide.width / DPR, guide.height / DPR);
    gg.fillStyle = "rgba(255,255,255,.9)";
    gg.font = "600 16px system-ui, sans-serif";
    gg.textAlign = "center";
    gg.fillText("Set duration, pick difficulty, then Start", guide.width / (2 * DPR), guide.height / (2 * DPR));
    gg.restore();
  };

  const make = (pts, closed = true, strokePx = 0) => ({ points: pts, closed, strokePx });
  const minSide = () => Math.min(hidden.width, hidden.height);

  // Open/simple
  const lineH = () => {
    const y = hidden.height * 0.5, x1 = hidden.width * 0.15, x2 = hidden.width * 0.85;
    return [make([{ x: x1, y }, { x: x2, y }], false, Math.round(hidden.height * 0.08))];
  };
  const lineV = () => {
    const x = hidden.width * 0.5, y1 = hidden.height * 0.18, y2 = hidden.height * 0.82;
    return [make([{ x, y: y1 }, { x, y: y2 }], false, Math.round(hidden.width * 0.08))];
  };
  const lineD = () => {
    const m = hidden.width * 0.15;
    return [make([{ x: m, y: m }, { x: hidden.width - m, y: hidden.height - m }], false, Math.round(hidden.width * 0.07))];
  };
  const zigzag = () => {
    const pts = [];
    const l = hidden.width * 0.18, r = hidden.width * 0.82, t = hidden.height * 0.22, b = hidden.height * 0.78, rows = 6;
    for (let i = 0; i <= rows; i++) {
      const y = t + (b - t) * (i / rows);
      const x = (i % 2 === 0) ? l : r;
      pts.push({ x, y });
    }
    return [make(pts, false, Math.round(hidden.width * 0.07))];
  };
  const sine = () => {
    const pts = [];
    const l = hidden.width * 0.12, r = hidden.width * 0.88, mid = hidden.height * 0.5, amp = hidden.height * 0.22, cyc = 1.5, steps = 180;
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const x = l + (r - l) * t;
      const y = mid + Math.sin(t * Math.PI * 2 * cyc) * amp;
      pts.push({ x, y });
    }
    return [make(pts, false, Math.round(hidden.width * 0.06))];
  };
  const lshape = () => {
    const x = hidden.width * 0.25, y = hidden.height * 0.25, w = hidden.width * 0.5, h = hidden.height * 0.5;
    return [make([{ x, y }, { x, y: y + h }, { x: x + w, y: y + h }], false, Math.round(hidden.width * 0.07))];
  };

  // Closed/simple
  const circle = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2, r = minSide() * 0.32, pts = [];
    for (let i = 0; i <= 180; i++) { const a = (i / 180) * Math.PI * 2; pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r }); }
    return [make(pts, true, 0)];
  };
  const square = () => {
    const s = minSide() * 0.64, x = (hidden.width - s) / 2, y = (hidden.height - s) / 2;
    const pts = [{ x, y }, { x: x + s, y }, { x: x + s, y: y + s }, { x, y: y + s }, { x, y }];
    return [make(pts, true, 0)];
  };
  const rect = () => {
    const w = minSide() * 0.72, h = w * 0.6, x = (hidden.width - w) / 2, y = (hidden.height - h) / 2;
    const pts = [{ x, y }, { x: x + w, y }, { x: x + w, y: y + h }, { x, y: y + h }, { x, y }];
    return [make(pts, true, 0)];
  };
  const tri = () => {
    const s = minSide() * 0.68, cx = hidden.width / 2, cy = hidden.height / 2;
    const pts = [{ x: cx, y: cy - s / 2 }, { x: cx - s / 2, y: cy + s / 2 }, { x: cx + s / 2, y: cy + s / 2 }, { x: cx, y: cy - s / 2 }];
    return [make(pts, true, 0)];
  };
  const diamond = () => {
    const s = minSide() * 0.68, cx = hidden.width / 2, cy = hidden.height / 2;
    const pts = [{ x: cx, y: cy - s / 2 }, { x: cx + s / 2, y: cy }, { x: cx, y: cy + s / 2 }, { x: cx - s / 2, y: cy }, { x: cx, y: cy - s / 2 }];
    return [make(pts, true, 0)];
  };
  const hex = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2, r = minSide() * 0.32, pts = [];
    for (let i = 0; i < 6; i++) { const a = (i / 6) * Math.PI * 2; pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r }); }
    pts.push(pts[0]);
    return [make(pts, true, 0)];
  };
  const star = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2, R = minSide() * 0.34, r = R * 0.5, pts = [];
    for (let i = 0; i < 10; i++) { const a = (i / 10) * Math.PI * 2 - Math.PI / 2; const rad = (i % 2 === 0) ? R : r; pts.push({ x: cx + Math.cos(a) * rad, y: cy + Math.sin(a) * rad }); }
    pts.push(pts[0]);
    return [make(pts, true, 0)];
  };

  // Complex
  const house = () => {
    const w = hidden.width * 0.6, h = hidden.height * 0.5, x = (hidden.width - w) / 2, y = (hidden.height - h) / 2 + hidden.height * 0.08, roofH = h * 0.45;
    const pts = [{ x:x, y:y+h }, { x:x, y:y+roofH }, { x:x+w/2, y:y }, { x:x+w, y:y+roofH }, { x:x+w, y:y+h }, { x:x, y:y+h }];
    return [make(pts, true, 0)];
  };
  const tree = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2, rw = minSide() * 0.42, rh = rw * 0.7;
    const trunkW = hidden.width * 0.08, trunkH = hidden.height * 0.16, base = cy + rh * 0.6;
    const trunk = [{ x: cx - trunkW/2, y: base }, { x: cx - trunkW/2, y: base - trunkH }, { x: cx + trunkW/2, y: base - trunkH }, { x: cx + trunkW/2, y: base }, { x: cx - trunkW/2, y: base }];
    const steps = 140, canopy = [];
    for (let i = 0; i <= steps; i++) { const a = (i/steps) * Math.PI * 2; canopy.push({ x: cx + Math.cos(a) * rw/2, y: cy + Math.sin(a) * rh/2 }); }
    return [make(canopy, true, 0), make(trunk, true, 0)];
  };
  const boat = () => {
    const cx = hidden.width / 2, cy = hidden.height * 0.62, w = hidden.width * 0.66, h = hidden.height * 0.16;
    const hull = [{ x: cx-w/2, y: cy }, { x: cx-w*0.35, y: cy+h }, { x: cx+w*0.35, y: cy+h }, { x: cx+w/2, y: cy }, { x: cx-w/2, y: cy }];
    const sail = [{ x: cx, y: cy }, { x: cx, y: cy-h*2 }, { x: cx+w*0.28, y: cy-h }, { x: cx, y: cy }];
    return [make(hull, true, 0), make(sail, true, 0)];
  };
  const bolt = () => {
    const x = hidden.width * 0.35, y = hidden.height * 0.18, w = hidden.width * 0.3, h = hidden.height * 0.6;
    const pts = [{ x:x, y:y }, { x:x+w*0.30, y:y+h*0.24 }, { x:x-w*0.10, y:y+h*0.24 }, { x:x+w*0.64, y:y+h*0.9 }, { x:x+w*0.38, y:y+h*0.45 }, { x:x+w*0.78, y:y+h*0.45 }, { x:x, y:y }];
    return [make(pts, true, 0)];
  };
  const arrow = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2, w = hidden.width * 0.6, h = hidden.height * 0.22, head = w * 0.28;
    const x1 = cx - w/2, x2 = cx + w/2 - head;
    const pts = [
      {x:x1, y: cy - h/2}, {x:x2, y: cy - h/2},
      {x:x2, y: cy - h},   {x:cx + w/2, y: cy},
      {x:x2, y: cy + h},   {x:x2, y: cy + h/2},
      {x:x1, y: cy + h/2}, {x:x1, y: cy - h/2}
    ];
    return [make(pts, true, 0)];
  };
  const heart = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2;
    const k = Math.min(hidden.width, hidden.height) * 0.02;
    const steps = 220, pts = [];
    for (let i = 0; i <= steps; i++) {
      const t = (i / steps) * Math.PI * 2;
      const x = cx + k * 16 * Math.pow(Math.sin(t), 3);
      const y = cy - k * (13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t));
      pts.push({x,y});
    }
    return [make(pts, true, 0)];
  };
  const moon = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2;
    const R = Math.min(hidden.width, hidden.height) * 0.34, r = R * 0.7, dx = R * 0.35;
    const a1 = -Math.PI * 0.6, a2 = Math.PI * 1.2;
    const outer = [], inner = [];
    const steps = 180;
    for (let i = 0; i <= steps; i++) {
      const t = a1 + (a2 - a1) * (i / steps);
      outer.push({ x: cx + Math.cos(t) * R, y: cy + Math.sin(t) * R });
    }
    for (let i = steps; i >= 0; i--) {
      const t = a1 + (a2 - a1) * (i / steps);
      inner.push({ x: cx + dx + Math.cos(t) * r, y: cy + Math.sin(t) * r });
    }
    return [make(outer.concat(inner), true, 0)];
  };
  const cloud = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2;
    const a = hidden.width * 0.34, b = hidden.height * 0.24, p = 2.5, pts = [];
    const steps = 240;
    const sgn = (v) => (v < 0 ? -1 : 1);
    for (let i = 0; i <= steps; i++) {
      const t = (i / steps) * Math.PI * 2;
      const ct = Math.cos(t), st = Math.sin(t);
      const x = cx + a * sgn(ct) * Math.pow(Math.abs(ct), 2 / p);
      const y = cy + b * sgn(st) * Math.pow(Math.abs(st), 2 / p);
      pts.push({x,y});
    }
    return [make(pts, true, 0)];
  };

  const POOLS = {
    easy:   [lineH, lineV, lineD, zigzag, sine, lshape],
    medium: [circle, square, rect, tri, diamond, hex, star, heart, arrow, cloud],
    hard:   [house, tree, boat, bolt, star, hex, heart, moon, arrow, cloud]
  };

  const drawGuide = () => {
    gg.clearRect(0, 0, guide.width, guide.height);
    gg.save();
    gg.lineCap = "round"; gg.lineJoin = "round";
    for (const sp of subs) {
      const pts = sp.points;
      if (!pts || pts.length < 2) continue;
      gg.strokeStyle = "rgba(0,0,0,.92)"; gg.lineWidth = 8 * DPR; gg.setLineDash([]);
      gg.beginPath(); gg.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) gg.lineTo(pts[i].x, pts[i].y);
      if (sp.closed) gg.closePath();
      gg.stroke();

      gg.strokeStyle = "rgba(255,255,255,.98)"; gg.lineWidth = 4 * DPR; gg.setLineDash([14 * DPR, 10 * DPR]);
      gg.beginPath(); gg.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) gg.lineTo(pts[i].x, pts[i].y);
      if (sp.closed) gg.closePath();
      gg.stroke();
    }
    gg.restore();
  };

  const drawHidden = () => {
    gh.clearRect(0, 0, hidden.width, hidden.height);
    const hue = Math.floor(Math.random() * 360);
    const g0 = "hsl(" + hue + ",85%,62%)";
    const g1 = "hsl(" + ((hue + 40) % 360) + ",85%,46%)";
    const grd = gh.createRadialGradient(hidden.width / 2, hidden.height / 2, 0, hidden.width / 2, hidden.height / 2, hidden.width / 2);
    grd.addColorStop(0, g0);
    grd.addColorStop(1, g1);

    for (const sp of subs) {
      const pts = sp.points;
      if (!pts || pts.length < 2) continue;
      gh.beginPath();
      gh.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) gh.lineTo(pts[i].x, pts[i].y);
      if (sp.closed) gh.closePath();
      if (sp.closed) { gh.fillStyle = grd; gh.fill(); }
      else { gh.lineCap = "round"; gh.lineJoin = "round"; gh.lineWidth = Math.max(4, sp.strokePx || 0); gh.strokeStyle = grd; gh.stroke(); }
    }

    gm.clearRect(0, 0, mask.width, mask.height);
    gi.clearRect(0, 0, ink.width, ink.height);
  };

  const buildCoverage = () => {
    samples = [];
    hits = 0;
    grid = new Map();
    const addSample = (x, y) => {
      const idx = samples.length;
      samples.push({ x, y, hit: false });
      const ci = Math.floor(x / cellSize), cj = Math.floor(y / cellSize);
      const key = ci + "|" + cj;
      const arr = grid.get(key);
      if (arr) arr.push(idx); else grid.set(key, [idx]);
    };
    const step = 6 * DPR;
    for (const sp of subs) {
      const pts = sp.points;
      for (let i = 0; i < pts.length - 1; i++) {
        const p1 = pts[i], p2 = pts[i + 1];
        const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const steps = Math.max(1, Math.ceil(dist / step));
        for (let j = 0; j <= steps; j++) {
          const t = j / steps;
          addSample(Math.round(p1.x + (p2.x - p1.x) * t), Math.round(p1.y + (p2.y - p1.y) * t));
        }
      }
      if (sp.closed && pts.length > 2) {
        const p1 = pts[pts.length - 1], p2 = pts[0];
        const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        const steps = Math.max(1, Math.ceil(dist / step));
        for (let j = 0; j <= steps; j++) {
          const t = j / steps;
          addSample(Math.round(p1.x + (p2.x - p1.x) * t), Math.round(p1.y + (p2.y - p1.y) * t));
        }
      }
    }
  };

  const updateComposite = () => {
    const tmp = document.createElement("canvas"); tmp.width = hidden.width; tmp.height = hidden.height;
    const gt = tmp.getContext("2d");
    gt.drawImage(hidden, 0, 0);
    gt.globalCompositeOperation = "destination-in";
    gt.drawImage(mask, 0, 0);

    gx.clearRect(0, 0, fx.width, fx.height);
    gx.drawImage(tmp, 0, 0);

    gx.save();
    gx.globalCompositeOperation = "lighter";
    gx.drawImage(tmp, 0, 0);
    gx.restore();
  };

  const pos = (e) => {
    const r = fx.getBoundingClientRect();
    const x = ((e.clientX || e.pageX) - r.left) * DPR;
    const y = ((e.clientY || e.pageY) - r.top) * DPR;
    return { x, y };
  };

  let isDrawing = false;
  let isCompleting = false;
  let lastP = null;

  const markCoverageNear = (p) => {
    if (!samples.length) return;
    const r = (brush * DPR / 2);
    const r2 = r * r;
    const ci = Math.floor(p.x / cellSize), cj = Math.floor(p.y / cellSize);
    for (let di = -1; di <= 1; di++) {
      for (let dj = -1; dj <= 1; dj++) {
        const key = (ci + di) + "|" + (cj + dj);
        const arr = grid.get(key);
        if (!arr) continue;
        for (const idx of arr) {
          const s = samples[idx];
          if (!s.hit) {
            const dx = s.x - p.x, dy = s.y - p.y;
            if (dx*dx + dy*dy <= r2) { s.hit = true; hits++; }
          }
        }
      }
    }
    const cov = Math.min(100, Math.round((hits / Math.max(1, samples.length)) * 100));
    bestCov = Math.max(bestCov, cov);
    covNowV.textContent = cov + "%";
    if (cov >= requiredCov && !isCompleting) complete();
  };

  const drawAt = (p) => {
    gm.globalCompositeOperation = "source-over";
    gm.fillStyle = "white";
    gm.beginPath();
    gm.arc(p.x, p.y, brush * DPR / 2, 0, Math.PI * 2);
    gm.fill();

    if (lastP) {
      gi.beginPath();
      gi.moveTo(lastP.x, lastP.y);
      gi.lineTo(p.x, p.y);
      gi.stroke();
    } else {
      gi.beginPath();
      gi.arc(p.x, p.y, Math.max(1, (brush * DPR * 0.25)), 0, Math.PI * 2);
      gi.fillStyle = "rgba(111,211,245,0.95)";
      gi.fill();
    }
    lastP = p;

    updateComposite();
    markCoverageNear(p);
  };

  const down = (e) => { if (!playing || isCompleting) return; isDrawing = true; drawAt(pos(e)); };
  const move = (e) => { if (!isDrawing || !playing || isCompleting) return; drawAt(pos(e)); };
  const up   = () => { isDrawing = false; lastP = null; };

  fx.addEventListener("mousedown", down);
  fx.addEventListener("mousemove", move);
  addEventListener("mouseup", up);

  fx.addEventListener("touchstart", (e) => { e.preventDefault(); down(e.touches[0]); }, { passive: false });
  fx.addEventListener("touchmove",  (e) => { e.preventDefault(); move(e.touches[0]); }, { passive: false });
  fx.addEventListener("touchend",   (e) => { e.preventDefault(); up(); }, { passive: false });

  const bagPick = (level) => {
    if (!bags[level] || bags[level].length === 0) bags[level] = [...POOLS[level]];
    const i = Math.floor(Math.random() * bags[level].length);
    const fn = bags[level].splice(i, 1)[0];
    return fn;
  };

  const newShape = () => {
    const level = diffSelect.value;
    const gen = bagPick(level);
    subs = gen();
    drawGuide(); drawHidden(); buildCoverage(); updateComposite();
  };

  const start = () => {
    const mins = Math.max(0.5, Math.min(30, Number(durInput.value || 2)));
    remainingMs = Math.round(mins * 60 * 1000);
    shapesDone = 0; bestCov = 0;
    doneV.textContent = "0";
    covNowV.textContent = "0%";
    timeV.textContent = fmt(remainingMs);

    document.body.classList.add("playing");
    playing = true; paused = false;

    requestAnimationFrame(() => { resizeStage(); newShape(); loop(performance.now()); });
  };

  const loop = (last) => {
    if (!playing) return;
    timeLoop = requestAnimationFrame((now) => {
      if (!paused) {
        const dt = now - last;
        remainingMs = Math.max(0, remainingMs - dt);
        timeV.textContent = fmt(remainingMs);
        if (remainingMs <= 0) { end(); return; }
      }
      loop(now);
    });
  };

  const pause = () => { if (!playing) return; paused = !paused; };
  const exit  = () => { if (!playing) return; playing = false; paused = false; document.body.classList.remove("playing"); cancelAnimationFrame(timeLoop); };

  const end = () => {
    playing = false; paused = false; document.body.classList.remove("playing"); cancelAnimationFrame(timeLoop);
    document.getElementById("finalShapes").textContent = String(shapesDone);
    document.getElementById("finalCov").textContent = Math.round(bestCov) + "%";
    donePane.classList.remove("hidden");
  };

  const complete = () => {
    isCompleting = true;
    shapesDone += 1;
    doneV.textContent = String(shapesDone);
    gx.save(); gx.fillStyle = "rgba(255,255,255,.16)"; gx.fillRect(0, 0, fx.width, fx.height); gx.restore();
    setTimeout(() => { gx.clearRect(0, 0, fx.width, fx.height); if (playing) { isCompleting = false; newShape(); } }, 160);
  };

  startBtn.addEventListener("click", start);
  pauseBtn.addEventListener("click", pause);
  exitBtn.addEventListener("click", exit);
  againBtn.addEventListener("click", () => { donePane.classList.add("hidden"); start(); });
  closeBtn.addEventListener("click", () => { donePane.classList.add("hidden"); });

  addEventListener("keydown", (e) => {
    if (!playing) return;
    if (e.key === " ") { e.preventDefault(); pause(); }
    if (e.key === "Escape") { e.preventDefault(); exit(); }
  });

  drawIdleGuide();
})();
</script>
</body>
</html>
