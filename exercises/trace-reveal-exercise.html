<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Trace & Reveal â€” Fine Point Rehab</title>

<!-- Comet-style inline theme (tokens/components extracted for consistency) -->
<style>
  :root{
    --vh: 1vh;
    --bg-1:#070b16; --bg-2:#0f1630; --bg-3:#0b1024;
    --accent: #6fd3f5;
    --radius: 14px;
    --panel: rgba(10,16,36,.9);
    --panel-border: rgba(255,255,255,.08);
    --text: #eaf6ff;
  }
  body{ margin:0; color:var(--text);
    background:
      radial-gradient(1200px 800px at 20% 25%, rgba(70,30,120,.35), transparent 60%),
      radial-gradient(900px 700px at 75% 65%, rgba(20,120,160,.28), transparent 55%),
      linear-gradient(180deg, var(--bg-1) 0%, var(--bg-2) 50%, var(--bg-3) 100%);
    min-height: calc(var(--vh) * 100);
    touch-action: manipulation;
    font-family: Segoe UI, Inter, system-ui, -apple-system, Roboto, Arial, sans-serif;
  }
  .layout{ display:grid; grid-template-columns: min(420px, 36vw) 1fr; gap:16px; padding:16px; max-width:1280px; margin:0 auto; }
  @media (max-width: 900px){ .layout{ grid-template-columns:1fr; } }
  .panel{ background: var(--panel); border:1px solid var(--panel-border); border-radius: var(--radius); box-shadow: 0 12px 28px rgba(0,0,0,.35), inset 0 0 40px rgba(0,0,0,.25); }
  h1,h2{ margin:0; }
  header.site{ position:sticky; top:0; z-index:10; background: linear-gradient(180deg, rgba(6,10,24,.85), rgba(6,10,24,.55)); border-bottom:1px solid var(--panel-border); backdrop-filter: blur(6px); }
  header .wrap{ display:flex; align-items:center; gap:12px; padding:10px 16px; }
  header .spacer{ flex:1; }
  .desc{ font-size:13px; opacity:.92; background: linear-gradient(180deg, rgba(6,10,24,.65), rgba(6,10,24,.35)); border: 1px solid rgba(255,255,255,.12); border-radius:10px; padding:10px; }
  .group{ margin-bottom:12px; }
  .label{ display:block; margin-bottom:6px; font-weight:700; letter-spacing:.2px; }
  select, input[type="number"]{
    width:100%; padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,.2);
    background: rgba(5,10,26,.8); color:var(--text); font-size:16px;
  }
  select:focus, input[type="number"]:focus{
    outline:none; border-color: rgba(111,211,245,.9); box-shadow: 0 0 0 2px rgba(111,211,245,.25);
  }
  .btn{
    min-height:46px; border:1px solid rgba(111,211,245,.35); background: rgba(111,211,245,.12);
    color:var(--text); border-radius:10px; font-weight:800; letter-spacing:.2px; cursor:pointer; transition:.2s;
  }
  .btn:hover:not(:disabled){ background: rgba(111,211,245,.22); transform: translateY(-1px); }
  .btn:disabled{ opacity:.55; cursor:not-allowed; }
  .btn-primary{ background: rgba(111,211,245,.95); color:#07101e; border-color: rgba(111,211,245,1); }
  .btn-primary:hover:not(:disabled){ background: rgba(111,211,245,1); box-shadow: 0 6px 18px rgba(111,211,245,.45); }
  .hud{ display:flex; flex-wrap:wrap; align-items:center; gap:8px; padding:8px 10px; margin-bottom:10px;
        background: rgba(8,14,36,.85); border: 1px solid var(--panel-border); border-radius: var(--radius);
        box-shadow: 0 6px 16px rgba(0,0,0,.35); position:relative; z-index:4; }
  .metric{ display:grid; grid-template-rows:auto auto; align-items:center; justify-items:start; min-width:110px; }
  .v{ font-weight:900; font-size:20px; color:#d7f2ff; text-shadow: 0 0 8px rgba(160,220,255,.7); line-height:1.1; }
  .t{ font-size:11px; opacity:.9; margin-top:2px; }
  .actions{ flex:0 0 auto; display:flex; gap:8px; margin-left:auto; }
  .frame{ position:relative; border-radius: var(--radius); overflow:hidden;
          border:1px solid var(--panel-border); box-shadow: inset 0 0 40px rgba(0,0,0,.35);
          background: radial-gradient(60% 45% at 50% 40%, rgba(80,160,200,.12), transparent 68%); }
  canvas.stage{ display:block; width:100%; aspect-ratio: 1 / 1; background: transparent; touch-action:none; }
  body.playing .layout{ grid-template-columns: 1fr; padding:0; height: calc(var(--vh) * 100); }
  body.playing #settings{ display:none; }
  .hidden{ display:none !important; }
  :focus-visible{ outline: 3px solid rgba(111,211,245,.85); outline-offset:2px; }

  /* High-contrast guide adjustments */
  #guide{ pointer-events:none; }
  #guide.halo{ filter: drop-shadow(0 0 6px rgba(0,0,0,.9)) drop-shadow(0 0 12px rgba(0,0,0,.7)); }
</style>
</head>
<body>
<header class="site">
  <div class="wrap">
    <h1>Trace & Reveal</h1>
    <div class="spacer"></div>
  </div>
</header>

<main class="layout">
  <!-- SETTINGS -->
  <aside id="settings" class="panel" aria-label="Settings" style="padding:16px;">
    <h2>Settings</h2>
    <div class="desc" style="margin:10px 0 14px;">
      <strong>How to play:</strong> Trace along the <em>dotted line</em> to reveal the shape. Hit the coverage target before time runs out.
      Press <strong>Space</strong> to pause, <strong>Esc</strong> to exit.
    </div>

    <div class="group">
      <label class="label" for="dur">Session Duration (minutes)</label>
      <input id="dur" type="number" min="0.5" step="0.5" max="30" value="2" inputmode="decimal" />
    </div>

    <div class="group">
      <label class="label" for="difficulty">Difficulty</label>
      <select id="difficulty">
        <option value="easy">Easy (more guidance)</option>
        <option value="medium" selected>Medium (balanced)</option>
        <option value="hard">Hard (precise)</option>
      </select>
      <div id="covHint" class="t" aria-live="polite" style="margin-top:6px;">Coverage target: 85%</div>
    </div>

    <div class="settings-actions">
      <button id="start" class="btn btn-primary" type="button">Start</button>
    </div>
  </aside>

  <!-- GAME COLUMN -->
  <section id="game" class="right">
    <div class="hud">
      <div class="metric" aria-live="polite"><div id="score" class="v">0</div><div class="t">Score</div></div>
      <div class="metric" aria-live="polite"><div id="doneCount" class="v">0</div><div class="t">Completed</div></div>
      <div class="metric" aria-live="polite"><div id="covNow" class="v">0%</div><div class="t">Coverage</div></div>
      <div class="metric" aria-live="polite"><div id="time" class="v">00:00</div><div class="t">Time</div></div>
      <div class="actions">
        <button id="pauseHud" class="btn" type="button" aria-label="Pause or resume">Pause</button>
        <button id="exitHud" class="btn" type="button" aria-label="Exit to results">Exit</button>
      </div>
    </div>

    <div class="frame panel" style="padding:8px;">
      <div style="position:relative; width:100%;">
        <canvas id="hidden" class="stage" aria-hidden="true"></canvas>
        <canvas id="mask" class="stage" aria-hidden="true"></canvas>
        <canvas id="guide" class="stage halo" aria-label="Trace guide"></canvas>
        <canvas id="fx" class="stage" aria-hidden="true"></canvas>
      </div>
    </div>
  </section>
</main>

<!-- RESULTS (simple modal-like pane) -->
<div id="done" class="hidden" role="dialog" aria-modal="true" style="position:fixed; inset:0; display:grid; place-items:center; background: rgba(0,0,0,.6); backdrop-filter: blur(4px);">
  <div class="panel" style="padding:20px; max-width:min(520px,92vw);">
    <h2 style="color:var(--accent); margin-top:0;">Session Complete</h2>
    <p><strong>Shapes completed:</strong> <span id="finalShapes">0</span></p>
    <p><strong>Best coverage:</strong> <span id="finalCov">0%</span></p>
    <div style="display:flex; gap:8px; justify-content:flex-end;">
      <button id="again" class="btn btn-primary">Start New Session</button>
      <button id="close" class="btn">Close</button>
    </div>
  </div>
</div>

<script>
/* Viewport fix */
const setVH = () => { document.documentElement.style.setProperty('--vh', (window.innerHeight*0.01) + 'px'); };
setVH(); addEventListener('resize', setVH); addEventListener('orientationchange', setVH);

/* Elements */
const startBtn = document.getElementById('start');
const durInput = document.getElementById('dur');
const diffSelect = document.getElementById('difficulty');
const covHint = document.getElementById('covHint');
const rightCol = document.querySelector('#game');
const timeV = document.getElementById('time');
const scoreV = document.getElementById('score');
const doneV = document.getElementById('doneCount');
const covNowV = document.getElementById('covNow');
const pauseBtn = document.getElementById('pauseHud');
const exitBtn = document.getElementById('exitHud');
const donePane = document.getElementById('done');
const againBtn = document.getElementById('again');
const closeBtn = document.getElementById('close');

/* Canvases */
const hidden = document.getElementById('hidden');
const mask = document.getElementById('mask');
const guide = document.getElementById('guide');
const fx = document.getElementById('fx');
const gh = hidden.getContext('2d');
const gm = mask.getContext('2d');
const gg = guide.getContext('2d');
const gx = fx.getContext('2d');
const DPR = Math.max(1, devicePixelRatio || 1);

/* State */
let playing=false, paused=false, startTs=0, totalMs=0, remainingMs=0, raf=0;
let score=0, shapesDone=0, bestCov=0;
let brush=28; // standardized
let requiredCov=85;
let path=[], coverPts=new Set(), covered=new Set();
let isDrawing=false, isCompleting=false;

function fmt(ms){ ms=Math.max(0,ms|0); const s=Math.ceil(ms/1000); return String(Math.floor(s/60)).padStart(2,'0')+':'+String(s%60).padStart(2,'0'); }

/* Difficulty -> coverage target */
function applyDifficulty(){
  const d = diffSelect.value;
  if(d==='easy') requiredCov = 70;
  else if(d==='hard') requiredCov = 95;
  else requiredCov = 85;
  covHint.textContent = 'Coverage target: ' + requiredCov + '%';
}
diffSelect.addEventListener('change', applyDifficulty);
applyDifficulty();

/* Resize canvases square and regenerate if needed */
function resizeStage(){
  const wrap = hidden.parentElement.getBoundingClientRect();
  const size = Math.floor(wrap.width);
  [hidden,mask,guide,fx].forEach(c=>{ c.width = Math.floor(size*DPR); c.height = Math.floor(size*DPR); c.style.width=size+'px'; c.style.height=size+'px'; });
  if(playing && !isCompleting){ newShape(); } else { drawIdleGuide(); }
}
new ResizeObserver(resizeStage).observe(hidden.parentElement);

/* Idle guide prompt for contrast debugging */
function drawIdleGuide(){
  gg.clearRect(0,0,guide.width,guide.height);
  gg.save();
  gg.scale(DPR,DPR);
  gg.fillStyle='rgba(255,255,255,.06)';
  gg.fillRect(0,0,guide.width/DPR,guide.height/DPR);
  gg.fillStyle='rgba(255,255,255,.9)';
  gg.font='600 16px system-ui, sans-serif';
  gg.textAlign='center';
  gg.fillText('Set duration, pick difficulty, then Start', guide.width/(2*DPR), guide.height/(2*DPR));
  gg.restore();
}

/* Shapes (points around path) */
function circle(){ const cx=hidden.width/2, cy=hidden.height/2, r=Math.min(hidden.width,hidden.height)*0.32; const pts=[]; for(let i=0;i<=160;i++){ const a=i/160*Math.PI*2; pts.push({x:cx+Math.cos(a)*r, y:cy+Math.sin(a)*r}); } return pts; }
function square(){ const s=Math.min(hidden.width,hidden.height)*0.64, x=(hidden.width-s)/2, y=(hidden.height-s)/2; return [{x,y},{x:x+s,y},{x:x+s,y:y+s},{x,y:y+s},{x,y}]; }
function tri(){ const s=Math.min(hidden.width,hidden.height)*0.64, cx=hidden.width/2, cy=hidden.height/2; return [{x:cx,y:cy-s/2},{x:cx-s/2,y:cy+s/2},{x:cx+s/2,y:cy+s/2},{x:cx,y:cy-s/2}]; }
function diamond(){ const s=Math.min(hidden.width,hidden.height)*0.64, cx=hidden.width/2, cy=hidden.height/2; return [{x:cx,y:cy-s/2},{x:cx+s/2,y:cy},{x:cx,y:cy+s/2},{x:cx-s/2,y:cy},{x:cx,y:cy-s/2}]; }
function hex(){ const cx=hidden.width/2, cy=hidden.height/2, r=Math.min(hidden.width,hidden.height)*0.32, pts=[]; for(let i=0;i<6;i++){ const a=i/6*Math.PI*2; pts.push({x:cx+Math.cos(a)*r,y:cy+Math.sin(a)*r}); } pts.push(pts[0]); return pts; }
const SHAPES = [circle, square, tri, diamond, hex];

/* Guide drawing with high contrast (halo + white dashed) */
function drawGuide(){
  gg.clearRect(0,0,guide.width,guide.height);
  gg.save();
  gg.lineCap='round'; gg.lineJoin='round';
  // Halo stroke first
  gg.strokeStyle='rgba(0,0,0,.85)'; gg.lineWidth=8*DPR; gg.setLineDash([]);
  gg.beginPath(); gg.moveTo(path[0].x, path[0].y); for(let i=1;i<path.length;i++) gg.lineTo(path[i].x, path[i].y); gg.stroke();
  // White dashed on top
  gg.strokeStyle='rgba(255,255,255,.98)'; gg.lineWidth=4*DPR; gg.setLineDash([14*DPR, 10*DPR]);
  gg.beginPath(); gg.moveTo(path[0].x, path[0].y); for(let i=1;i<path.length;i++) gg.lineTo(path[i].x, path[i].y); gg.stroke();
  gg.restore();
}

/* Hidden image fill (vivid gradient) and clear mask */
function drawHidden(){
  gh.clearRect(0,0,hidden.width,hidden.height);
  const grd = gh.createRadialGradient(hidden.width/2, hidden.height/2, 0, hidden.width/2, hidden.height/2, hidden.width/2);
  const hue = Math.floor(Math.random()*360);
  grd.addColorStop(0, `hsl(${hue},80%,60%)`);
  grd.addColorStop(1, `hsl(${(hue+40)%360},80%,45%)`);
  gh.beginPath(); gh.moveTo(path[0].x, path[0].y); for(let i=1;i<path.length;i++) gh.lineTo(path[i].x, path[i].y); gh.closePath(); gh.fillStyle=grd; gh.fill();

  // Mask starts transparent; we'll paint white where user draws to REVEAL
  gm.clearRect(0,0,mask.width,mask.height);
}

/* Coverage sampling points along the path */
function buildCoverage(){
  coverPts.clear(); covered.clear();
  for(let i=0;i<path.length-1;i++){
    const p1=path[i], p2=path[i+1]; const dist=Math.hypot(p2.x-p1.x, p2.y-p1.y); const steps=Math.ceil(dist/(6*DPR));
    for(let j=0;j<=steps;j++){ const t=j/steps; const x=Math.round(p1.x+(p2.x-p1.x)*t), y=Math.round(p1.y+(p2.y-p1.y)*t); coverPts.add(x+','+y); }
  }
}

/* Composite hidden with mask (destination-in keeps only masked areas) */
function updateComposite(){
  const ctx = hidden.getContext('2d');
  // Draw hidden already present, now apply mask to fx canvas then copy back
  const tmp = document.createElement('canvas'); tmp.width=hidden.width; tmp.height=hidden.height;
  const gt = tmp.getContext('2d');
  gt.drawImage(hidden,0,0);
  gt.globalCompositeOperation='destination-in';
  gt.drawImage(mask,0,0);
  // Blit to fx for display, leaving guide above
  gx.clearRect(0,0,fx.width,fx.height);
  gx.drawImage(tmp,0,0);
}

/* Drawing handlers */
function pos(e){ const r=fx.getBoundingClientRect(); const x=((e.clientX||e.pageX)-r.left)*DPR; const y=((e.clientY||e.pageY)-r.top)*DPR; return {x,y}; }
function down(e){ if(!playing||isCompleting) return; isDrawing=true; draw(e); }
function move(e){ if(!isDrawing||!playing||isCompleting) return; draw(e); }
function up(){ isDrawing=false; }
function draw(e){
  const {x,y}=pos(e);
  gm.globalCompositeOperation='source-over';
  gm.fillStyle='white'; gm.beginPath(); gm.arc(x, y, brush*DPR/2, 0, Math.PI*2); gm.fill();
  // Coverage
  const r = Math.round(brush*DPR/2);
  for(let dx=-r; dx<=r; dx++){
    for(let dy=-r; dy<=r; dy++){
      if(dx*dx+dy*dy<=r*r){
        const key=(Math.round(x+dx))+','+(Math.round(y+dy));
        if(coverPts.has(key)) covered.add(key);
      }
    }
  }
  const cov = Math.min(100, Math.round((covered.size/Math.max(1,coverPts.size))*100));
  bestCov = Math.max(bestCov, cov);
  covNowV.textContent = cov + '%';
  updateComposite();
  if(cov>=requiredCov && !isCompleting){ complete(cov); }
}
fx.addEventListener('mousedown', down);
fx.addEventListener('mousemove', move);
addEventListener('mouseup', up);
fx.addEventListener('touchstart', (e)=>{ e.preventDefault(); down(e.touches[0]); }, {passive:false});
fx.addEventListener('touchmove', (e)=>{ e.preventDefault(); move(e.touches[0]); }, {passive:false});
fx.addEventListener('touchend', (e)=>{ e.preventDefault(); up(); }, {passive:false});

/* Shape cycle */
function newShape(){
  const gen = SHAPES[Math.floor(Math.random()*SHAPES.length)];
  path = gen();
  drawGuide();
  drawHidden();
  buildCoverage();
  updateComposite();
}

/* Session flow */
function start(){
  const mins = Math.max(0.5, Math.min(30, Number(durInput.value||2)));
  totalMs = Math.round(mins*60*1000);
  remainingMs = totalMs;
  score=0; shapesDone=0; bestCov=0; scoreV.textContent='0'; doneV.textContent='0'; covNowV.textContent='0%'; timeV.textContent=fmt(remainingMs);
  rightCol.classList.remove('hidden'); document.body.classList.add('playing');
  playing=true; paused=false; startTs=performance.now();
  resizeStage(); newShape(); loop();
}
function loop(){
  if(!playing){ cancelAnimationFrame(raf); return; }
  raf = requestAnimationFrame(loop);
  if(paused) return;
  const now = performance.now();
  remainingMs = Math.max(0, totalMs - (now - startTs));
  timeV.textContent = fmt(remainingMs);
  if(remainingMs<=0){ end(); }
}
function pause(){ if(!playing) return; paused=!paused; if(!paused){ startTs = performance.now() - (totalMs - remainingMs); } }
function exit(){ if(!playing) return; playing=false; paused=false; document.body.classList.remove('playing'); rightCol.classList.add('hidden'); cancelAnimationFrame(raf); }
function end(){
  playing=false; paused=false; document.body.classList.remove('playing');
  cancelAnimationFrame(raf);
  document.getElementById('finalShapes').textContent = String(shapesDone);
  document.getElementById('finalCov').textContent = Math.round(bestCov) + '%';
  donePane.classList.remove('hidden');
}
function complete(cov){
  isCompleting=true; shapesDone++; doneV.textContent=String(shapesDone);
  // simple flash
  gx.save(); gx.fillStyle='rgba(255,255,255,.16)'; gx.fillRect(0,0,fx.width,fx.height); gx.restore();
  setTimeout(()=>{ gx.clearRect(0,0,fx.width,fx.height); isCompleting=false; if(playing) newShape(); }, 200);
}

/* Buttons & keys */
startBtn.addEventListener('click', start);
pauseBtn.addEventListener('click', pause);
exitBtn.addEventListener('click', exit);
againBtn.addEventListener('click', ()=>{ donePane.classList.add('hidden'); start(); });
closeBtn.addEventListener('click', ()=> donePane.classList.add('hidden'));
addEventListener('keydown', (e)=>{ if(!playing) return; if(e.key===' '){ e.preventDefault(); pause(); } if(e.key==='Escape'){ e.preventDefault(); exit(); }});

/* Init */
drawIdleGuide();
</script>
</body>
</html>
