<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Trace &amp; Reveal — Fine Point Rehab</title>

  <style>
    :root{
      --vh: 1vh;
      --bg1:#070b16; --bg2:#0f1630; --bg3:#0b1024;
      --accent:#6fd3f5; --panel:rgba(10,16,36,.9); --bd:rgba(255,255,255,.08); --text:#eaf6ff;
      --radius:14px;
    }
    html,body{height:100%}
    body{
      margin:0; color:var(--text); font:15px/1.5 system-ui, Segoe UI, Inter, -apple-system, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1200px 800px at 20% 25%, rgba(70,30,120,.35), transparent 60%),
        radial-gradient(900px 700px at 75% 65%, rgba(20,120,160,.28), transparent 55%),
        linear-gradient(180deg,var(--bg1) 0%, var(--bg2) 50%, var(--bg3) 100%);
      min-height: calc(var(--vh) * 100);
      touch-action: manipulation;
    }
    header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg, rgba(6,10,24,.85), rgba(6,10,24,.55));border-bottom:1px solid var(--bd);backdrop-filter: blur(6px)}
    header .wrap{display:flex;gap:12px;align-items:center;padding:10px 16px}
    .layout{display:grid;grid-template-columns:min(420px,36vw) 1fr;gap:16px;max-width:1280px;margin:0 auto;padding:16px}
    @media (max-width:900px){.layout{grid-template-columns:1fr}}
    .panel{background:var(--panel);border:1px solid var(--bd);border-radius:var(--radius);box-shadow:0 12px 28px rgba(0,0,0,.35),inset 0 0 40px rgba(0,0,0,.25)}
    .desc{font-size:13px;opacity:.95;background:linear-gradient(180deg, rgba(6,10,24,.65), rgba(6,10,24,.35));border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:10px;margin:10px 0 14px}
    .group{margin-bottom:12px}.label{display:block;margin:0 0 6px;font-weight:700}
    select,input[type=number]{width:100%;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,.2);background:rgba(5,10,26,.8);color:var(--text);font-size:16px}
    select:focus,input[type=number]:focus{outline:none;border-color:rgba(111,211,245,.9);box-shadow:0 0 0 2px rgba(111,211,245,.25)}
    .btn{min-height:46px;border:1px solid rgba(111,211,245,.35);background:rgba(111,211,245,.12);color:var(--text);border-radius:10px;font-weight:800;letter-spacing:.2px;cursor:pointer;transition:.2s}
    .btn:hover:not(:disabled){background:rgba(111,211,245,.22);transform:translateY(-1px)}
    .btn-primary{background:rgba(111,211,245,.95);color:#07101e;border-color:rgba(111,211,245,1)}
    .btn-primary:hover:not(:disabled){background:rgba(111,211,245,1);box-shadow:0 6px 18px rgba(111,211,245,.45)}
    .hud{display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:8px 10px;margin-bottom:10px;background:rgba(8,14,36,.85);border:1px solid var(--bd);border-radius:var(--radius);box-shadow:0 6px 16px rgba(0,0,0,.35)}
    .metric{display:grid;grid-template-rows:auto auto;min-width:110px}
    .v{font-weight:900;font-size:20px;color:#d7f2ff;text-shadow:0 0 8px rgba(160,220,255,.7)}
    .t{font-size:11px;opacity:.9;margin-top:2px}
    .actions{margin-left:auto;display:flex;gap:8px}
    .frame{position:relative;border-radius:var(--radius);overflow:hidden;border:1px solid var(--bd);box-shadow:inset 0 0 40px rgba(0,0,0,.35);background: radial-gradient(60% 45% at 50% 40%, rgba(80,160,200,.12), transparent 68%)}
    .stage-wrap{position:relative;width:100%;aspect-ratio:1/1}
    canvas.stage{position:absolute;inset:0;width:100%;height:100%;display:block;background:transparent;touch-action:none}
    body.playing .layout{grid-template-columns:1fr;padding:0;height:calc(var(--vh) * 100)}
    body.playing #settings{display:none}
    .hidden{display:none !important}
    :focus-visible{outline:3px solid rgba(111,211,245,.85);outline-offset:2px}
    #errbar{position:fixed;left:0;right:0;bottom:0;background:#400;color:#fff;font:13px/1.4 system-ui;padding:8px 12px;display:none;z-index:9999}
  </style>
</head>
<body>
<header><div class="wrap"><h1>Trace &amp; Reveal</h1><div style="flex:1"></div></div></header>
<div id="errbar"></div>

<main class="layout">
  <!-- SETTINGS -->
  <aside id="settings" class="panel" style="padding:16px" aria-label="Settings">
    <h2>Settings</h2>
    <div class="desc">
      <strong>How to play:</strong> Trace the dotted line to reveal the shape. Hit the coverage target before time runs out.
      Press <strong>Space</strong> to pause, <strong>Esc</strong> to exit.
    </div>
    <div class="group">
      <label class="label" for="dur">Session Duration (minutes)</label>
      <input id="dur" type="number" min="0.5" step="0.5" max="30" value="2" inputmode="decimal" />
    </div>
    <div class="group">
      <label class="label" for="difficulty">Difficulty</label>
      <select id="difficulty">
        <option value="easy">Easy (lines &amp; zigzags)</option>
        <option value="medium" selected>Medium (basic shapes)</option>
        <option value="hard">Hard (complex outlines)</option>
      </select>
      <div id="covHint" class="t" aria-live="polite" style="margin-top:6px">Coverage target: 85%</div>
    </div>
    <button id="start" class="btn btn-primary" type="button">Start</button>
  </aside>

  <!-- GAME -->
  <section aria-label="Game">
    <div class="hud">
      <div class="metric" aria-live="polite"><div id="doneCount" class="v">0</div><div class="t">Completed</div></div>
      <div class="metric" aria-live="polite"><div id="covNow"   class="v">0%</div><div class="t">Coverage</div></div>
      <div class="metric" aria-live="polite"><div id="time"     class="v">00:00</div><div class="t">Time</div></div>
      <div class="actions">
        <button id="pauseHud" class="btn" type="button" aria-label="Pause or resume">Pause</button>
        <button id="exitHud"  class="btn" type="button" aria-label="Exit to results">Exit</button>
      </div>
    </div>

    <div class="frame panel" style="padding:8px">
      <div class="stage-wrap">
        <canvas id="hidden" class="stage" aria-hidden="true"></canvas>
        <canvas id="mask"   class="stage" aria-hidden="true"></canvas>
        <canvas id="fx"     class="stage" aria-hidden="true"></canvas>
        <canvas id="guide"  class="stage" aria-label="Trace guide"></canvas>
      </div>
    </div>
  </section>
</main>

<!-- RESULTS -->
<div id="done" class="hidden" role="dialog" aria-modal="true" style="position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.6);backdrop-filter:blur(4px)">
  <div class="panel" style="padding:20px;max-width:min(520px,92vw)">
    <h2 style="color:var(--accent);margin:0 0 8px">Session Complete</h2>
    <p><strong>Shapes completed:</strong> <span id="finalShapes">0</span></p>
    <p><strong>Best coverage:</strong> <span id="finalCov">0%</span></p>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="again" class="btn btn-primary">Start New Session</button>
      <button id="close" class="btn">Close</button>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  // === friendly error banner ===
  const errbar = document.getElementById("errbar");
  window.addEventListener("error", (e) => {
    errbar.style.display = "block";
    errbar.textContent = `Script error: ${e.message || ""} ${e.filename ? "— " + e.filename + ":" + e.lineno : ""}`;
  });

  // === viewport fix for mobile ===
  const setVH = () => document.documentElement.style.setProperty("--vh", `${window.innerHeight * 0.01}px`);
  setVH(); addEventListener("resize", setVH); addEventListener("orientationchange", setVH);

  // === elements ===
  const startBtn = document.getElementById("start");
  const durInput = document.getElementById("dur");
  const diffSelect = document.getElementById("difficulty");
  const covHint = document.getElementById("covHint");
  const timeV = document.getElementById("time");
  const doneV = document.getElementById("doneCount");
  const covNowV = document.getElementById("covNow");
  const pauseBtn = document.getElementById("pauseHud");
  const exitBtn  = document.getElementById("exitHud");
  const donePane = document.getElementById("done");
  const againBtn = document.getElementById("again");
  const closeBtn = document.getElementById("close");

  // canvases
  const hidden = document.getElementById("hidden");
  const mask   = document.getElementById("mask");
  const fx     = document.getElementById("fx");
  const guide  = document.getElementById("guide");
  const gh = hidden.getContext("2d");
  const gm = mask.getContext("2d");
  const gx = fx.getContext("2d");
  const gg = guide.getContext("2d");
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // === state ===
  let playing = false;
  let paused = false;
  let remainingMs = 0;
  let timeLoop = 0;

  let shapesDone = 0;
  let bestCov = 0;

  let path = [];
  let pathClosed = true;
  let pathStrokePx = 0;

  const coverPts = new Set();
  const covered = new Set();

  const brush = 28; // px at 1x DPR
  let requiredCov = 85;

  // === helpers ===
  const fmt = (ms) => {
    const s = Math.max(0, Math.ceil(ms / 1000));
    const mm = String(Math.floor(s / 60)).padStart(2, "0");
    const ss = String(s % 60).padStart(2, "0");
    return `${mm}:${ss}`;
  };

  const applyDifficulty = () => {
    requiredCov = diffSelect.value === "easy" ? 70 : (diffSelect.value === "hard" ? 95 : 85);
    covHint.textContent = `Coverage target: ${requiredCov}%`;
  };
  diffSelect.addEventListener("change", applyDifficulty);
  applyDifficulty();

  const resizeStage = () => {
    const wrap = fx.parentElement.getBoundingClientRect();
    const size = Math.max(10, Math.floor(wrap.width));
    [hidden, mask, fx, guide].forEach((c) => {
      c.width = Math.floor(size * DPR);
      c.height = Math.floor(size * DPR);
      c.style.width = `${size}px`;
      c.style.height = `${size}px`;
    });
    if (playing) {
      newShape(); // regenerate to fit new size
    } else {
      drawIdleGuide();
    }
  };
  new ResizeObserver(resizeStage).observe(fx.parentElement);

  const drawIdleGuide = () => {
    gg.clearRect(0, 0, guide.width, guide.height);
    gg.save();
    gg.scale(DPR, DPR);
    gg.fillStyle = "rgba(255,255,255,.06)";
    gg.fillRect(0, 0, guide.width / DPR, guide.height / DPR);
    gg.fillStyle = "rgba(255,255,255,.9)";
    gg.font = "600 16px system-ui, sans-serif";
    gg.textAlign = "center";
    gg.fillText("Set duration, pick difficulty, then Start", guide.width / (2 * DPR), guide.height / (2 * DPR));
    gg.restore();
  };

  // === shape helpers ===
  const desc = (pts, closed = true, strokePx = 0) => ({ points: pts, closed, strokePx });

  const lineH = () => {
    const y = hidden.height * 0.5, x1 = hidden.width * 0.15, x2 = hidden.width * 0.85;
    return desc([{ x: x1, y }, { x: x2, y }], false, Math.round(hidden.height * 0.08));
  };
  const lineV = () => {
    const x = hidden.width * 0.5, y1 = hidden.height * 0.18, y2 = hidden.height * 0.82;
    return desc([{ x, y: y1 }, { x, y: y2 }], false, Math.round(hidden.width * 0.08));
  };
  const lineD = () => {
    const m = hidden.width * 0.15;
    return desc([{ x: m, y: m }, { x: hidden.width - m, y: hidden.height - m }], false, Math.round(hidden.width * 0.07));
  };
  const zigzag = () => {
    const pts = [];
    const l = hidden.width * 0.18, r = hidden.width * 0.82, t = hidden.height * 0.22, b = hidden.height * 0.78, rows = 6;
    for (let i = 0; i <= rows; i++) {
      const y = t + (b - t) * (i / rows);
      const x = (i % 2 === 0) ? l : r;
      pts.push({ x, y });
    }
    return desc(pts, false, Math.round(hidden.width * 0.07));
  };
  const sine = () => {
    const pts = [];
    const l = hidden.width * 0.12, r = hidden.width * 0.88, mid = hidden.height * 0.5, amp = hidden.height * 0.22, cyc = 1.5, steps = 160;
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const x = l + (r - l) * t;
      const y = mid + Math.sin(t * Math.PI * 2 * cyc) * amp;
      pts.push({ x, y });
    }
    return desc(pts, false, Math.round(hidden.width * 0.06));
  };
  const lshape = () => {
    const x = hidden.width * 0.25, y = hidden.height * 0.25, w = hidden.width * 0.5, h = hidden.height * 0.5;
    return desc([{ x, y }, { x, y: y + h }, { x: x + w, y: y + h }], false, Math.round(hidden.width * 0.07));
  };

  const circle = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2, r = Math.min(hidden.width, hidden.height) * 0.32, pts = [];
    for (let i = 0; i <= 180; i++) {
      const a = (i / 180) * Math.PI * 2;
      pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
    }
    return desc(pts, true, 0);
  };
  const square = () => {
    const s = Math.min(hidden.width, hidden.height) * 0.64, x = (hidden.width - s) / 2, y = (hidden.height - s) / 2;
    return desc([{ x, y }, { x: x + s, y }, { x: x + s, y: y + s }, { x, y: y + s }, { x, y }], true, 0);
  };
  const rect = () => {
    const w = Math.min(hidden.width, hidden.height) * 0.72, h = w * 0.6, x = (hidden.width - w) / 2, y = (hidden.height - h) / 2;
    return desc([{ x, y }, { x: x + w, y }, { x: x + w, y: y + h }, { x, y: y + h }, { x, y }], true, 0);
  };
  const tri = () => {
    const s = Math.min(hidden.width, hidden.height) * 0.68, cx = hidden.width / 2, cy = hidden.height / 2;
    return desc([{ x: cx, y: cy - s / 2 }, { x: cx - s / 2, y: cy + s / 2 }, { x: cx + s / 2, y: cy + s / 2 }, { x: cx, y: cy - s / 2 }], true, 0);
  };
  const diamond = () => {
    const s = Math.min(hidden.width, hidden.height) * 0.68, cx = hidden.width / 2, cy = hidden.height / 2;
    return desc([{ x: cx, y: cy - s / 2 }, { x: cx + s / 2, y: cy }, { x: cx, y: cy + s / 2 }, { x: cx - s / 2, y: cy }, { x: cx, y: cy - s / 2 }], true, 0);
  };
  const hex = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2, r = Math.min(hidden.width, hidden.height) * 0.32, pts = [];
    for (let i = 0; i < 6; i++) {
      const a = (i / 6) * Math.PI * 2;
      pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
    }
    pts.push(pts[0]);
    return desc(pts, true, 0);
  };
  const star = () => {
    const cx = hidden.width / 2, cy = hidden.height / 2, R = Math.min(hidden.width, hidden.height) * 0.34, r = R * 0.45, pts = [];
    for (let i = 0; i < 10; i++) {
      const a = (i / 10) * Math.PI * 2 - Math.PI / 2;
      const rad = (i % 2 === 0) ? R : r;
      pts.push({ x: cx + Math.cos(a) * rad, y: cy + Math.sin(a) * rad });
    }
    pts.push(pts[0]);
    return desc(pts, true, 0);
  };

  const house = () => {
    const w = hidden.width * 0.6, h = hidden.height * 0.5, x = (hidden.width - w) / 2, y = (hidden.height - h) / 2 + hidden.height * 0.08, roofH = h * 0.45;
    return desc([{ x: x, y: y + h }, { x: x, y: y + roofH }, { x: x + w / 2, y: y }, { x: x + w, y: y + roofH }, { x: x + w, y: y + h }, { x: x, y: y + h }], true, 0);
  };
  const tree = () => {
    const cx = hidden.width / 2, base = hidden.height * 0.78, tw = hidden.width * 0.08, th = hidden.height * 0.18;
    const trunk = [{ x: cx - tw / 2, y: base }, { x: cx - tw / 2, y: base - th }, { x: cx + tw / 2, y: base - th }, { x: cx + tw / 2, y: base }, { x: cx - tw / 2, y: base }];
    const cw = hidden.width * 0.6, ch = hidden.height * 0.5, left = cx - cw / 2, top = base - th - ch;
    const canopy = [
      { x: cx, y: top }, { x: left + cw * 0.15, y: top + ch * 0.35 }, { x: left + cw * 0.30, y: top + ch * 0.35 },
      { x: left + cw * 0.10, y: top + ch * 0.65 }, { x: left + cw * 0.40, y: top + ch * 0.65 }, { x: left + cw * 0.20, y: top + ch * 0.95 },
      { x: left + cw * 0.80, y: top + ch * 0.95 }, { x: left + cw * 0.60, y: top + ch * 0.65 }, { x: left + cw * 0.90, y: top + ch * 0.65 },
      { x: left + cw * 0.70, y: top + ch * 0.35 }, { x: left + cw * 0.85, y: top + ch * 0.35 }, { x: cx, y: top }
    ];
    return desc(canopy.concat(trunk), true, 0);
  };
  const boat = () => {
    const cx = hidden.width / 2, cy = hidden.height * 0.6, w = hidden.width * 0.7, h = hidden.height * 0.18;
    const hull = [{ x: cx - w / 2, y: cy }, { x: cx - w * 0.35, y: cy + h }, { x: cx + w * 0.35, y: cy + h }, { x: cx + w / 2, y: cy }, { x: cx - w / 2, y: cy }];
    const sail = [{ x: cx, y: cy }, { x: cx, y: cy - h * 2 }, { x: cx + w * 0.25, y: cy - h }, { x: cx, y: cy }];
    return desc(hull.concat(sail), true, 0);
  };
  const bolt = () => {
    const x = hidden.width * 0.35, y = hidden.height * 0.18, w = hidden.width * 0.3, h = hidden.height * 0.6;
    return desc([{ x: x, y: y }, { x: x + w * 0.25, y: y + h * 0.25 }, { x: x - w * 0.10, y: y + h * 0.25 }, { x: x + w * 0.65, y: y + h * 0.9 }, { x: x + w * 0.40, y: y + h * 0.45 }, { x: x + w * 0.75, y: y + h * 0.45 }, { x: x, y: y }], true, 0);
  };

  const POOLS = {
    easy:   [lineH, lineV, lineD, zigzag, sine, lshape],
    medium: [circle, square, rect, tri, diamond, hex, star],
    hard:   [house, tree, boat, bolt, star, hex]
  };

  const drawGuide = () => {
    if (!path.length) { drawIdleGuide(); return; }
    gg.clearRect(0, 0, guide.width, guide.height);
    gg.save();
    gg.lineCap = "round"; gg.lineJoin = "round";
    gg.strokeStyle = "rgba(0,0,0,.9)"; gg.lineWidth = 8 * DPR; gg.setLineDash([]);
    gg.beginPath();
    gg.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) gg.lineTo(path[i].x, path[i].y);
    if (pathClosed) gg.closePath();
    gg.stroke();

    gg.strokeStyle = "rgba(255,255,255,.98)"; gg.lineWidth = 4 * DPR; gg.setLineDash([14 * DPR, 10 * DPR]);
    gg.beginPath();
    gg.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) gg.lineTo(path[i].x, path[i].y);
    if (pathClosed) gg.closePath();
    gg.stroke();
    gg.restore();
  };

  const drawHidden = () => {
    gh.clearRect(0, 0, hidden.width, hidden.height);
    const hue = Math.floor(Math.random() * 360);
    const g0 = `hsl(${hue},80%,60%)`;
    const g1 = `hsl(${(hue + 40) % 360},80%,45%)`;
    const grd = gh.createRadialGradient(hidden.width / 2, hidden.height / 2, 0, hidden.width / 2, hidden.height / 2, hidden.width / 2);
    grd.addColorStop(0, g0);
    grd.addColorStop(1, g1);

    gh.beginPath();
    gh.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) gh.lineTo(path[i].x, path[i].y);

    if (pathClosed) {
      gh.closePath();
      gh.fillStyle = grd;
      gh.fill();
    } else {
      gh.lineCap = "round"; gh.lineJoin = "round"; gh.lineWidth = Math.max(4, pathStrokePx); gh.strokeStyle = grd; gh.stroke();
    }

    gm.clearRect(0, 0, mask.width, mask.height);
  };

  const buildCoverage = () => {
    coverPts.clear(); covered.clear();
    for (let i = 0; i < path.length - 1; i++) {
      const p1 = path[i], p2 = path[i + 1];
      const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      const steps = Math.max(1, Math.ceil(dist / (6 * DPR)));
      for (let j = 0; j <= steps; j++) {
        const t = j / steps;
        const x = Math.round(p1.x + (p2.x - p1.x) * t);
        const y = Math.round(p1.y + (p2.y - p1.y) * t);
        coverPts.add(`${x},${y}`);
      }
    }
  };

  const updateComposite = () => {
    const tmp = document.createElement("canvas");
    tmp.width = hidden.width; tmp.height = hidden.height;
    const gt = tmp.getContext("2d");
    gt.drawImage(hidden, 0, 0);
    gt.globalCompositeOperation = "destination-in";
    gt.drawImage(mask, 0, 0);
    gx.clearRect(0, 0, fx.width, fx.height);
    gx.drawImage(tmp, 0, 0);
  };

  // pointer helpers
  const pos = (e) => {
    const r = fx.getBoundingClientRect();
    const x = ((e.clientX || e.pageX) - r.left) * DPR;
    const y = ((e.clientY || e.pageY) - r.top) * DPR;
    return { x, y };
  };

  let isDrawing = false;
  let isCompleting = false;

  const draw = (e) => {
    const p = pos(e);

    gm.globalCompositeOperation = "source-over";
    gm.fillStyle = "white";
    gm.beginPath();
    gm.arc(p.x, p.y, brush * DPR / 2, 0, Math.PI * 2);
    gm.fill();

    updateComposite();

    // cursor ring
    gx.save();
    gx.globalCompositeOperation = "source-over";
    gx.strokeStyle = "rgba(255,255,255,0.35)";
    gx.lineWidth = Math.max(1, 1 * DPR);
    gx.beginPath();
    gx.arc(p.x, p.y, brush * DPR * 0.48, 0, Math.PI * 2);
    gx.stroke();
    gx.restore();

    // coverage sampling
    const rpx = Math.round(brush * DPR / 2);
    for (let dx = -rpx; dx <= rpx; dx++) {
      for (let dy = -rpx; dy <= rpx; dy++) {
        if (dx * dx + dy * dy <= rpx * rpx) {
          covered.add(`${Math.round(p.x + dx)},${Math.round(p.y + dy)}`);
        }
      }
    }

    const cov = Math.min(100, Math.round((covered.size / Math.max(1, coverPts.size)) * 100));
    bestCov = Math.max(bestCov, cov);
    covNowV.textContent = `${cov}%`;

    if (cov >= requiredCov && !isCompleting) complete();
  };

  const down = (e) => { if (!playing || isCompleting) return; isDrawing = true; draw(e); };
  const move = (e) => { if (!isDrawing || !playing || isCompleting) return; draw(e); };
  const up   = () => { isDrawing = false; };

  fx.addEventListener("mousedown", down);
  fx.addEventListener("mousemove", move);
  addEventListener("mouseup", up);

  fx.addEventListener("touchstart", (e) => { e.preventDefault(); down(e.touches[0]); }, { passive: false });
  fx.addEventListener("touchmove",  (e) => { e.preventDefault(); move(e.touches[0]); }, { passive: false });
  fx.addEventListener("touchend",   (e) => { e.preventDefault(); up(); }, { passive: false });

  const newShape = () => {
    const pool = POOLS[diffSelect.value] || POOLS.medium;
    const gen = pool[Math.floor(Math.random() * pool.length)];
    const d = gen();
    path = d.points; pathClosed = d.closed; pathStrokePx = d.strokePx || 0;
    drawGuide(); drawHidden(); buildCoverage(); updateComposite();
  };

  // === flow ===
  const start = () => {
    const mins = Math.max(0.5, Math.min(30, Number(durInput.value || 2)));
    remainingMs = Math.round(mins * 60 * 1000);
    shapesDone = 0; bestCov = 0;
    doneV.textContent = "0";
    covNowV.textContent = "0%";
    timeV.textContent = fmt(remainingMs);

    document.body.classList.add("playing");
    playing = true; paused = false;

    // Defer sizing until after layout
    requestAnimationFrame(() => { resizeStage(); newShape(); loop(performance.now()); });
  };

  const loop = (last) => {
    if (!playing) return;
    timeLoop = requestAnimationFrame((now) => {
      if (!paused) {
        const dt = now - last;
        remainingMs = Math.max(0, remainingMs - dt);
        timeV.textContent = fmt(remainingMs);
        if (remainingMs <= 0) { end(); return; }
      }
      loop(now);
    });
  };

  const pause = () => { if (!playing) return; paused = !paused; };
  const exit  = () => { if (!playing) return; playing = false; paused = false; document.body.classList.remove("playing"); cancelAnimationFrame(timeLoop); };

  const end = () => {
    playing = false; paused = false; document.body.classList.remove("playing"); cancelAnimationFrame(timeLoop);
    document.getElementById("finalShapes").textContent = String(shapesDone);
    document.getElementById("finalCov").textContent = `${Math.round(bestCov)}%`;
    donePane.classList.remove("hidden");
  };

  const complete = () => {
    isCompleting = true;
    shapesDone += 1;
    doneV.textContent = String(shapesDone);
    gx.save(); gx.fillStyle = "rgba(255,255,255,.16)"; gx.fillRect(0, 0, fx.width, fx.height); gx.restore();
    setTimeout(() => {
      gx.clearRect(0, 0, fx.width, fx.height);
      isCompleting = false;
      if (playing) newShape();
    }, 180);
  };

  // buttons & keys
  startBtn.addEventListener("click", start);
  pauseBtn.addEventListener("click", pause);
  exitBtn.addEventListener("click", exit);
  againBtn.addEventListener("click", () => { donePane.classList.add("hidden"); start(); });
  closeBtn.addEventListener("click", () => { donePane.classList.add("hidden"); });

  addEventListener("keydown", (e) => {
    if (!playing) return;
    if (e.key === " ") { e.preventDefault(); pause(); }
    if (e.key === "Escape") { e.preventDefault(); exit(); }
  });

  // initial idle state
  drawIdleGuide();
})();
</script>
</body>
</html>
