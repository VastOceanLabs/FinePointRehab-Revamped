<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Trace & Reveal — Fine Motor Training</title>

  <style>
    :root {
      --bg-primary: #0f1629;
      --bg-secondary: #1a1f3a;
      --bg-tertiary: #252b47;
      --text-primary: #e8eef5;
      --text-secondary: #b8c5d1;
      --text-muted: #8a96a3;
      --brand-aqua: #6fd3f5;
      --success: #4caf50;
      --error: #ff6b6b;
      --error-bg: #2d1b1b;
      --border: #374151;
      --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.3);
      --radius: 8px;
      --radius-lg: 12px;
      --radius-xl: 16px;
      --radius-full: 50%;
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-6: 24px;
      --font-size-xs: 12px;
      --font-size-base: 16px;
      --font-size-lg: 20px;
      --font-size-xl: 24px;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;
      --duration-fast: 150ms;
      --easing: cubic-bezier(0.4, 0, 0.2, 1);
      --vh: 1vh;
      --header-h: 0px;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(180deg, #0a0e1a 0%, #1a1f3a 50%, #0f1524 100%);
      color: var(--text-primary);
      min-height: calc(var(--vh) * 100);
      touch-action: manipulation;
    }

    body.playing {
      overflow: hidden;
      overscroll-behavior: none;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-4);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-semibold);
      text-decoration: none;
      cursor: pointer;
      transition: all var(--duration-fast) var(--easing);
      min-height: 44px;
    }

    .btn:hover {
      border-color: var(--brand-aqua);
      background-color: var(--bg-tertiary);
    }

    .btn-primary {
      background-color: var(--brand-aqua);
      color: #000;
      border-color: var(--brand-aqua);
    }

    .btn-primary:hover {
      background-color: #5bc2e7;
    }

    .btn-secondary {
      background-color: var(--bg-tertiary);
    }

    .input, select {
      width: 100%;
      padding: var(--space-2) var(--space-3);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      font-size: var(--font-size-base);
    }

    .input:focus, select:focus {
      outline: none;
      border-color: var(--brand-aqua);
      box-shadow: 0 0 0 2px rgba(111, 211, 245, 0.25);
    }

    .panel {
      background: rgba(15, 22, 41, 0.8);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-4);
      box-shadow: var(--shadow-lg);
    }

    .site-header {
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(8px);
      background: rgba(8, 15, 35, 0.8);
      border-bottom: 1px solid var(--border);
    }

    .site-header .inner {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-3) var(--space-4);
      max-width: 1200px;
      margin: 0 auto;
    }

    .site-header h1 {
      margin: 0;
      font-size: var(--font-size-xl);
      line-height: 1.2;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: var(--space-4);
    }

    [data-screen] {
      display: none !important;
    }

    [data-screen].active {
      display: block !important;
    }

    .settings-panel {
      max-width: 480px;
      margin: 0 auto;
      padding-top: var(--space-6);
    }

    .settings-panel h2 {
      margin: 0 0 var(--space-4);
      font-size: var(--font-size-lg);
      text-align: center;
    }

    .game-description {
      background: var(--bg-tertiary);
      border-radius: var(--radius);
      padding: var(--space-4);
      margin-bottom: var(--space-4);
      border: 1px solid var(--border);
    }

    .stats-row {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: var(--space-4);
    }

    .metric-settings {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: var(--space-2) var(--space-3);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: rgba(111, 211, 245, 0.08);
      min-width: 110px;
    }

    .pb-value {
      font-weight: var(--font-weight-bold);
      font-size: var(--font-size-lg);
      color: var(--brand-aqua);
      text-shadow: 0 0 6px rgba(111, 211, 245, 0.5);
      line-height: 1.1;
    }

    .pb-label {
      font-size: var(--font-size-xs);
      opacity: 0.9;
      margin-top: var(--space-1);
      color: var(--text-secondary);
    }

    .settings-group {
      margin-bottom: var(--space-4);
    }

    .settings-label {
      display: block;
      margin-bottom: var(--space-2);
      font-weight: var(--font-weight-semibold);
    }

    .setting-help {
      display: block;
      color: var(--text-muted);
      font-size: var(--font-size-xs);
      margin-top: var(--space-1);
      font-style: italic;
    }

    .right-col {
      display: grid;
      grid-template-rows: auto 1fr;
      gap: var(--space-3);
      min-height: 0;
    }

    .hud {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: 1fr;
      gap: var(--space-2);
      align-items: center;
      position: relative;
      padding-top: calc(var(--space-3) + 8px);
    }

    @media (max-width: 768px) {
      .hud {
        grid-template-columns: 1fr 1fr 1fr;
        grid-auto-flow: row;
        gap: var(--space-1);
        padding: var(--space-2);
        padding-top: calc(var(--space-2) + 6px);
      }
      
      .hud-value {
        font-size: var(--font-size-base);
      }
      
      .hud-label {
        font-size: 11px;
      }
      
      .controls {
        grid-column: 1 / -1;
        display: flex;
        gap: var(--space-2);
        justify-content: center;
        margin-top: var(--space-1);
      }
      
      .controls .btn {
        padding: 6px 12px;
        font-size: 13px;
      }
    }

    .hud-group {
      display: grid;
      gap: var(--space-1);
      text-align: center;
    }

    .hud-value {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--brand-aqua);
      text-shadow: 0 0 8px rgba(111, 211, 245, 0.7);
    }

    .hud-label {
      font-size: var(--font-size-xs);
      color: var(--text-secondary);
      opacity: 0.9;
    }

    .timer-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 8px;
      width: 100%;
      background: linear-gradient(90deg, var(--brand-aqua), rgba(111,211,245,.35));
      transform-origin: left center;
      transition: width .1s linear;
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
    }

    .controls {
      display: flex;
      gap: var(--space-2);
      justify-content: center;
      flex-wrap: wrap;
    }

    .instructions {
      text-align: center;
      color: var(--text-secondary);
      margin: 0 0 var(--space-3);
      font-size: var(--font-size-base);
      padding: var(--space-3);
      background-color: rgba(8, 15, 35, 0.7);
      border-radius: var(--radius);
    }

    #game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      min-height: 0;
      padding: var(--space-3);
      padding-bottom: max(var(--space-1), env(safe-area-inset-bottom));
      background: rgba(0,0,0,0.15);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-lg);
      overflow: hidden;
    }

    #stars-container {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    body.playing .page {
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 0;
      max-width: none;
      padding: 0;
      height: calc(var(--vh) * 100 - var(--header-h, 0px));
    }

    body.playing .settings-panel {
      display: none;
    }

    body.playing .right-col {
      height: calc(var(--vh) * 100);
      max-width: none;
      margin: 0;
      gap: 0;
      grid-template-rows: auto 1fr;
      min-height: 0;
    }

    body.playing #game-container {
      height: 100%;
      border-radius: 0;
      border: none;
      padding: var(--space-2);
      padding-bottom: max(var(--space-1), env(safe-area-inset-bottom));
    }

    .stage-wrap {
      position: relative;
      flex: 1;
      min-height: 0;
      width: 100%;
      display: block;
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.35);
      background: radial-gradient(60% 45% at 50% 40%, rgba(111, 211, 245, 0.12), transparent 68%);
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      aspect-ratio: 1 / 1;
    }

    .stage-wrap .stage {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
      touch-action: none;
    }

    #hidden { z-index: 0; }
    #mask   { z-index: 1; }
    #fx     { z-index: 2; }
    #ink    { z-index: 3; pointer-events: none; }
    #guide  { z-index: 4; pointer-events: none; }

    .coverage-display {
      position: absolute;
      top: var(--space-2);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 22, 41, 0.95);
      border: 2px solid var(--brand-aqua);
      border-radius: var(--radius-lg);
      padding: var(--space-2) var(--space-3);
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow-lg);
      font-weight: var(--font-weight-bold);
      font-size: var(--font-size-xs);
      z-index: 20;
      color: var(--brand-aqua);
    }

    @media (max-width: 768px) {
      body.playing .hud {
        padding: var(--space-1) var(--space-2);
        padding-top: calc(var(--space-1) + 4px);
        gap: var(--space-1);
      }

      body.playing #game-container {
        padding: var(--space-1);
      }

      .instructions {
        font-size: 14px;
        padding: var(--space-2);
        margin-bottom: var(--space-2);
      }

      .coverage-display {
        font-size: 11px;
        padding: 4px 8px;
      }
    }

    @media (max-height: 720px) {
      .instructions {
        display: none;
      }
    }

    @media (max-height: 600px) {
      body.playing .hud {
        padding: 4px var(--space-1);
        padding-top: 8px;
      }
      
      .hud-value {
        font-size: 14px;
      }
      
      .hud-label {
        font-size: 10px;
      }
    }

    .completion {
      position: fixed;
      inset: 50% auto auto 50%;
      transform: translate(-50%, -50%) scale(1);
      max-width: 90%;
      width: 560px;
      z-index: 1100;
      text-align: center;
      display: none;
    }

    .completion.show {
      display: block;
      animation: pop 0.25s ease;
    }

    @keyframes pop {
      from {
        transform: translate(-50%, -50%) scale(0.95);
        opacity: 0.6;
      }
      to {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }

    .score-highlight {
      color: var(--brand-aqua);
      font-weight: var(--font-weight-bold);
    }

    .celebrate {
      animation: celebrate 900ms ease-out 1;
    }

    @keyframes celebrate {
      0% { box-shadow: 0 0 0 rgba(111,211,245,0); }
      40% { box-shadow: 0 0 40px rgba(111,211,245,.8); }
      100% { box-shadow: 0 0 20px rgba(111,211,245,.2); }
    }

    .hidden {
      display: none !important;
    }

    @media (prefers-reduced-motion: reduce) {
      .celebrate { 
        animation: none; 
      }
    }

    @media (max-width: 768px) {
      .settings-panel {
        padding: var(--space-3);
        margin: var(--space-2);
      }
      
      .page {
        padding: var(--space-2);
      }
    }

    #errbar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--error-bg);
      color: var(--error);
      font-size: var(--font-size-xs);
      padding: var(--space-2) var(--space-3);
      display: none;
      z-index: 9999;
      border-top: 1px solid var(--error);
    }

    :focus-visible {
      outline: 3px solid rgba(111, 211, 245, 0.85);
      outline-offset: 2px;
    }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="inner">
      <a class="btn btn-secondary" href="/" aria-label="Go to Home">← Home</a>
      <h1>Trace & Reveal</h1>
    </div>
  </header>

  <div id="errbar"></div>

  <main class="page">
    <aside class="settings-panel panel active" data-screen="settings">
      <h2>Session Settings</h2>

      <div class="game-description">
        <p>
          <strong>How to play:</strong> Trace the dotted line to reveal the hidden shape. 
          Hit the coverage target before time runs out. Improves fine motor control, 
          hand-eye coordination, and visual-motor integration.
        </p>
        <p>
          Press <strong>Space</strong> to pause, <strong>Esc</strong> to exit session.
        </p>
      </div>

      <div class="stats-row">
        <div class="metric-settings">
          <div id="pb-settings" class="pb-value">0</div>
          <div class="pb-label">Personal Best</div>
        </div>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="dur">Session Duration (minutes)</label>
        <input class="input" id="dur" type="number" min="0.5" step="0.5" max="30" value="2" inputmode="decimal">
        <small class="setting-help">0.5–30 minutes recommended for motor training.</small>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="difficulty">Difficulty</label>
        <select class="input" id="difficulty">
          <option value="easy">Easy – lines & zigzags, 70% coverage</option>
          <option value="medium" selected>Medium – basic shapes, 85% coverage</option>
          <option value="hard">Hard – complex shapes, 95% coverage</option>
        </select>
        <div id="covHint" class="setting-help" aria-live="polite">Coverage target: 85%</div>
      </div>

      <div class="controls">
        <button id="start" class="btn btn-primary">Start</button>
        <button id="restart-session" class="btn">Restart</button>
      </div>
    </aside>

    <section class="right-col" data-screen="game">
      <div class="hud panel">
        <div class="timer-bar" id="timer-bar"></div>

        <div class="hud-group">
          <div id="doneCount" class="hud-value">0</div>
          <div class="hud-label">Completed</div>
        </div>

        <div class="hud-group">
          <div id="covNow" class="hud-value">0%</div>
          <div class="hud-label">Coverage</div>
        </div>

        <div class="hud-group">
          <div id="time" class="hud-value">00:00</div>
          <div class="hud-label">Time Left</div>
        </div>

        <div class="controls">
          <button id="pauseHud" class="btn btn-secondary">Pause</button>
          <button id="exitHud" class="btn">Exit</button>
        </div>
      </div>

      <div class="panel" id="game-container">
        <div id="stars-container"></div>

        <div class="coverage-display" id="coverage-display">
          Target: <span id="coverage-target">85%</span>
        </div>

        <p class="instructions" id="instructions">
          Trace along the dotted lines to reveal the hidden shape beneath.
        </p>

        <div class="stage-wrap">
          <canvas id="hidden" class="stage" aria-hidden="true"></canvas>
          <canvas id="mask" class="stage" aria-hidden="true"></canvas>
          <canvas id="fx" class="stage" aria-hidden="true"></canvas>
          <canvas id="ink" class="stage" aria-label="Drawing canvas"></canvas>
          <canvas id="guide" class="stage" aria-label="Trace guide"></canvas>
        </div>
      </div>
    </section>
  </main>

  <div id="completion-message" class="completion panel">
    <h2>Therapy Session Complete!</h2>
    <div id="completion-scores">
      <p>Shapes Completed: <span id="final-shapes" class="score-highlight">0</span></p>
      <p>Best Coverage: <span id="final-coverage" class="score-highlight">0%</span></p>
      <p>Motor Performance Score: <span id="final-score" class="score-highlight">0</span></p>
      <p>XP Earned: <span id="final-xp" class="score-highlight">0</span></p>
    </div>
    <div class="controls">
      <button id="restart-button" class="btn btn-primary">Start New Therapy Session</button>
      <button class="btn" id="close-complete">Close</button>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      "use strict";

      const errbar = document.getElementById("errbar");
      function showErr(e) {
        if (errbar) {
          errbar.style.display = 'block';
          errbar.textContent = (e && e.message) ? e.message : String(e);
        }
        console.error(e);
      }

      window.addEventListener("error", (e) => {
        showErr("Script error: " + (e.message || "") + (e.filename ? " – " + e.filename + ":" + e.lineno : ""));
      });

      function setHeaderH() {
        const header = document.querySelector('.site-header');
        const h = header ? header.getBoundingClientRect().height : 0;
        document.documentElement.style.setProperty('--header-h', `${h}px`);
      }
      
      const setVH = () => {
        const vh = (window.visualViewport?.height ?? window.innerHeight) * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      };
      
      setVH();
      setHeaderH();

      const startBtn = document.getElementById("start");
      const restartBtn = document.getElementById("restart-session");
      const durInput = document.getElementById("dur");
      const diffSelect = document.getElementById("difficulty");
      const covHint = document.getElementById("covHint");
      const coverageTarget = document.getElementById("coverage-target");
      const timeV = document.getElementById("time");
      const doneV = document.getElementById("doneCount");
      const covNowV = document.getElementById("covNow");
      const timerBar = document.getElementById("timer-bar");
      const pauseBtn = document.getElementById("pauseHud");
      const exitBtn = document.getElementById("exitHud");
      const completionModal = document.getElementById("completion-message");
      const finalShapesEl = document.getElementById("final-shapes");
      const finalCoverageEl = document.getElementById("final-coverage");
      const finalScoreEl = document.getElementById("final-score");
      const finalXPEl = document.getElementById("final-xp");
      const restartModalBtn = document.getElementById("restart-button");
      const completeClose = document.getElementById("close-complete");
      const pbSettingsEl = document.getElementById("pb-settings");
      const starsContainer = document.getElementById('stars-container');

      const hidden = document.getElementById("hidden");
      const mask = document.getElementById("mask");
      const fx = document.getElementById("fx");
      const ink = document.getElementById("ink");
      const guide = document.getElementById("guide");
      
      if (!hidden || !mask || !fx || !ink || !guide) {
        showErr("Canvas elements not found");
        return;
      }

      const gh = hidden.getContext("2d");
      const gm = mask.getContext("2d");
      const gx = fx.getContext("2d");
      const gi = ink.getContext("2d");
      const gg = guide.getContext("2d");

      function generateStars(container, count = 150) {
        if (!container) return;
        container.innerHTML = '';
        for (let i = 0; i < count; i++) {
          const star = document.createElement('div');
          star.style.position = 'absolute';
          star.style.width = Math.random() * 3 + 'px';
          star.style.height = star.style.width;
          star.style.backgroundColor = 'white';
          star.style.borderRadius = '50%';
          star.style.left = Math.random() * 100 + '%';
          star.style.top = Math.random() * 100 + '%';
          star.style.opacity = Math.random() * 0.8 + 0.2;
          container.appendChild(star);
        }
      }

      generateStars(starsContainer, 150);

      const PB_KEY = 'trace-reveal:best';
      const getPB = () => parseInt(localStorage.getItem(PB_KEY) || '0', 10);
      const setPB = (score) => localStorage.setItem(PB_KEY, String(score));

      function updatePersonalBest() {
        const pb = getPB();
        if (pbSettingsEl) pbSettingsEl.textContent = pb ? String(pb) : '0';
      }

      let playing = false;
      let paused = false;
      let remainingMs = 0;
      let sessionMs = 0;
      let shapesDone = 0;
      let bestCov = 0;
      let subs = [];
      let samples = [];
      let hits = 0;
      let grid = null;
      let cellSize = 16;
      const brush = 28;
      let requiredCov = 85;

      function setScreen(screenName) {
        document.querySelectorAll('[data-screen]').forEach(el => {
          el.classList.remove('active');
        });
        const screen = document.querySelector(`[data-screen="${screenName}"]`);
        if (screen) screen.classList.add('active');
      }

      const bags = { easy: [], medium: [], hard: [] };

      const fmt = (ms) => {
        const s = Math.max(0, Math.ceil(ms / 1000));
        const mm = String(Math.floor(s / 60)).padStart(2, "0");
        const ss = String(s % 60).padStart(2, "0");
        return mm + ":" + ss;
      };

      const applyDifficulty = () => {
        requiredCov = diffSelect.value === "easy" ? 70 : (diffSelect.value === "hard" ? 95 : 85);
        if (covHint) covHint.textContent = "Coverage target: " + requiredCov + "%";
        if (coverageTarget) coverageTarget.textContent = requiredCov + "%";
      };

      function resizeStage() {
        try {
          const DPR = Math.max(1, window.devicePixelRatio || 1);

          const wrap = fx.parentElement;
          const game = document.getElementById('game-container');
          const header = document.querySelector('.site-header');
          const hud = document.querySelector('.hud');

          if (!wrap || !game) return;

          const vH = (window.visualViewport?.height ?? window.innerHeight);
          const vW = window.innerWidth;

          const headerH = header ? header.getBoundingClientRect().height : 0;
          const hudH = hud && hud.offsetParent !== null ? hud.getBoundingClientRect().height : 0;

          const cs = getComputedStyle(game);
          const padTop = parseFloat(cs.paddingTop) || 0;
          const padBottom = parseFloat(cs.paddingBottom) || 0;
          const padLeft = parseFloat(cs.paddingLeft) || 0;
          const padRight = parseFloat(cs.paddingRight) || 0;

          const safeTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('env(safe-area-inset-top)')) || 0;
          const safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('env(safe-area-inset-bottom)')) || 0;

          const availH = Math.max(160, vH - headerH - hudH - padTop - padBottom - safeTop - safeBottom);
          const availW = Math.max(160, vW - padLeft - padRight);

          let cssSize;
          if (vW > 768) {
            const wrapRect = wrap.getBoundingClientRect();
            cssSize = Math.floor(Math.max(160, Math.min(wrapRect.width, wrapRect.height)));
          } else {
            cssSize = Math.floor(Math.max(160, Math.min(availW, availH)));
          }

          [hidden, mask, fx, ink, guide].forEach((c) => {
            c.width = Math.max(1, Math.floor(cssSize * DPR));
            c.height = Math.max(1, Math.floor(cssSize * DPR));
            c.style.width = cssSize + 'px';
            c.style.height = cssSize + 'px';
          });

          [gh, gm, gx, gi, gg].forEach(ctx => ctx.setTransform(DPR, 0, 0, DPR, 0, 0));

          gi.lineCap = "round";
          gi.lineJoin = "round";
          gi.strokeStyle = "rgba(111,211,245,0.95)";
          gi.lineWidth = Math.max(2, Math.round(brush * 0.35));

          cellSize = Math.max(8, Math.round(brush * 0.8));

          if (playing) newShape(); else drawIdleGuide();
        } catch (e) {
          showErr(e);
        }
      }

      const drawIdleGuide = () => {
        gg.clearRect(0, 0, guide.width, guide.height);
        gg.save();
        gg.fillStyle = "rgba(255,255,255,.06)";
        gg.fillRect(0, 0, guide.width, guide.height);
        gg.fillStyle = "rgba(255,255,255,.9)";
        gg.font = "600 16px system-ui, sans-serif";
        gg.textAlign = "center";
        gg.fillText("Set duration, pick difficulty, then Start", 
          guide.width / 2, guide.height / 2);
        gg.restore();
      };

      const make = (pts, closed = true, strokePx = 0) => ({ points: pts, closed, strokePx });
      const getCanvasSize = () => Math.min(hidden.width, hidden.height) / devicePixelRatio;

      const lineH = () => {
        const size = getCanvasSize();
        const y = size * 0.5, x1 = size * 0.15, x2 = size * 0.85;
        return [make([{ x: x1, y }, { x: x2, y }], false, Math.round(size * 0.08))];
      };
      const lineV = () => {
        const size = getCanvasSize();
        const x = size * 0.5, y1 = size * 0.18, y2 = size * 0.82;
        return [make([{ x, y: y1 }, { x, y: y2 }], false, Math.round(size * 0.08))];
      };
      const zigzag = () => {
        const size = getCanvasSize();
        const pts = [];
        const l = size * 0.18, r = size * 0.82, t = size * 0.22, b = size * 0.78, rows = 6;
        for (let i = 0; i <= rows; i++) {
          const y = t + (b - t) * (i / rows);
          const x = (i % 2 === 0) ? l : r;
          pts.push({ x, y });
        }
        return [make(pts, false, Math.round(size * 0.07))];
      };
      const sine = () => {
        const size = getCanvasSize();
        const pts = [];
        const l = size * 0.12, r = size * 0.88, mid = size * 0.5, amp = size * 0.22, cyc = 1.5, steps = 180;
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = l + (r - l) * t;
          const y = mid + Math.sin(t * Math.PI * 2 * cyc) * amp;
          pts.push({ x, y });
        }
        return [make(pts, false, Math.round(size * 0.06))];
      };
      const circle = () => {
        const size = getCanvasSize();
        const cx = size / 2, cy = size / 2, r = size * 0.32, pts = [];
        for (let i = 0; i <= 180; i++) {
          const a = (i / 180) * Math.PI * 2;
          pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
        }
        return [make(pts, true, 0)];
      };
      const square = () => {
        const size = getCanvasSize();
        const s = size * 0.64, x = (size - s) / 2, y = (size - s) / 2;
        const pts = [{ x, y }, { x: x + s, y }, { x: x + s, y: y + s }, { x, y: y + s }, { x, y }];
        return [make(pts, true, 0)];
      };
      const triangle = () => {
        const size = getCanvasSize();
        const s = size * 0.68, cx = size / 2, cy = size / 2;
        const pts = [
          { x: cx, y: cy - s / 2 },
          { x: cx - s / 2, y: cy + s / 2 },
          { x: cx + s / 2, y: cy + s / 2 },
          { x: cx, y: cy - s / 2 }
        ];
        return [make(pts, true, 0)];
      };
      const star = () => {
        const size = getCanvasSize();
        const cx = size / 2, cy = size / 2, R = size * 0.34, r = R * 0.5, pts = [];
        for (let i = 0; i < 10; i++) {
          const a = (i / 10) * Math.PI * 2 - Math.PI / 2;
          const rad = (i % 2 === 0) ? R : r;
          pts.push({ x: cx + Math.cos(a) * rad, y: cy + Math.sin(a) * rad });
        }
        pts.push(pts[0]);
        return [make(pts, true, 0)];
      };
      const heart = () => {
        const size = getCanvasSize();
        const cx = size / 2, cy = size / 2;
        const k = size * 0.02;
        const steps = 220, pts = [];
        for (let i = 0; i <= steps; i++) {
          const t = (i / steps) * Math.PI * 2;
          const x = cx + k * 16 * Math.pow(Math.sin(t), 3);
          const y = cy - k * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
          pts.push({ x, y });
        }
        return [make(pts, true, 0)];
      };

      const POOLS = {
        easy: [
          lineH, lineV, zigzag, sine,
          () => {
            const size = getCanvasSize();
            const m = size * 0.15;
            return [make([{ x: m, y: m }, { x: size - m, y: size - m }], false, Math.round(size * 0.08))];
          },
          () => {
            const size = getCanvasSize();
            const m = size * 0.15;
            return [make([{ x: size - m, y: m }, { x: m, y: size - m }], false, Math.round(size * 0.08))];
          },
          () => {
            const size = getCanvasSize();
            const pts = [];
            const l = size * 0.12, r = size * 0.88, mid = size * 0.5, amp = size * 0.15, cyc = 2, steps = 200;
            for (let i = 0; i <= steps; i++) {
              const t = i / steps;
              const x = l + (r - l) * t;
              const y = mid + Math.sin(t * Math.PI * 2 * cyc) * amp;
              pts.push({ x, y });
            }
            return [make(pts, false, Math.round(size * 0.06))];
          },
          () => {
            const size = getCanvasSize();
            const cx = size / 2, cy = size / 2, pts = [];
            const steps = 150;
            for (let i = 0; i <= steps; i++) {
              const t = i / steps;
              const a = t * Math.PI * 4;
              const r = size * 0.05 + t * size * 0.25;
              pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
            }
            return [make(pts, false, Math.round(size * 0.06))];
          }
        ],
        medium: [
          circle, square, triangle, star, heart,
          () => {
            const size = getCanvasSize();
            const cx = size / 2, cy = size / 2, r = size * 0.32, pts = [];
            for (let i = 0; i <= 5; i++) {
              const a = (i / 5) * Math.PI * 2 - Math.PI / 2;
              pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
            }
            return [make(pts, true, 0)];
          },
          () => {
            const size = getCanvasSize();
            const cx = size / 2, cy = size / 2, r = size * 0.32, pts = [];
            for (let i = 0; i <= 6; i++) {
              const a = (i / 6) * Math.PI * 2;
              pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
            }
            return [make(pts, true, 0)];
          },
          () => {
            const size = getCanvasSize();
            const cx = size / 2, cy = size / 2, w = size * 0.3, h = size * 0.4;
            const pts = [
              { x: cx, y: cy - h },
              { x: cx + w, y: cy },
              { x: cx, y: cy + h },
              { x: cx - w, y: cy },
              { x: cx, y: cy - h }
            ];
            return [make(pts, true, 0)];
          },
          () => {
            const size = getCanvasSize();
            const cx = size / 2, cy = size / 2, r = size * 0.28, pts = [];
            for (let i = 0; i <= 180; i++) {
              const a = (i / 180) * Math.PI * 2 - Math.PI / 4;
              const rad = i < 90 ? r : r * 0.7;
              pts.push({ x: cx + Math.cos(a) * rad, y: cy + Math.sin(a) * rad });
            }
            return [make(pts, true, 0)];
          }
        ],
        hard: [
          heart, star,
          () => {
            const size = getCanvasSize();
            const cx = size / 2, cy = size / 2, R = size * 0.34, r = R * 0.6, pts = [];
            for (let i = 0; i < 16; i++) {
              const a = (i / 16) * Math.PI * 2 - Math.PI / 2;
              const rad = (i % 2 === 0) ? R : r;
              pts.push({ x: cx + Math.cos(a) * rad, y: cy + Math.sin(a) * rad });
            }
            pts.push(pts[0]);
            return [make(pts, true, 0)];
          },
          () => {
            const size = getCanvasSize();
            const cx = size / 2, cy = size / 2, r = size * 0.28, pts = [];
            const petals = 6;
            for (let i = 0; i <= 360; i += 2) {
              const a = (i / 180) * Math.PI;
              const rad = r * (1 + 0.5 * Math.sin(petals * a));
              pts.push({ x: cx + Math.cos(a) * rad, y: cy + Math.sin(a) * rad });
            }
            return [make(pts, true, 0)];
          },
          () => {
            const size = getCanvasSize();
            const cx = size / 2, cy = size / 2, w = size * 0.25, pts = [];
            for (let i = 0; i <= 360; i += 2) {
              const t = (i / 180) * Math.PI;
              const scale = 2 / (3 - Math.cos(2 * t));
              const x = cx + w * scale * Math.cos(t);
              const y = cy + w * 0.5 * scale * Math.sin(2 * t);
              pts.push({ x, y });
            }
            return [make(pts, true, 0)];
          },
          () => {
            const size = getCanvasSize();
            const cx = size / 2, cy = size / 2, pts = [];
            const steps = 200;
            for (let i = 0; i <= steps; i++) {
              const t = i / steps;
              const a = t * Math.PI * 6;
              const r = size * 0.08 + t * size * 0.3;
              pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
            }
            return [make(pts, false, Math.round(size * 0.05))];
          },
          () => {
            const size = getCanvasSize();
            const cx = size / 2, cy = size / 2, r = size * 0.2, pts = [];
            for (let i = 0; i <= 360; i += 2) {
              const t = (i / 180) * Math.PI;
              const x = cx + r * Math.cos(t) * (2 + Math.cos(3 * t));
              const y = cy + r * Math.sin(t) * (2 + Math.cos(3 * t));
              pts.push({ x, y });
            }
            return [make(pts, true, 0)];
          },
          circle, square, triangle
        ]
      };

      const drawGuide = () => {
        gg.clearRect(0, 0, guide.width, guide.height);
        gg.save();
        gg.lineCap = "round";
        gg.lineJoin = "round";
        for (const sp of subs) {
          const pts = sp.points;
          if (!pts || pts.length < 2) continue;
          gg.strokeStyle = "rgba(0,0,0,.92)";
          gg.lineWidth = 8;
          gg.setLineDash([]);
          gg.beginPath();
          gg.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) gg.lineTo(pts[i].x, pts[i].y);
          if (sp.closed) gg.closePath();
          gg.stroke();

          gg.strokeStyle = "rgba(255,255,255,.98)";
          gg.lineWidth = 4;
          gg.setLineDash([14, 10]);
          gg.beginPath();
          gg.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) gg.lineTo(pts[i].x, pts[i].y);
          if (sp.closed) gg.closePath();
          gg.stroke();
        }
        gg.restore();
      };

      const drawHidden = () => {
        const size = getCanvasSize();
        gh.clearRect(0, 0, hidden.width, hidden.height);
        const hue = Math.floor(Math.random() * 360);
        const g0 = "hsl(" + hue + ",85%,62%)";
        const g1 = "hsl(" + ((hue + 40) % 360) + ",85%,46%)";
        const grd = gh.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
        grd.addColorStop(0, g0);
        grd.addColorStop(1, g1);

        for (const sp of subs) {
          const pts = sp.points;
          if (!pts || pts.length < 2) continue;
          gh.beginPath();
          gh.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) gh.lineTo(pts[i].x, pts[i].y);
          if (sp.closed) gh.closePath();
          if (sp.closed) {
            gh.fillStyle = grd;
            gh.fill();
          } else {
            gh.lineCap = "round";
            gh.lineJoin = "round";
            gh.lineWidth = Math.max(4, sp.strokePx || 0);
            gh.strokeStyle = grd;
            gh.stroke();
          }
        }

        gm.clearRect(0, 0, mask.width, mask.height);
        gi.clearRect(0, 0, ink.width, ink.height);
      };

      const buildCoverage = () => {
        samples = [];
        hits = 0;
        grid = new Map();
        const addSample = (x, y) => {
          const idx = samples.length;
          samples.push({ x, y, hit: false });
          const ci = Math.floor(x / cellSize), cj = Math.floor(y / cellSize);
          const key = ci + "|" + cj;
          const arr = grid.get(key);
          if (arr) arr.push(idx); else grid.set(key, [idx]);
        };
        const step = 4;
        for (const sp of subs) {
          const pts = sp.points;
          for (let i = 0; i < pts.length - 1; i++) {
            const p1 = pts[i], p2 = pts[i + 1];
            const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const steps = Math.max(1, Math.ceil(dist / step));
            for (let j = 0; j <= steps; j++) {
              const t = j / steps;
              addSample(Math.round(p1.x + (p2.x - p1.x) * t), Math.round(p1.y + (p2.y - p1.y) * t));
            }
          }
        }
      };

      const updateComposite = () => {
        const tmp = document.createElement("canvas");
        tmp.width = hidden.width;
        tmp.height = hidden.height;
        const gt = tmp.getContext("2d");
        gt.drawImage(hidden, 0, 0);
        gt.globalCompositeOperation = "destination-in";
        gt.drawImage(mask, 0, 0);

        gx.clearRect(0, 0, fx.width, fx.height);
        gx.setTransform(1, 0, 0, 1, 0, 0);
        gx.drawImage(tmp, 0, 0);
      };

      const pos = (e) => {
        const r = guide.getBoundingClientRect();
        const cx = (e.clientX ?? e.pageX);
        const cy = (e.clientY ?? e.pageY);
        return { x: cx - r.left, y: cy - r.top };
      };

      let isDrawing = false;
      let isCompleting = false;
      let lastP = null;

      const markCoverageNear = (p) => {
        if (!samples.length) return;
        const r = brush * 0.6;
        const r2 = r * r;
        const ci = Math.floor(p.x / cellSize), cj = Math.floor(p.y / cellSize);
        for (let di = -1; di <= 1; di++) {
          for (let dj = -1; dj <= 1; dj++) {
            const key = (ci + di) + "|" + (cj + dj);
            const arr = grid.get(key);
            if (!arr) continue;
            for (const idx of arr) {
              const s = samples[idx];
              if (!s.hit) {
                const dx = s.x - p.x, dy = s.y - p.y;
                if (dx * dx + dy * dy <= r2) {
                  s.hit = true;
                  hits++;
                }
              }
            }
          }
        }
        const cov = Math.min(100, Math.round((hits / Math.max(1, samples.length)) * 100));
        bestCov = Math.max(bestCov, cov);
        covNowV.textContent = cov + "%";
        if (cov >= requiredCov && !isCompleting) complete();
      };

      const drawAt = (p) => {
        gm.globalCompositeOperation = "source-over";
        gm.lineCap = "round";
        gm.lineJoin = "round";
        gm.strokeStyle = "white";
        gm.lineWidth = Math.max(gi.lineWidth, brush * 0.45);

        if (lastP) {
          gm.beginPath();
          gm.moveTo(lastP.x, lastP.y);
          gm.lineTo(p.x, p.y);
          gm.stroke();
        } else {
          gm.beginPath();
          gm.arc(p.x, p.y, brush / 2, 0, Math.PI * 2);
          gm.fillStyle = "white";
          gm.fill();
        }

        if (lastP) {
          gi.beginPath();
          gi.moveTo(lastP.x, lastP.y);
          gi.lineTo(p.x, p.y);
          gi.stroke();
        } else {
          gi.beginPath();
          gi.arc(p.x, p.y, Math.max(1, brush * 0.25), 0, Math.PI * 2);
          gi.fillStyle = "rgba(111,211,245,0.95)";
          gi.fill();
        }

        lastP = p;

        updateComposite();
        markCoverageNear(p);
      };

      const handlePointerMove = (e) => {
        if (!isDrawing || !playing || isCompleting) return;
        const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
        for (const ev of events) drawAt(pos(ev));
      };

      fx.addEventListener("pointerdown", (e) => {
        if (!playing || isCompleting) return;
        isDrawing = true;
        drawAt(pos(e));
      });
      fx.addEventListener("pointermove", handlePointerMove);
      addEventListener("pointerup", () => {
        isDrawing = false;
        lastP = null;
      });

      fx.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (!playing || isCompleting) return;
        isDrawing = true;
        drawAt(pos(e.touches[0]));
      }, { passive: false });
      fx.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (!isDrawing || !playing || isCompleting) return;
        drawAt(pos(e.touches[0]));
      }, { passive: false });
      fx.addEventListener("touchend", (e) => {
        e.preventDefault();
        isDrawing = false;
        lastP = null;
      }, { passive: false });

      const bagPick = (level) => {
        if (!bags[level] || bags[level].length === 0) bags[level] = [...POOLS[level]];
        const i = Math.floor(Math.random() * bags[level].length);
        const fn = bags[level].splice(i, 1)[0];
        return fn;
      };

      const newShape = () => {
        const level = diffSelect.value;
        const gen = bagPick(level);
        subs = gen();
        drawGuide();
        drawHidden();
        buildCoverage();
        updateComposite();
        isCompleting = false;
      };

      const complete = () => {
        isCompleting = true;
        shapesDone += 1;
        doneV.textContent = String(shapesDone);
        gx.save();
        gx.fillStyle = "rgba(255,255,255,.16)";
        gx.fillRect(0, 0, fx.width, fx.height);
        gx.restore();

        if (fx.parentElement) fx.parentElement.classList.add('celebrate');

        setTimeout(() => {
          gx.clearRect(0, 0, fx.width, fx.height);
          if (fx.parentElement) fx.parentElement.classList.remove('celebrate');
          if (playing) {
            newShape();
          }
        }, 900);
      };

      function updateHUD() {
        try {
          if (timeV) timeV.textContent = fmt(remainingMs);
          if (doneV) doneV.textContent = String(shapesDone);
          if (covNowV) covNowV.textContent = Math.round(bestCov) + '%';
          if (timerBar && sessionMs > 0) {
            const pct = Math.max(0, Math.min(1, remainingMs / sessionMs));
            timerBar.style.width = (pct * 100).toFixed(2) + '%';
          }
        } catch (e) { showErr(e); }
      }

      let rafId = 0;
      function startTimerLoop() {
        cancelAnimationFrame(rafId);
        let last = performance.now();
        const tick = (t) => {
          if (!playing) return;
          const dt = t - last; 
          last = t;
          if (!paused) {
            remainingMs = Math.max(0, remainingMs - dt);
            updateHUD();
            if (remainingMs <= 0) {
              endSession();
              return;
            }
          }
          rafId = requestAnimationFrame(tick);
        };
        rafId = requestAnimationFrame(tick);
      }

      function beginSession() {
        try {
          applyDifficulty();
          const mins = parseFloat(durInput.value || '2');
          sessionMs = (isFinite(mins) && mins > 0 ? mins : 2) * 60 * 1000;
          remainingMs = sessionMs;
          shapesDone = 0;
          bestCov = 0;
          paused = false;
          playing = true;

          document.body.classList.add('playing');
          setScreen('game');
          
          requestAnimationFrame(() => {
            resizeStage();
            updateHUD();
            newShape();
            startTimerLoop();
          });
        } catch (e) { 
          showErr(e); 
        }
      }

      function endSession() {
        playing = false;
        document.body.classList.remove('playing');
        cancelAnimationFrame(rafId);

        const score = shapesDone * 100 + Math.round(bestCov);

        if (finalShapesEl) finalShapesEl.textContent = String(shapesDone);
        if (finalCoverageEl) finalCoverageEl.textContent = Math.round(bestCov) + '%';
        if (finalScoreEl) finalScoreEl.textContent = String(score);
        if (finalXPEl) finalXPEl.textContent = String(Math.max(10, Math.round(score * 0.5)));

        const previousPB = getPB();
        if (score > previousPB) {
          setPB(score);
          updatePersonalBest();
        }

        if (completionModal) completionModal.classList.add('show');
        setScreen('settings');
      }

      const isPlaying = () => (typeof playing !== 'undefined' && playing);
      
      let rAF = 0;
      function scheduleResize() {
        cancelAnimationFrame(rAF);
        rAF = requestAnimationFrame(() => {
          requestAnimationFrame(() => { 
            setVH();
            setHeaderH();
            if (isPlaying()) resizeStage(); 
          });
        });
      }

      const gc = document.getElementById('game-container');
      if (gc && 'ResizeObserver' in window) {
        const ro = new ResizeObserver(() => requestAnimationFrame(() => {
          if (playing) resizeStage();
        }));
        ro.observe(gc);
      }

      addEventListener('resize', scheduleResize);
      addEventListener('orientationchange', scheduleResize);
      if (window.visualViewport) {
        visualViewport.addEventListener('resize', scheduleResize);
      }

      if (startBtn) startBtn.addEventListener('click', beginSession);

      if (pauseBtn) pauseBtn.addEventListener('click', () => {
        paused = !paused;
        pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      });

      if (exitBtn) exitBtn.addEventListener('click', () => {
        playing = false;
        paused = false;
        document.body.classList.remove('playing');
        setScreen('settings');
        cancelAnimationFrame(rafId);
      });

      if (restartBtn) restartBtn.addEventListener('click', () => {
        document.body.classList.remove('playing');
        setScreen('settings');
        if (completionModal) completionModal.classList.remove('show');
      });

      if (restartModalBtn) restartModalBtn.addEventListener('click', () => {
        if (completionModal) completionModal.classList.remove('show');
        beginSession();
      });

      if (completeClose) completeClose.addEventListener('click', () => {
        if (completionModal) completionModal.classList.remove('show');
        document.body.classList.remove('playing');
        setScreen('settings');
      });

      addEventListener("keydown", (e) => {
        if (!playing) return;
        if (e.key === " ") {
          e.preventDefault();
          if (pauseBtn) pauseBtn.click();
        }
        if (e.key === "Escape") {
          e.preventDefault();
          if (exitBtn) exitBtn.click();
        }
      });

      if (diffSelect) {
        diffSelect.addEventListener("change", () => {
          applyDifficulty();
          try {
            localStorage.setItem('traceRevealDifficulty', diffSelect.value);
          } catch {}
        });
      }

      if (durInput) {
        durInput.addEventListener("input", () => {
          try {
            localStorage.setItem('traceRevealDuration', durInput.value);
          } catch {}
        });
      }

      function loadSettings() {
        try {
          if (diffSelect) diffSelect.value = localStorage.getItem('traceRevealDifficulty') || 'medium';
          if (durInput) durInput.value = localStorage.getItem('traceRevealDuration') || '2';
        } catch {}
        applyDifficulty();
        updatePersonalBest();
      }

      loadSettings();
      drawIdleGuide();
      setScreen("settings");
    });
  </script>
</body>
</html>