<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RVKCCWBFKE"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-RVKCCWBFKE');
  </script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sequence Builder | Fine Point Rehab</title>

  <!-- SEO -->
  <meta name="description" content="Interactive sequence building exercise for cognitive rehabilitation. Improve executive function, planning skills, and sequential processing."/>
  <meta name="theme-color" content="#121d33"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="default"/>
  <link rel="canonical" href="https://finepointrehab.com/exercises/sequence-builder-exercise.html"/>

  <!-- Shared tokens + components -->
  <link rel="stylesheet" href="/css/tokens.css"/>
  <link rel="stylesheet" href="/css/components.css"/>

  <style>
    /* Base & background */
    * { box-sizing: border-box; }
    @media (prefers-reduced-motion: reduce) {
      * { animation-duration: .01ms !important; animation-iteration-count: 1 !important; transition: none !important; }
    }
    :root {
      --bg-grad: radial-gradient(1200px 800px at 50% -20%, rgba(111,211,245,.12), transparent 60%), linear-gradient(#0a1326, #121d33);
      --card-bg: rgba(8,15,35,.7);
      --card-border: 1px solid rgba(255,255,255,.08);
      --accent: rgba(111,211,245,1);
      --accent-weak: rgba(111,211,245,.6);
      --ok: rgba(46,204,113,1);
      --bad: rgba(231,76,60,1);
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color: #fff;
      background: var(--bg-grad);
      min-height: 100vh;
      overflow: hidden;
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
    }

    /* Sticky header */
    header.app-header {
      position: sticky; top: 0; z-index: 1000;
      backdrop-filter: blur(8px);
      background: linear-gradient(180deg, rgba(10,19,38,.9), rgba(10,19,38,.6));
      border-bottom: 1px solid rgba(255,255,255,.08);
      display: flex; align-items: center; gap: var(--space-3, 12px);
      padding: var(--space-3, 12px) var(--space-5, 20px);
    }
    header .home-link {
      text-decoration: none;
      color: #0b1a2f;
      background: var(--accent);
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 700;
      min-height: 44px;
      display: inline-flex; align-items: center; gap: 6px;
    }
    header h1 {
      font-size: clamp(1rem, 2vw + 1rem, 1.6rem);
      margin: 0;
      letter-spacing: .3px;
    }
    header .spacer { flex: 1; }

    /* Layout */
    .layout {
      display: grid;
      grid-template-columns: minmax(260px, 360px) 1fr;
      grid-template-rows: 1fr;
      gap: var(--space-5, 20px);
      padding: var(--space-5, 20px);
      height: calc(100vh - 68px);
    }
    .panel {
      background: var(--card-bg);
      border: var(--card-border);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    /* Left: Settings panel */
    #settings-panel {
      height: 100%;
      overflow: auto;
      padding: 20px;
    }
    #settings-panel h2 {
      margin: 0 0 10px;
      text-align: center;
    }
    .game-description {
      background: rgba(111,211,245,.08);
      border: 1px solid rgba(111,211,245,.25);
      border-radius: 12px;
      padding: 12px;
      font-size: 14px;
      margin-bottom: 16px;
    }
    .settings-group { margin-bottom: 14px; }
    .settings-label { display:block; margin-bottom: 6px; font-weight: 700; }
    .setting-description { font-size: 13px; opacity: .9; margin-bottom: 6px; }
    .option-explanations { margin: 6px 0 0 0; padding-left: 18px; font-size: 12px; opacity: .85; }
    select, input {
      width: 100%; min-height: 44px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,10,30,.8); color: #fff; font-size: 16px; padding: 10px 12px;
    }
    select:focus, input:focus {
      outline: none; border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(111,211,245,.25);
    }

    /* Right: Game + HUD */
    .right-wrap { position: relative; display: flex; flex-direction: column; gap: 12px; }

    .hud.panel {
      padding: 10px 12px;
      display: grid;
      grid-template-columns: 1fr auto auto auto;
      align-items: center;
      gap: 10px;
    }
    .timer-bar {
      grid-column: 1 / -1;
      height: 8px; background: rgba(255,255,255,.08);
      border-radius: 6px; overflow: hidden; position: relative;
    }
    #timer-fill {
      position: absolute; inset: 0 100% 0 0; background: var(--accent); transition: width .1s linear;
    }
    .hud-metric {
      display: inline-flex; align-items: baseline; gap: 8px; padding: 6px 10px;
      background: rgba(255,255,255,.05); border-radius: 10px;
    }
    .hud-metric .value { font-weight: 800; color: var(--accent); }
    .hud-metric .label { font-size: 12px; opacity: .9; }

    /* Game area cards */
    #game-surface { flex: 1; display: grid; grid-template-rows: auto 1fr; gap: 12px; }
    .cards { display: grid; grid-template-columns: 1fr; gap: 12px; }
    #sequence-area.panel { padding: 14px; }
    .card {
      background: rgba(0,12,28,.6);
      border: 1px solid rgba(255,255,255,.07);
      border-radius: 14px; padding: 14px;
    }
    .section-label { font-size: 12px; text-transform: uppercase; letter-spacing: .8px; color: var(--accent-weak); font-weight: 700; margin-bottom: 8px; }

    #model-display, #user-sequence {
      display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 10px;
      padding: 12px; min-height: 84px;
      border: 1px dashed rgba(111,211,245,.5); border-radius: 10px; background: rgba(8,15,35,.45);
    }
    #model-display.hidden { opacity: 0.1; filter: blur(4px); }

    /* Pieces */
    .sequence-piece {
      width: 60px; height: 60px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(111,211,245,.9));
      border-radius: 10px;
      display: flex; align-items: center; justify-content: center;
      font-size: 28px; cursor: pointer;
      box-shadow: 0 0 15px rgba(111,211,245,.35);
      transition: transform .2s, box-shadow .2s; position: relative;
    }
    .sequence-piece:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(111,211,245,.6); }
    .sequence-piece:active { transform: scale(.98); }
    .sequence-piece:focus { outline: 2px solid var(--accent); outline-offset: 2px; }
    .sequence-piece.selected { transform: scale(1.1); box-shadow: 0 0 30px rgba(111,211,245,.9); animation: selectedPulse 1s ease-in-out infinite; }
    @keyframes selectedPulse { 0%,100%{box-shadow:0 0 30px rgba(111,211,245,.9);} 50%{box-shadow:0 0 40px rgba(111,211,245,1);} }
    .sequence-piece.model { background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.85), rgba(111,211,245,.7)); cursor: default; transform: none; box-shadow: 0 0 10px rgba(111,211,245,.25); }
    .sequence-piece.correct { background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(46,204,113,.9)); box-shadow: 0 0 15px rgba(46,204,113,.6); animation: correctPulse .5s ease-out; }
    @keyframes correctPulse { 0%{transform:scale(1);} 50%{transform:scale(1.15);} 100%{transform:scale(1);} }
    .sequence-piece.incorrect { background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(231,76,60,.9)); box-shadow: 0 0 15px rgba(231,76,60,.6); animation: shake .4s ease; }
    @keyframes shake { 0%{transform:translateX(0);}25%{transform:translateX(-5px);}50%{transform:translateX(5px);}75%{transform:translateX(-5px);}100%{transform:translateX(0);} }
    .sequence-piece.placeholder { background: rgba(255,255,255,.1); box-shadow: none; border: 2px dashed rgba(111,211,245,.5); }
    .sequence-piece.placeholder.next { border-color: rgba(111,211,245,.8); background: rgba(111,211,245,.12); animation: nextPulse 2s ease-in-out infinite; }
    @keyframes nextPulse { 0%,100%{box-shadow:0 0 0 0 rgba(111,211,245,.4);} 50%{box-shadow:0 0 15px 3px rgba(111,211,245,.25);} }

    /* Pieces palette */
    #pieces-container {
      display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;
      padding: 10px; background: rgba(8,15,35,.45); border-radius: 10px;
    }

    /* Status & controls */
    .status-indicator {
      display: flex; justify-content: space-between; align-items: center;
      background: rgba(255,255,255,.05); border-radius: 10px; padding: 8px 12px; margin-top: 10px;
    }
    .current-step { color: var(--accent); font-weight: 800; }
    .controls {
      display: grid; grid-template-columns: repeat(3, minmax(120px, 1fr));
      gap: 10px; margin-top: 12px;
    }
    .btn { min-height: 44px; }
    .btn-primary { background: var(--accent); color: #0b1a2f; }
    .btn-danger { background: var(--bad); }
    .btn-secondary { background: rgba(255,255,255,.15); color: #fff; }
    .btn:disabled { opacity: .55; cursor: not-allowed; }

    /* Completion modal */
    #completion-message {
      position: fixed; inset: 0; display: none; place-items: center; z-index: 1200;
      background: rgba(0,0,0,.55);
    }
    #completion-card {
      background: var(--card-bg); border: var(--card-border);
      padding: 22px; border-radius: 16px; width: min(560px, 92vw); text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
    }
    #completion-card h2 { margin: 0 0 8px; }
    #completion-scores { margin: 14px 0; font-size: 18px; }
    .score-highlight { color: var(--accent); font-weight: 800; }
    .xp-line { margin-top: 8px; opacity: .95; }

    /* Stars */
    #stars-container { position: fixed; inset: 0; z-index: 0; overflow: hidden; pointer-events: none; }
    .star { position: absolute; background-color: white; width: 2px; height: 2px; border-radius: 50%; opacity: .4; }

    /* Helpers */
    .hidden { display: none !important; }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; height: auto; min-height: calc(100vh - 68px); }
      #settings-panel { max-height: none; }
    }
  </style>
</head>
<body>
  <!-- Header & Navigation -->
  <header class="app-header" role="banner">
    <a class="home-link" href="/" aria-label="Go home">← Home</a>
    <h1>Sequence Builder</h1>
    <div class="spacer"></div>
  </header>

  <div id="stars-container" aria-hidden="true"></div>

  <!-- Shared Layout -->
  <main class="layout" role="main">
    <!-- Left panel: Settings -->
    <section id="settings-panel" class="panel" aria-labelledby="settings-title">
      <h2 id="settings-title">Sequence Builder Settings</h2>

      <div class="game-description">
        <strong>How to play:</strong> Look at the target pattern, select a piece from below, then place it into the empty slots to recreate the pattern. Aim for accuracy and speed.
      </div>

      <div class="settings-group">
        <label class="settings-label" for="sequence-type">Sequence Type</label>
        <div class="setting-description">Choose the kind of sequences to practice.</div>
        <select id="sequence-type">
          <option value="pattern" selected>Pattern (Symbols)</option>
          <option value="assembly">Assembly (Building Blocks)</option>
          <option value="numerical">Numerical (Math Sequence)</option>
          <option value="spatial">Spatial (Positioning)</option>
        </select>
        <ul class="option-explanations">
          <li><strong>Pattern:</strong> Shapes & symbols in repeating patterns</li>
          <li><strong>Assembly:</strong> Tools/components in logical order</li>
          <li><strong>Numerical:</strong> Numbers & math symbols</li>
          <li><strong>Spatial:</strong> Directional arrows and movement</li>
        </ul>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="difficulty-select">Difficulty</label>
        <div class="setting-description">Controls sequence length & distractors.</div>
        <select id="difficulty-select">
          <option value="easy">Easy (3–4 Steps)</option>
          <option value="medium" selected>Medium (5–6 Steps)</option>
          <option value="hard">Hard (7–8 Steps)</option>
        </select>
        <ul class="option-explanations">
          <li><strong>Easy:</strong> 3–4 steps, 2 distractors</li>
          <li><strong>Medium:</strong> 5–6 steps, 4 distractors</li>
          <li><strong>Hard:</strong> 7–8 steps, 6 distractors</li>
        </ul>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="show-completed">Model Visibility</label>
        <div class="setting-description">How long the target pattern remains visible.</div>
        <select id="show-completed">
          <option value="always">Always Visible</option>
          <option value="initially" selected>Initially Visible, Then Hidden</option>
          <option value="never">Never Visible (Memory Challenge)</option>
        </select>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="session-duration">Session Duration (minutes)</label>
        <input type="number" id="session-duration" min="1" max="10" value="3" inputmode="numeric"/>
      </div>

      <div class="settings-group">
        <button type="button" id="start-session" class="btn btn-primary" aria-label="Start session">Start</button>
      </div>
    </section>

    <!-- Right panel: HUD + Game -->
    <section class="right-wrap" aria-live="polite">
      <!-- HUD Row -->
      <div class="hud panel" role="region" aria-label="Session status">
        <div class="timer-bar" aria-hidden="true"><div id="timer-fill" style="width:0%"></div></div>

        <div class="hud-metric" aria-label="Score">
          <span class="label">Score</span><span id="score" class="value">0</span>
        </div>
        <div class="hud-metric" aria-label="Correct sequences">
          <span class="label">Correct</span><span id="correct-count" class="value">0</span>
        </div>
        <div class="hud-metric" aria-label="Personal best">
          <span class="label">PB</span><span id="personal-best" class="value">0</span>
        </div>
        <div class="hud-metric" aria-label="Difficulty">
          <span class="label">Diff</span><span id="hud-difficulty" class="value">Medium</span>
        </div>
      </div>

      <!-- Game Surface -->
      <div id="game-surface">
        <div id="sequence-area" class="panel">
          <div class="cards">
            <div class="card">
              <div class="section-label">Target Pattern</div>
              <div id="model-display"></div>
              <div class="section-label" id="memory-timer" style="margin-top:8px; display:none;"></div>
            </div>

            <div class="card">
              <div class="section-label">Your Sequence</div>
              <div id="user-sequence"></div>

              <div class="status-indicator" aria-live="polite">
                <span id="status-text">Select a piece below to place</span>
                <span class="current-step">Step: <span id="current-step-display">1</span>/<span id="total-steps">5</span></span>
              </div>

              <div id="pieces-container" class="card" style="margin-top:10px;"></div>

              <div class="controls">
                <button type="button" class="btn btn-primary" id="check-button" disabled>Check</button>
                <button type="button" class="btn btn-secondary" id="pause-button">Pause</button>
                <button type="button" class="btn btn-danger" id="reset-button">Clear</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Completion Modal -->
  <div id="completion-message" role="dialog" aria-modal="true" aria-labelledby="completion-title">
    <div id="completion-card" class="panel">
      <h2 id="completion-title">Session Complete!</h2>
      <div id="completion-scores">
        <p>Final Score: <span id="final-score" class="score-highlight">0</span></p>
        <p>Sequences Completed: <span id="final-sequences" class="score-highlight">0</span></p>
        <p>Steps Accuracy: <span id="final-accuracy" class="score-highlight">0%</span></p>
        <p class="xp-line">You earned <strong><span id="xp-earned">0</span> XP</strong> 🎉</p>
        <p id="pb-note" class="hidden">New Personal Best! 🏆</p>
      </div>
      <div style="display:flex; gap:10px; justify-content:center; margin-top:10px;">
        <button type="button" id="restart-button" class="btn btn-primary">Start New Session</button>
        <a href="/" class="btn">← Home</a>
      </div>
    </div>
  </div>

  <!-- Utils & enhancement -->
  <script type="module" src="/js/utils.js"></script>
  <script type="module" src="/js/session-enhancement.js"></script>

  <script type="module">
    import { storage, starfield, theme, viewport, audio, initUtils, toast } from '/js/utils.js';
    import { sessionEnhancement } from '/js/session-enhancement.js';
    import { checkAndUnlockAchievements, markExerciseTried, showAchievementNotification } from '/js/achievements.js';
    import { recordSession } from '/js/progress.js';

    initUtils();

    /* ====== Elements ====== */
    const timerFill = document.getElementById('timer-fill');
    const scoreEl = document.getElementById('score');
    const correctEl = document.getElementById('correct-count');
    const pbEl = document.getElementById('personal-best');
    const hudDifficulty = document.getElementById('hud-difficulty');

    const modelDisplay = document.getElementById('model-display');
    const userSequence = document.getElementById('user-sequence');
    const piecesContainer = document.getElementById('pieces-container');

    const memoryTimer = document.getElementById('memory-timer');
    const statusText = document.getElementById('status-text');
    const currentStepElement = document.getElementById('current-step-display');
    const totalStepsElement = document.getElementById('total-steps');

    const startSessionButton = document.getElementById('start-session');
    const pauseButton = document.getElementById('pause-button');
    const checkButton = document.getElementById('check-button');
    const resetButton = document.getElementById('reset-button');
    const restartButton = document.getElementById('restart-button');

    const completionModal = document.getElementById('completion-message');
    const finalScoreElement = document.getElementById('final-score');
    const finalSequencesElement = document.getElementById('final-sequences');
    const finalAccuracyElement = document.getElementById('final-accuracy');
    const pbNote = document.getElementById('pb-note');
    const xpEarned = document.getElementById('xp-earned');

    const sequenceTypeSelect = document.getElementById('sequence-type');
    const difficultySelect = document.getElementById('difficulty-select');
    const showCompletedSelect = document.getElementById('show-completed');
    const sessionDurationInput = document.getElementById('session-duration');

    /* ====== State ====== */
    const EXERCISE_ID = 'sequence-builder';
    const PB_KEY = 'sequence-builder-pb-correct'; // PB on correct sequences
    let isSessionActive = false;
    let isPaused = false;
    let sessionDuration = 3 * 60 * 1000;
    let timeRemaining = 0;
    let timerInterval = null;
    let memoryTimerInterval = null;
    let score = 0;
    let sequencesCompleted = 0;
    let totalAttempts = 0;
    let correctSequences = 0;
    let currentSequenceIndex = 0;
    let selectedPiece = null;
    let sequences = [];
    let currentSequence = [];
    let availablePieces = [];
    let userSteps = [];
    let currentStepIndex = 0;
    let modelVisible = true;
    let firstTime = !localStorage.getItem('sequenceBuilderPlayed');

    function getCurrentDifficulty() { return difficultySelect?.value || 'medium'; }
    function setHudDifficulty() {
      const map = { easy: 'Easy', medium: 'Medium', hard: 'Hard' };
      hudDifficulty.textContent = map[getCurrentDifficulty()] || 'Medium';
    }
    setHudDifficulty();

    // Initialize session enhancement
    sessionEnhancement.initializeExercise(EXERCISE_ID, getCurrentDifficulty());
    difficultySelect?.addEventListener('change', () => {
      setHudDifficulty();
      sessionEnhancement.initializeExercise(EXERCISE_ID, getCurrentDifficulty());
    });

    /* ====== Background stars ====== */
    const starsContainer = document.getElementById('stars-container');
    for (let i = 0; i < 60; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      star.style.left = `${Math.random() * 100}%`;
      star.style.top = `${Math.random() * 100}%`;
      const size = Math.random() * 2 + .5;
      star.style.width = `${size}px`;
      star.style.height = `${size}px`;
      star.style.opacity = Math.random() * 0.4 + 0.1;
      starsContainer.appendChild(star);
    }

    /* ====== Sequences library (unchanged core content) ====== */
    const sequenceLibraries = {
      pattern: {
        pieces: ['🔹','🔸','🔺','🔻','⭐','💫','🌟','✨','⚡','❄️','🌀','🟡','🔄','➿','➰'],
        generators: [
          (steps)=> {
            const p=getRandomSubset(sequenceLibraries.pattern.pieces,2);
            return Array.from({length:steps},(_,i)=>p[i%2]);
          },
          (steps)=> {
            const p=getRandomSubset(sequenceLibraries.pattern.pieces,3);
            return Array.from({length:steps},(_,i)=>p[i%3]);
          },
          (steps)=> {
            const p=getRandomSubset(sequenceLibraries.pattern.pieces,3); const r=[];
            for (let i=0;i<steps;i++){ if(i===0) r.push(p[0]); else if(i===1) r.push(p[1]); else r.push(i%2===0?p[0]:p[1]); }
            return r;
          },
          (steps)=> getRandomSubset(sequenceLibraries.pattern.pieces, steps)
        ]
      },
      assembly: {
        pieces: ['🧱','🔨','🔧','🪚','🔩','⚙️','🧰','🧲','🧪','🔬','📊','🔋','📚','📍','🔒'],
        generators: [
          (steps)=> getRandomSubset(sequenceLibraries.assembly.pieces, steps),
          (steps)=> getRandomSubset(['🧱','🔨','🔧','⚙️','🔩','🧰','🗝️','🚧'], steps),
          (steps)=> getRandomSubset(['🧪','🔬','⚗️','🧫','📊','📍','💡','📚'], steps)
        ]
      },
      numerical: {
        pieces: ['0️⃣','1️⃣','2️⃣','3️⃣','4️⃣','5️⃣','6️⃣','7️⃣','8️⃣','9️⃣','🔢','🔣','➕','➖','✖️','➗'],
        generators: [
          (s)=>['0️⃣','1️⃣','2️⃣','3️⃣','4️⃣','5️⃣','6️⃣','7️⃣','8️⃣','9️⃣'].slice(0,s),
          (s)=>['0️⃣','2️⃣','4️⃣','6️⃣','8️⃣','🔟'].slice(0,s),
          (s)=>['1️⃣','3️⃣','5️⃣','7️⃣','9️⃣'].slice(0,s),
          (s)=>['1️⃣','➕','2️⃣','➖','3️⃣','✖️','4️⃣','➗'].slice(0,s)
        ]
      },
      spatial: {
        pieces: ['⬆️','⬇️','⬅️','➡️','↗️','↘️','↙️','↖️','↕️','↔️','🔄','🔀','🔂','🔃'],
        generators: [
          (s)=> getRandomSubset(['⬆️','⬇️','⬅️','➡️','↗️','↘️','↙️','↖️'], s),
          (s)=> getRandomSubset(['🔄','🔀','🔂','🔃','🔀'], s),
          (s)=> Array.from({length:s},(_,i)=>['⬆️','⬇️','⬅️','➡️'][i%4])
        ]
      }
    };

    /* ====== Event wiring ====== */
    startSessionButton.addEventListener('click', () => {
      if (firstTime) {
        firstTime = false;
        localStorage.setItem('sequenceBuilderPlayed','true');
      }
      startSession();
    });

    pauseButton.addEventListener('click', () => {
      if (!isSessionActive) return;
      isPaused = !isPaused;
      pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
      if (isPaused) {
        clearInterval(timerInterval);
      } else {
        runTimer();
      }
    });

    restartButton.addEventListener('click', () => {
      completionModal.style.display = 'none';
      startSession();
    });

    document.addEventListener('keydown', (e) => {
      if (!isSessionActive || isPaused) return;
      const el = document.activeElement;
      if ((e.key === 'Enter' || e.key === ' ') && el?.classList?.contains('sequence-piece')) {
        e.preventDefault();
        if (el.classList.contains('placeholder')) {
          placePiece(el);
        } else if (!el.classList.contains('model')) {
          selectPiece(el);
        }
      }
    });

    checkButton.addEventListener('click', checkSequence);
    resetButton.addEventListener('click', resetUserSequence);

    /* ====== Load/save simple settings ====== */
    loadSettings();

    /* ====== Helpers & game logic (adapted from original) ====== */
    function createSequencePiece(symbol, type='') {
      const piece = document.createElement('div');
      piece.className = 'sequence-piece';
      if (type) piece.classList.add(type);
      piece.textContent = symbol;
      piece.dataset.symbol = symbol;
      if (!type) piece.addEventListener('click', () => selectPiece(piece));
      piece.setAttribute('role','button');
      piece.setAttribute('tabindex','0');
      return piece;
    }

    function selectPiece(piece) {
      if (!isSessionActive || isPaused || piece.classList.contains('placeholder')) return;
      if (selectedPiece) selectedPiece.classList.remove('selected');
      selectedPiece = piece;
      selectedPiece.classList.add('selected');
      selectedPiece.focus();
      statusText.textContent = 'Now click an empty slot to place it';
      userSequence.classList.add('active');
    }

    function createUserPlaceholders(count) {
      userSequence.innerHTML = '';
      for (let i=0;i<count;i++) {
        const ph = document.createElement('div');
        ph.className = 'sequence-piece placeholder';
        ph.dataset.index = i;
        ph.setAttribute('role','button');
        ph.setAttribute('tabindex','0');
        ph.setAttribute('aria-label',`Empty slot ${i+1} of ${count}`);
        if (i === currentStepIndex) ph.classList.add('next');
        ph.addEventListener('click', () => placePiece(ph));
        userSequence.appendChild(ph);
      }
    }

    function placePiece(placeholder) {
      if (!selectedPiece || !isSessionActive || isPaused) return;
      const index = parseInt(placeholder.dataset.index,10);
      const newPiece = selectedPiece.cloneNode(true);
      newPiece.classList.remove('selected');
      newPiece.setAttribute('aria-label', `Placed ${newPiece.dataset.symbol} in position ${index+1}`);
      newPiece.addEventListener('click', () => removePiece(newPiece, index));
      userSequence.replaceChild(newPiece, placeholder);
      userSteps[index] = newPiece.dataset.symbol;
      currentStepIndex = userSteps.filter(Boolean).length;
      currentStepElement.textContent = Math.min(currentStepIndex + 1, currentSequence.length);
      selectedPiece.classList.remove('selected'); selectedPiece = null;
      statusText.textContent = currentStepIndex < currentSequence.length ? 'Select the next piece' : 'Sequence complete! Click Check';
      userSequence.classList.remove('active');
      updatePlaceholderHighlights();
      checkButton.disabled = currentStepIndex < currentSequence.length;
    }

    function removePiece(piece, index) {
      if (!isSessionActive || isPaused) return;
      const ph = document.createElement('div');
      ph.className = 'sequence-piece placeholder';
      ph.dataset.index = index;
      ph.setAttribute('role','button');
      ph.setAttribute('tabindex','0');
      ph.setAttribute('aria-label',`Empty slot ${index+1}`);
      ph.addEventListener('click', () => placePiece(ph));
      userSequence.replaceChild(ph, piece);
      userSteps[index] = null;
      currentStepIndex = userSteps.filter(Boolean).length;
      currentStepElement.textContent = Math.min(currentStepIndex + 1, currentSequence.length);
      statusText.textContent = 'Piece removed - select a piece to continue';
      updatePlaceholderHighlights();
      checkButton.disabled = true;
    }

    function updatePlaceholderHighlights() {
      const placeholders = userSequence.querySelectorAll('.placeholder');
      placeholders.forEach((p,i)=>{
        p.classList.remove('next');
        if (!userSteps[i] && !p.classList.contains('next')) {
          let hasPrevEmpty=false;
          for (let j=0;j<i;j++) if (!userSteps[j]) { hasPrevEmpty=true; break; }
          if (!hasPrevEmpty) p.classList.add('next');
        }
      });
    }

    function checkSequence() {
      if (!isSessionActive || isPaused || currentStepIndex < currentSequence.length) return;
      totalAttempts++;
      let isCorrect = true;
      for (let i=0;i<currentSequence.length;i++) {
        const piece = userSequence.children[i];
        if (userSteps[i] === currentSequence[i]) {
          piece.classList.add('correct');
        } else {
          piece.classList.add('incorrect');
          isCorrect = false;
        }
      }
      if (isCorrect) {
        correctSequences++; sequencesCompleted++;
        score += 100 + (50 * currentSequence.length);
        toast?.('✅ Perfect!');
      } else {
        score = Math.max(0, score - 25);
        toast?.('❌ Try again');
      }
      updateStats();
      checkButton.disabled = true; resetButton.disabled = true;

      setTimeout(() => {
        if (!isSessionActive) return;
        if (isCorrect) {
          currentSequenceIndex++;
          if (currentSequenceIndex < sequences.length) {
            startSequence(sequences[currentSequenceIndex]);
          } else {
            endSession(score, getCurrentDifficulty());
          }
        } else {
          resetUserSequence();
          checkButton.disabled = false; resetButton.disabled = false;
        }
      }, 1200);
    }

    function resetUserSequence() {
      if (!isSessionActive) return;
      currentStepIndex = 0; userSteps = [];
      currentStepElement.textContent = '1';
      createUserPlaceholders(currentSequence.length);
      statusText.textContent = 'Select a piece below to place';
      checkButton.disabled = true;
      if (selectedPiece) { selectedPiece.classList.remove('selected'); selectedPiece = null; }
      userSequence.classList.remove('active');
    }

    function updateStats() {
      scoreEl.textContent = score;
      correctEl.textContent = String(correctSequences);
    }

    function updateTimerUi() {
      const pct = Math.max(0, timeRemaining / sessionDuration);
      timerFill.style.width = `${pct * 100}%`;
    }

    function runTimer() {
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timeRemaining -= 100;
        updateTimerUi();
        if (timeRemaining <= 0) {
          endSession(score, getCurrentDifficulty());
        }
      }, 100);
    }

    function startSession() {
      // Reset state
      score = 0; sequencesCompleted = 0; totalAttempts = 0; correctSequences = 0;
      timeRemaining = (parseInt(sessionDurationInput.value,10) || 3) * 60 * 1000;
      sessionDuration = timeRemaining;
      currentSequenceIndex = 0; isPaused = false;
      pauseButton.textContent = 'Pause';

      // Generate sequences
      generateSequences(sequenceTypeSelect.value, getCurrentDifficulty());

      // Stats + HUD
      updateStats();
      setHudDifficulty();

      // First sequence
      isSessionActive = true; modelVisible = true;
      startSequence(sequences[0]);

      // Timer
      updateTimerUi();
      runTimer();

      // Save prefs
      saveSettings();
    }

    function generateSequences(type, difficulty) {
      sequences = [];
      let stepsPerSequence;
      switch (difficulty) {
        case 'easy': stepsPerSequence = Math.floor(Math.random()*2)+3; break;
        case 'hard': stepsPerSequence = Math.floor(Math.random()*2)+7; break;
        default: stepsPerSequence = Math.floor(Math.random()*2)+5; break;
      }
      for (let i=0;i<10;i++) {
        const library = sequenceLibraries[type];
        const generator = library.generators[Math.floor(Math.random()*library.generators.length)];
        sequences.push(generator(stepsPerSequence));
      }
    }

    function startSequence(sequence) {
      // Reset containers
      modelDisplay.innerHTML = '';
      userSequence.innerHTML = '';
      piecesContainer.innerHTML = '';
      currentSequence = sequence;
      userSteps = [];
      currentStepIndex = 0;
      currentStepElement.textContent = '1';
      totalStepsElement.textContent = sequence.length;
      statusText.textContent = 'Study the pattern above';
      checkButton.disabled = true; resetButton.disabled = false;

      // Render model + pieces
      sequence.forEach(item => modelDisplay.appendChild(createSequencePiece(item,'model')));
      createAvailablePieces(sequence);
      createUserPlaceholders(sequence.length);

      // Handle model visibility
      const showMode = showCompletedSelect.value;
      memoryTimer.style.display = 'none';
      modelDisplay.classList.remove('hidden');

      const applyHideAfter = (seconds, label) => {
        memoryTimer.style.display = '';
        let countdown = seconds;
        memoryTimer.textContent = `${label}: ${countdown}s`;
        clearInterval(memoryTimerInterval);
        memoryTimerInterval = setInterval(() => {
          countdown--;
          memoryTimer.textContent = `${label}: ${countdown}s`;
          if (countdown <= 0) {
            clearInterval(memoryTimerInterval);
            modelDisplay.classList.add('hidden');
            memoryTimer.style.display = 'none';
            modelVisible = false;
            statusText.textContent = 'Recreate the pattern from memory';
          }
        }, 1000);
      };

      if (showMode === 'initially') {
        applyHideAfter(5, 'Memorize');
      } else if (showMode === 'never') {
        applyHideAfter(2, 'Quick look');
      } else {
        statusText.textContent = 'Select a piece below to place';
      }
    }

    function createAvailablePieces(sequence) {
      const uniquePieces = [...new Set(sequence)];
      const library = sequenceLibraries[sequenceTypeSelect.value];
      let allPieces = [...uniquePieces];
      let numDistractors = 0;
      switch (getCurrentDifficulty()) {
        case 'easy': numDistractors = 2; break;
        case 'medium': numDistractors = 4; break;
        case 'hard': numDistractors = 6; break;
      }
      const distractors = library.pieces.filter(p => !uniquePieces.includes(p));
      const selectedDistractors = getRandomSubset(distractors, numDistractors);
      allPieces = [...allPieces, ...selectedDistractors];
      shuffleArray(allPieces);
      allPieces.forEach(symbol => piecesContainer.appendChild(createSequencePiece(symbol)));
      availablePieces = allPieces;
    }

    /* ====== Session end (SINGLE DEFINITION) ====== */
    function endSession(passedScore, passedDifficulty = 'easy') {
      clearInterval(timerInterval);
      clearInterval(memoryTimerInterval);
      isSessionActive = false;
      isPaused = false;

      const difficultyUsed = passedDifficulty || getCurrentDifficulty();
      const scoreUsed = typeof passedScore === 'number' ? passedScore : score;
      const accuracy = totalAttempts > 0 ? Math.round((correctSequences / totalAttempts) * 100) : 0;

      // Enhance/record
      sessionEnhancement.handleSessionComplete({
        score: scoreUsed,
        sequences: sequencesCompleted,
        accuracy,
        totalAttempts
      });

      try {
        recordSession(EXERCISE_ID, difficultyUsed, scoreUsed);
        markExerciseTried(EXERCISE_ID);
        const newly = checkAndUnlockAchievements() || [];
        newly.forEach(id => {
          if (typeof showAchievementNotification === 'function') showAchievementNotification(id);
          else toast?.(`Achievement unlocked: ${id}`);
        });
      } catch (e) { console.warn('Progress/Achievement hook error:', e); }

      // Personal Best (by Correct)
      const prevPb = parseInt(localStorage.getItem(PB_KEY) || '0', 10);
      let isNewPb = false;
      if (correctSequences > prevPb) {
        localStorage.setItem(PB_KEY, String(correctSequences));
        isNewPb = true;
      }
      pbEl.textContent = String(Math.max(correctSequences, prevPb));

      // Completion UI
      finalScoreElement.textContent = String(scoreUsed);
      finalSequencesElement.textContent = String(sequencesCompleted);
      finalAccuracyElement.textContent = `${accuracy}%`;
      xpEarned.textContent = String(scoreUsed); // XP mirrors score
      pbNote.classList.toggle('hidden', !isNewPb);
      completionModal.style.display = 'grid';
      timerFill.style.width = '0%';
    }

    // Expose single, standard endSession
    window.endSession = endSession;

    /* ====== Utils ====== */
    function hide(el){ el?.classList?.add('hidden'); }
    function show(el){ el?.classList?.remove('hidden'); }
    function getRandomSubset(array, size){ const shuffled=[...array].sort(()=>.5-Math.random()); return shuffled.slice(0,size); }
    function shuffleArray(array){ for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [array[i],array[j]]=[array[j],array[i]];} return array; }

    function saveSettings() {
      localStorage.setItem('sequenceType', sequenceTypeSelect.value);
      localStorage.setItem('sequenceDifficulty', difficultySelect.value);
      localStorage.setItem('showCompleted', showCompletedSelect.value);
      localStorage.setItem('sequenceDuration', sessionDurationInput.value);
    }
    function loadSettings() {
      if (localStorage.getItem('sequenceType')) sequenceTypeSelect.value = localStorage.getItem('sequenceType');
      if (localStorage.getItem('sequenceDifficulty')) difficultySelect.value = localStorage.getItem('sequenceDifficulty');
      if (localStorage.getItem('showCompleted')) showCompletedSelect.value = localStorage.getItem('showCompleted');
      if (localStorage.getItem('sequenceDuration')) sessionDurationInput.value = localStorage.getItem('sequenceDuration');
      // Set PB HUD on load
      const pb = parseInt(localStorage.getItem(PB_KEY) || '0', 10);
      pbEl.textContent = String(pb);
    }

    // Touch zoom prevention (kept)
    document.addEventListener('touchstart', (e) => { if (e.touches.length > 1) e.preventDefault(); }, { passive:false });
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      const now = Date.now(); if (now - lastTouchEnd <= 300) e.preventDefault(); lastTouchEnd = now;
    }, false);
  </script>
</body>
</html>
