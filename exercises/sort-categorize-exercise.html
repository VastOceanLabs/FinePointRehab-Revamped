<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RVKCCWBFKE"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-RVKCCWBFKE');
  </script>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Sort & Categorize Exercise | Cognitive-Motor Training | Fine Point Rehab</title>

  <!-- SEO Meta Tags -->
  <meta name="description" content="Interactive sorting and categorization exercise that combines cognitive processing with motor skills. Enhance visual discrimination, decision-making, and upper limb control while improving attention and cognitive flexibility. Ideal for stroke rehabilitation, brain injury recovery, and cognitive therapy.">

  <!-- Canonical URL -->
  <link rel="canonical" href="https://finepointrehab.com/exercises/sort-categorize-exercise.html">

  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="Sort & Categorize Exercise | Cognitive-Motor Training | Fine Point Rehab">
  <meta property="og:description" content="Interactive categorization exercise combining cognitive processing with motor skills. Enhance visual discrimination, decision-making, and upper limb control.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://finepointrehab.com/exercises/sort-categorize-exercise.html">
  <meta property="og:image" content="https://finepointrehab.com/images/sort-categorize-preview.jpg">
  <meta property="og:site_name" content="Fine Point Rehab">

  <!-- Design System Styles -->
  <link rel="stylesheet" href="/css/base.css">
  <link rel="stylesheet" href="/css/tokens.css">
  <link rel="stylesheet" href="/css/components.css">
  <link rel="stylesheet" href="/css/exercises.css">

  <style>
    /* Stars background effect */
    .star {
      position: absolute;
      width: 2px;
      height: 2px;
      background: var(--brand);
      border-radius: 50%;
      animation: twinkle 3s infinite;
    }
    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    /* Exercise-specific styles */
    #stars-container { 
      position: absolute; 
      inset: 0; 
      z-index: 1; 
      pointer-events: none; 
      overflow: hidden; 
    }

    #timer-bar { 
      position: absolute; 
      top: 0; 
      left: 0; 
      height: 4px; 
      background: var(--brand, #48cae4); 
      width: 100%; 
      z-index: 20; 
      border-radius: 0 0 var(--radius, 8px) var(--radius, 8px);
    }

    #challenge-display {
      position: absolute; 
      top: var(--gap, 16px); 
      left: 50%; 
      transform: translateX(-50%);
      padding: var(--gap, 16px);
      background: var(--color-bg-elevated, rgba(28, 42, 78, 0.95));
      border: 2px solid var(--brand, #48cae4);
      border-radius: var(--radius, 8px);
      z-index: 20; 
      font-weight: 700; 
      text-align: center; 
      max-width: 80%;
    }

    #sort-area {
      flex: 1;
      background: var(--color-bg-elevated, rgba(28, 42, 78, 0.95));
      border: 2px solid var(--brand, #48cae4);
      border-radius: var(--radius, 8px);
      overflow: hidden;
      box-shadow: 0 0 20px rgba(72, 202, 228, 0.3);
      display: flex; 
      flex-direction: column;
      margin: var(--gap, 16px);
    }

    #objects-container {
      flex: 1; 
      position: relative; 
      padding: var(--gap);
      display: flex; 
      flex-wrap: wrap; 
      align-items: center; 
      justify-content: center; 
      gap: var(--gap);
    }

    #categories-container {
      display: flex; 
      justify-content: space-evenly; 
      padding: var(--gap, 16px);
      border-top: 1px solid rgba(72, 202, 228, 0.5); 
      background: rgba(18, 29, 51, 0.5);
      min-height: 150px;
      flex-wrap: wrap;
      gap: var(--gap-sm, 8px);
    }

    .category-box {
      width: 130px; 
      height: 130px; 
      border: 3px dashed rgba(72, 202, 228, 0.7);
      border-radius: var(--radius, 8px); 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      padding: var(--gap-sm, 8px);
      transition: all 0.2s ease; 
      background: rgba(18, 29, 51, 0.4);
      position: relative;
    }

    .category-box.highlight { 
      background: rgba(72, 202, 228, 0.2); 
      box-shadow: 0 0 20px rgba(72, 202, 228, 0.5); 
      transform: scale(1.05);
    }

    .category-box.correct { 
      border-color: var(--success, #10b981); 
      background: rgba(16, 185, 129, 0.15); 
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.5); 
      animation: correctPulse 0.8s ease;
    }

    .category-box.incorrect { 
      border-color: var(--danger, #ef4444); 
      background: rgba(239, 68, 68, 0.15); 
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.5); 
      animation: incorrectShake 0.5s ease;
    }

    @keyframes correctPulse {
      0% { transform: scale(1) }
      50% { transform: scale(1.1) }
      100% { transform: scale(1) }
    }

    @keyframes incorrectShake {
      0% { transform: translateX(0) }
      20% { transform: translateX(-10px) }
      40% { transform: translateX(10px) }
      60% { transform: translateX(-10px) }
      80% { transform: translateX(10px) }
      100% { transform: translateX(0) }
    }

    .category-icon { 
      font-size: 38px; 
      margin-bottom: var(--gap-xs);
    }

    .category-label { 
      font-size: 16px; 
      text-align: center; 
      font-weight: 700; 
      color: var(--text-primary);
      background: rgba(var(--color-bg-rgb), 0.8); 
      padding: var(--gap-xs) var(--gap-sm); 
      border-radius: var(--radius); 
      width: 90%;
    }

    .sort-object {
      width: 70px; 
      height: 70px; 
      border-radius: var(--radius, 8px); 
      position: relative; 
      z-index: 5;
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 30px; 
      cursor: grab;
      box-shadow: 0 0 15px rgba(72, 202, 228, 0.4); 
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.95), var(--brand, #48cae4));
      border: 3px solid transparent; 
      touch-action: none; 
      user-select: none;
    }

    .sort-object:active { 
      cursor: grabbing; 
      transform: scale(1.05); 
      z-index: 12;
    }

    .sort-object:focus-visible {
      outline: 2px solid var(--brand, #48cae4);
      outline-offset: 2px;
    }

    .category-hint {
      position: absolute; 
      bottom: -24px; 
      left: 50%; 
      transform: translateX(-50%);
      font-size: 12px; 
      background: var(--color-bg-elevated);
      padding: var(--gap-xs) var(--gap-sm); 
      border-radius: var(--radius); 
      opacity: 0; 
      transition: opacity 0.2s ease; 
      pointer-events: none; 
      white-space: nowrap;
      border: 1px solid rgba(var(--brand-rgb), 0.3);
    }

    .sort-object:hover .category-hint { 
      opacity: 1;
    }

    .object-clone { 
      position: absolute; 
      opacity: 0.85; 
      pointer-events: none; 
      z-index: 15; 
      transition: transform 0.08s ease;
    }

    #round-progress { 
      position: relative; 
      height: 10px; 
      flex: 1; 
      background: rgba(148, 163, 184, 0.2); 
      border-radius: 999px; 
      overflow: hidden; 
      margin: 0 var(--gap-sm, 8px);
    }

    #round-progress-fill { 
      position: absolute; 
      top: 0; 
      left: 0; 
      height: 100%; 
      width: 0%; 
      background: linear-gradient(90deg, var(--brand, #48cae4), var(--accent, #2563eb));
    }

    #feedback-message {
      position: absolute; 
      top: 20%; 
      left: 50%; 
      transform: translateX(-50%);
      padding: var(--gap) var(--gap-lg); 
      border-radius: var(--radius); 
      font-size: 18px; 
      font-weight: 800; 
      opacity: 0; 
      transition: opacity 0.25s ease; 
      z-index: 50; 
      text-align: center; 
      box-shadow: var(--shadow-lg);
    }

    #feedback-message.show { 
      opacity: 1;
    }

    #feedback-message.correct { 
      background: var(--success, #10b981); 
      color: var(--text-on-success, #ffffff);
    }

    #feedback-message.incorrect { 
      background: var(--danger, #ef4444); 
      color: var(--text-on-danger, #ffffff);
    }

    .stat-box {
      text-align: center;
    }

    .stat-value { 
      font-size: 22px; 
      font-weight: 800; 
      color: var(--brand);
    }

    .stat-label { 
      font-size: 12px; 
      color: var(--text-secondary);
    }

    /* Game panel layout */
    .game-panel {
      position: relative;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .game-hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--gap-sm) var(--gap);
      background: var(--color-bg-elevated);
      border-bottom: 1px solid rgba(var(--brand-rgb), 0.2);
      gap: var(--gap);
    }

    .hud-stats {
      display: flex;
      gap: var(--gap-lg);
      align-items: center;
    }

    .hud-stat {
      display: flex;
      align-items: center;
      gap: var(--gap-xs);
      font-size: 14px;
    }

    .hud-stat .label {
      color: var(--text-secondary);
    }

    .hud-stat .value {
      color: var(--brand);
      font-weight: 700;
    }

    /* Bottom stats panel */
    #stats-panel {
      position: absolute; 
      bottom: 0; 
      left: 0; 
      right: 0;
      background: var(--color-bg-elevated); 
      padding: var(--gap-sm) var(--gap); 
      display: flex; 
      gap: var(--gap-sm); 
      justify-content: space-around; 
      align-items: center;
      box-shadow: var(--shadow-lg); 
      z-index: 30;
    }

    /* Utility Classes */
    .hidden { 
      display: none !important; 
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .stat-value { 
        font-size: 18px;
      }
      .category-box { 
        width: 110px; 
        height: 110px;
      }
      .category-icon { 
        font-size: 30px;
      }
      .category-label { 
        font-size: 14px;
      }
      .sort-object { 
        width: 60px; 
        height: 60px; 
        font-size: 24px;
      }
      #challenge-display { 
        font-size: 16px; 
        padding: var(--gap-sm);
      }
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      .category-box.correct {
        animation: none;
        border-color: var(--success);
      }
      .category-box.incorrect {
        animation: none;
        border-color: var(--danger);
      }
      .star {
        animation: none;
      }
    }
  </style>
</head>
<body>
  <main class="layout">
    <!-- Settings Panel -->
    <aside class="panel settings-panel" id="settings-panel" role="dialog" aria-modal="true" aria-labelledby="settings-title">
      <header class="panel-header">
        <h1 id="settings-title">Sort & Categorize</h1>
        <p class="panel-description">
          Drag and drop objects into their correct categories to train visual discrimination, decision-making, and hand-eye coordination.
        </p>
      </header>

      <div class="settings-content">
        <div class="setting-group">
          <label class="setting-label" for="difficulty">Difficulty</label>
          <select class="setting-input" id="difficulty" aria-label="Difficulty">
            <option value="easy">Easy (3 Categories)</option>
            <option value="medium" selected>Medium (4 Categories)</option>
            <option value="hard">Hard (5 Categories)</option>
          </select>
        </div>

        <div class="setting-group">
          <label class="setting-label" for="category-type">Category Type</label>
          <select class="setting-input" id="category-type" aria-label="Category Type">
            <option value="colors">Colors</option>
            <option value="shapes" selected>Shapes</option>
            <option value="numbers">Numbers</option>
            <option value="letters">Letters</option>
          </select>
        </div>

        <div class="setting-group">
          <label class="setting-label" for="objects-count">Objects Per Round</label>
          <select class="setting-input" id="objects-count" aria-label="Objects per round">
            <option value="6">Few (6)</option>
            <option value="9" selected>Medium (9)</option>
            <option value="12">Many (12)</option>
          </select>
        </div>

        <div class="setting-group">
          <label class="setting-label" for="session-duration">Session Duration (minutes)</label>
          <input class="setting-input" type="number" id="session-duration" min="1" max="10" value="3">
        </div>

        <div class="setting-group">
          <label class="setting-label" for="hint-setting">Show Category Hints</label>
          <select class="setting-input" id="hint-setting">
            <option value="off">Off</option>
            <option value="hover" selected>Show on Hover</option>
            <option value="always">Always Show</option>
          </select>
        </div>
      </div>

      <div class="panel-footer">
        <button class="btn btn-primary" id="start-session">Start Therapy Session</button>
      </div>
    </aside>

    <!-- Game Panel -->
    <section class="panel game-panel">
      <div class="game-hud">
        <div class="hud-stats">
          <div class="hud-stat">
            <span class="label">Score</span>
            <span class="value" id="hud-score">0</span>
          </div>
          <div class="hud-stat">
            <span class="label">Progress</span>
            <span class="value" id="hud-progress">0/0</span>
          </div>
          <div class="hud-stat">
            <span class="label">Difficulty</span>
            <span class="value" id="hud-difficulty">Medium</span>
          </div>
        </div>
      </div>

      <div class="game-area" role="application" aria-label="Sort & Categorize exercise">
        <div id="stars-container"></div>
        <div id="timer-bar"></div>
        
        <div id="challenge-display" role="status" aria-live="polite" class="hidden">
          Sort the objects by their categories
        </div>
        <div id="feedback-message" role="status" aria-live="polite"></div>

        <div id="sort-area" aria-label="Play area">
          <div id="objects-container" aria-label="Objects to sort"></div>
          <div id="categories-container" aria-label="Category boxes"></div>
        </div>

        <!-- Bottom Stats Panel -->
        <div id="stats-panel" class="hidden" aria-live="polite">
          <div class="stat-box">
            <div id="score" class="stat-value">0</div>
            <div class="stat-label">Score</div>
          </div>
          <div class="stat-box">
            <div id="rounds-completed" class="stat-value">0</div>
            <div class="stat-label">Rounds</div>
          </div>
          <div id="round-progress" aria-label="Round progress">
            <div id="round-progress-fill"></div>
          </div>
          <div class="stat-box">
            <div id="time-left" class="stat-value">3:00</div>
            <div class="stat-label">Time Left</div>
          </div>
          <div class="stat-box">
            <div id="accuracy" class="stat-value">0%</div>
            <div class="stat-label">Accuracy</div>
          </div>
        </div>

        <!-- Completion Dialog -->
        <div id="completion-message" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="completed-title">
          <div class="modal-content">
            <h2 id="completed-title">Session Complete!</h2>
            <div class="completion-stats">
              <p>Final Score: <span id="final-score" class="highlight">0</span></p>
              <p>Rounds Completed: <span id="final-rounds" class="highlight">0</span></p>
              <p>Accuracy: <span id="final-accuracy" class="highlight">0%</span></p>
            </div>
            <button class="btn btn-outline" id="restart-button">Start New Session</button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- STANDARDIZED MODULE IMPORTS & SESSION INTEGRATION -->
  <script type="module">
    import { recordSession } from '/js/progress.js';
    import { checkAndUnlockAchievements } from '/js/achievements.js';
    const EXERCISE_ID = 'sort';

    // Call this when an exercise session ends
    window.endSession = function(score, difficulty = 'medium') {
      recordSession(EXERCISE_ID, difficulty, score);
      try { checkAndUnlockAchievements(); } catch (e) { /* optional */ }
    };
  </script>

  <!-- MAIN GAME SCRIPT -->
  <script type="module">
    import { initUtils } from '/js/utils.js';
    import { sessionEnhancement } from '/js/session-enhancement.js';
    
    initUtils(); // Initialize utilities
    
    const EXERCISE_ID = 'sort';

    /* --------- State --------- */
    const el = (id) => document.getElementById(id);
    const objectsContainer = el('objects-container');
    const categoriesContainer = el('categories-container');
    const statsPanel = el('stats-panel');
    const challengeDisplay = el('challenge-display');
    const feedbackMessage = el('feedback-message');
    const timerBar = el('timer-bar');

    const scoreEl = el('score');
    const roundsEl = el('rounds-completed');
    const timeLeftEl = el('time-left');
    const accuracyEl = el('accuracy');

    const hudScore = el('hud-score');
    const hudProgress = el('hud-progress');
    const hudDifficulty = el('hud-difficulty');

    const progressFill = el('round-progress-fill');

    const settingsPanel = el('settings-panel');
    const startBtn = el('start-session');
    const restartBtn = el('restart-button');
    const completionMsg = el('completion-message');

    const stars = el('stars-container');

    let sessionActive = false;
    let sessionEndsAt = 0;
    let sessionTimerId = null;
    let totalSessionSeconds = 0;

    let score = 0;
    let rounds = 0;
    let attempts = 0;
    let correct = 0;

    let totalInRound = 0;
    let placedInRound = 0;

    let dragging = null;
    let dragClone = null;
    let dragOffset = {x:0,y:0};

    // Global event listeners for drag (attached once)
    let globalMoveHandler = null;
    let globalUpHandler = null;

    /* --------- Utilities --------- */
    function starfield(n=120){
      stars.innerHTML = '';
      const frag = document.createDocumentFragment();
      for(let i=0;i<n;i++){
        const s = document.createElement('div');
        s.className = 'star';
        s.style.left = (Math.random()*100)+'%';
        s.style.top  = (Math.random()*100)+'%';
        s.style.opacity = (0.25 + Math.random()*0.6).toFixed(2);
        s.style.transform = `scale(${0.8 + Math.random()*1.6})`;
        frag.appendChild(s);
      }
      stars.appendChild(frag);
    }
    starfield();

    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

    /* --------- Difficulty --------- */
    function getCurrentDifficulty(){
      const difficultySelect = document.getElementById('difficulty');
      if (!difficultySelect) return 'medium';
      const val = (difficultySelect.value || 'medium').toLowerCase();
      if (val !== 'easy' && val !== 'medium' && val !== 'hard') return 'medium';
      return val;
    }

    function categoryCountFor(difficulty){
      return difficulty === 'easy' ? 3 : (difficulty === 'hard' ? 5 : 4);
    }

    /* --------- Category Sets --------- */
    const emoji = {
      Red:'üî¥', Blue:'üîµ', Green:'üü¢', Yellow:'üü°', Purple:'üü£',
      Round:'üîµ', Square:'üü•', Triangle:'üî∫', Stars:'‚≠ê', Hearts:'‚ù§Ô∏è'
    };

    function buildCategories(type, difficulty){
      const n = categoryCountFor(difficulty);
      if (type === 'colors'){
        const base = ['Red','Blue','Green','Yellow','Purple'];
        return base.slice(0,n).map(label => ({ key:label, label, icon: emoji[label] || '‚¨ú' }));
      }
      if (type === 'shapes'){
        const base = ['Round','Square','Triangle','Stars','Hearts'];
        return base.slice(0,n).map(label => ({ key:label, label, icon: emoji[label] || '‚óªÔ∏è' }));
      }
      if (type === 'numbers'){
        // group buckets by ranges
        const defs = {
          easy:  [ [1,3], [4,6], [7,9] ],
          medium:[ [1,3], [4,6], [7,9], [10,12] ],
          hard:  [ [1,3], [4,6], [7,9], [10,12], [13,15] ]
        }[difficulty];
        return defs.map(([a,b]) => {
          const label = `${a}-${b}`;
          return { key:label, label, icon:'üî¢', range:[a,b] };
        });
      }
      if (type === 'letters'){
        // alphabet buckets
        const defs = {
          easy:  [ ['A','I'], ['J','R'], ['S','Z'] ],
          medium:[ ['A','F'], ['G','L'], ['M','R'], ['S','Z'] ],
          hard:  [ ['A','E'], ['F','J'], ['K','O'], ['P','T'], ['U','Z'] ]
        }[difficulty];
        return defs.map(([a,b]) => {
          const label = `${a}‚Äì${b}`;
          return { key:label, label, icon:'üî§', range:[a.charCodeAt(0), b.charCodeAt(0)] };
        });
      }
      return [];
    }

    function pickObjects(type, categories, count){
      const items = [];
      if (type === 'colors'){
        const pool = categories.map(c => c.key);
        for(let i=0;i<count;i++){
          const cat = pool[Math.floor(Math.random()*pool.length)];
          const icon = emoji[cat] || '‚¨ú';
          items.push({ display:icon, category:cat, hint:`Drop into ${cat}` });
        }
        return items;
      }
      if (type === 'shapes'){
        const pool = categories.map(c => c.key);
        const iconFor = (c)=> emoji[c] || '‚óªÔ∏è';
        for(let i=0;i<count;i++){
          const cat = pool[Math.floor(Math.random()*pool.length)];
          items.push({ display: iconFor(cat), category:cat, hint:`${cat}` });
        }
        return items;
      }
      if (type === 'numbers'){
        // derive min/max across ranges we use
        const min = Math.min(...categories.map(c => c.range[0]));
        const max = Math.max(...categories.map(c => c.range[1]));
        for(let i=0;i<count;i++){
          const num = Math.floor(Math.random()*(max-min+1))+min;
          const cat = categories.find(c => num>=c.range[0] && num<=c.range[1]).key;
          items.push({ display:String(num), category:cat, hint:`${cat}` });
        }
        return items;
      }
      if (type === 'letters'){
        const [min,max] = [
          Math.min(...categories.map(c => c.range[0])),
          Math.max(...categories.map(c => c.range[1]))
        ];
        for(let i=0;i<count;i++){
          const code = Math.floor(Math.random()*(max-min+1))+min;
          const letter = String.fromCharCode(code);
          const cat = categories.find(c => code>=c.range[0] && code<=c.range[1]).key;
          items.push({ display:letter, category:cat, hint:`${cat}` });
        }
        return items;
      }
      return items;
    }

    /* --------- Rendering --------- */
    function clearRoundUI(){
      objectsContainer.innerHTML = '';
      categoriesContainer.innerHTML = '';
      placedInRound = 0;
      updateRoundProgress();
    }

    function renderCategories(categories){
      const frag = document.createDocumentFragment();
      categories.forEach(c => {
        const box = document.createElement('div');
        box.className = 'category-box';
        box.setAttribute('role','button');
        box.setAttribute('aria-label', `Category ${c.label}`);
        box.dataset.category = c.key;

        const icon = document.createElement('div');
        icon.className = 'category-icon';
        icon.textContent = c.icon || '‚óªÔ∏è';

        const label = document.createElement('div');
        label.className = 'category-label';
        label.textContent = c.label;

        box.appendChild(icon); box.appendChild(label);
        frag.appendChild(box);
      });
      categoriesContainer.appendChild(frag);
    }

    function renderObjects(items, showHintsMode){
      const frag = document.createDocumentFragment();
      items.forEach((it, idx) => {
        const ob = document.createElement('div');
        ob.className = 'sort-object';
        ob.dataset.category = it.category;
        ob.dataset.index = String(idx);
        ob.setAttribute('tabindex', '0');
        ob.setAttribute('role','button');
        ob.setAttribute('aria-label', `Object ${it.display}, category ${it.category}`);

        const span = document.createElement('span');
        span.textContent = it.display;
        ob.appendChild(span);

        const hint = document.createElement('div');
        hint.className = 'category-hint';
        hint.textContent = it.hint || it.category;
        ob.appendChild(hint);

        if (showHintsMode === 'always'){
          hint.style.opacity = '1';
        } else if (showHintsMode === 'off'){
          hint.style.display = 'none';
        }

        attachDragHandlers(ob);
        frag.appendChild(ob);
      });
      objectsContainer.appendChild(frag);
    }

    /* --------- Drag & Drop (pointer-based) --------- */
    function pointerPos(e){
      if (e.touches && e.touches[0]) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
      return { x:e.clientX, y:e.clientY };
    }

    function setupGlobalDragHandlers() {
      if (globalMoveHandler) return; // Already set up

      globalMoveHandler = (e) => {
        if (!dragClone) return;
        e.preventDefault();
        const {x,y} = pointerPos(e);
        dragClone.style.transform = `translate(${x - dragOffset.x - parseFloat(dragClone.style.left)}px, ${y - dragOffset.y - parseFloat(dragClone.style.top)}px)`;

        // highlight hovered category
        const target = categoryAtPoint(x,y);
        for (const box of categoriesContainer.children){
          box.classList.toggle('highlight', box === target);
        }
      };

      globalUpHandler = (e) => {
        if (!dragClone) return;
        const {x,y} = pointerPos(e);
        const target = categoryAtPoint(x,y);
        finalizeDrop(target);
      };

      // Add only pointer event listeners (covers touch + mouse on modern browsers)
      window.addEventListener('pointermove', globalMoveHandler, {passive:false});
      window.addEventListener('pointerup', globalUpHandler, {passive:false});
    }

    function attachDragHandlers(elm){
      const onDown = (e) => {
        if (!sessionActive) return;
        e.preventDefault();
        elm.setPointerCapture?.(e.pointerId || undefined);

        const {x,y} = pointerPos(e);
        const rect = elm.getBoundingClientRect();
        dragOffset = { x: x - rect.left, y: y - rect.top };

        dragging = elm;
        dragClone = elm.cloneNode(true);
        dragClone.classList.add('object-clone');
        dragClone.style.width = rect.width+'px';
        dragClone.style.height = rect.height+'px';
        dragClone.style.left = rect.left+'px';
        dragClone.style.top = rect.top+'px';
        document.body.appendChild(dragClone);

        elm.style.opacity = '0.25';
      };

      // Attach only pointer event handlers (covers touch + mouse on modern browsers)
      elm.addEventListener('pointerdown', onDown, {passive:false});
    }

    function categoryAtPoint(x,y){
      const boxes = Array.from(categoriesContainer.children);
      for (const b of boxes){
        const r = b.getBoundingClientRect();
        if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) return b;
      }
      return null;
    }

    function finalizeDrop(targetBox){
      const obj = dragging;
      const clone = dragClone;
      dragging = null; 
      dragClone = null;

      // clear highlights
      for (const box of categoriesContainer.children){ 
        box.classList.remove('highlight'); 
      }

      if (!obj){ return; }

      const correctCat = obj.dataset.category;
      attempts++;

      if (targetBox && targetBox.dataset.category === correctCat){
        // Correct placement
        targetBox.classList.add('correct');
        setTimeout(()=> targetBox.classList.remove('correct'), 350);

        showFeedback(true);
        correct++;
        score += 10;
        placedInRound++;
        updateRoundProgress();

        // Remove object after brief delay for better UX
        setTimeout(() => {
          if (obj && obj.parentNode) obj.remove();
        }, 200);
        
      } else {
        if (targetBox){
          targetBox.classList.add('incorrect');
          setTimeout(()=> targetBox.classList.remove('incorrect'), 350);
        }
        showFeedback(false);
        score = Math.max(0, score - 2);
        
        // Reset object position and opacity
        if (obj && obj.parentNode) obj.style.opacity = '1';
      }

      // cleanup clone
      if (clone && clone.parentNode) clone.parentNode.removeChild(clone);

      updateScoreAccuracy();
      updateHud();

      // Round complete?
      if (placedInRound >= totalInRound){
        rounds++;
        roundsEl.textContent = String(rounds);
        startNextRound();
      }
    }

    function showFeedback(isCorrect){
      const msg = isCorrect ? 'Nice!' : 'Try again';
      feedbackMessage.textContent = msg;
      feedbackMessage.className = 'show ' + (isCorrect ? 'correct' : 'incorrect');
      setTimeout(()=> { 
        feedbackMessage.className = feedbackMessage.className.replace('show','').trim(); 
      }, 600);
    }

    function updateScoreAccuracy(){
      const acc = attempts ? Math.round((correct/attempts)*100) : 0;
      scoreEl.textContent = String(score);
      accuracyEl.textContent = acc + '%';
    }

    function updateHud(){
      hudScore.textContent = String(score);
      hudProgress.textContent = `${placedInRound}/${totalInRound}`;
      hudDifficulty.textContent = capitalize(getCurrentDifficulty());
    }

    function updateRoundProgress(){
      const pct = totalInRound ? (placedInRound/totalInRound)*100 : 0;
      progressFill.style.width = pct + '%';
      hudProgress.textContent = `${placedInRound}/${totalInRound}`;
    }

    function capitalize(s){ return (s||'').slice(0,1).toUpperCase() + (s||'').slice(1) }

    /* --------- Rounds --------- */
    function startRound(){
      const difficulty = getCurrentDifficulty();
      const type = document.getElementById('category-type').value;
      const count = parseInt(document.getElementById('objects-count').value,10);

      const categories = buildCategories(type, difficulty);
      clearRoundUI();
      renderCategories(categories);

      const items = pickObjects(type, categories, count);
      totalInRound = items.length;
      placedInRound = 0;

      const hintMode = document.getElementById('hint-setting').value; // 'off' | 'hover' | 'always'
      renderObjects(items, hintMode);

      challengeDisplay.classList.remove('hidden');
      challengeDisplay.textContent = `Sort by ${capitalize(type)} (${categories.length} categories)`;
      updateRoundProgress();
      updateHud();
    }

    function startNextRound(){
      // brief pause then new round
      setTimeout(()=> startRound(), 500);
    }

    /* --------- Session Timer --------- */
    function formatTime(s){
      const m = Math.floor(s/60);
      const r = s%60;
      return `${m}:${String(r).padStart(2,'0')}`;
    }

    function startTimer(totalSeconds){
      totalSessionSeconds = totalSeconds;
      sessionEndsAt = Date.now() + totalSeconds*1000;

      if (sessionTimerId) clearInterval(sessionTimerId);

      sessionTimerId = setInterval(() => {
        const remaining = Math.max(0, Math.ceil((sessionEndsAt - Date.now())/1000));
        timeLeftEl.textContent = formatTime(remaining);

        const pct = clamp(remaining/totalSessionSeconds, 0, 1);
        timerBar.style.width = (pct*100) + '%';

        if (remaining <= 0){
          clearInterval(sessionTimerId);
          endExercise();
        }
      }, 250);
    }

    function endExercise(){
      sessionActive = false;
      
      // Clear game area
      clearRoundUI();
      challengeDisplay.classList.add('hidden');
      statsPanel.classList.add('hidden');

      const acc = attempts ? Math.round((correct/attempts)*100) : 0;
      document.getElementById('final-score').textContent = String(score);
      document.getElementById('final-rounds').textContent = String(rounds);
      document.getElementById('final-accuracy').textContent = acc + '%';

      completionMsg.classList.remove('hidden');

      // Notify session enhancement system
      try {
        sessionEnhancement.handleSessionComplete({ 
          score: score, 
          accuracy: acc,
          rounds: rounds,
          attempts: attempts,
          correct: correct
        });
      } catch (e) {
        console.warn('Session enhancement not available:', e);
      }

      // Record session via shared hook
      window.endSession(score, getCurrentDifficulty());
    }

    /* --------- Session Flow --------- */
    function resetState(){
      score = 0; rounds = 0; attempts = 0; correct = 0;
      scoreEl.textContent = '0'; 
      roundsEl.textContent = '0'; 
      accuracyEl.textContent = '0%';
      hudScore.textContent = '0'; 
      hudProgress.textContent = '0/0';
      timerBar.style.width = '100%';
      updateHud();
    }

    function initializeSession() {
      // Initialize session enhancement with current difficulty
      try {
        sessionEnhancement.initializeExercise(EXERCISE_ID, getCurrentDifficulty());
      } catch (e) {
        console.warn('Session enhancement initialization failed:', e);
      }
    }

    startBtn.addEventListener('click', () => {
      settingsPanel.classList.add('hidden');
      settingsPanel.setAttribute('aria-hidden', 'true');
      statsPanel.classList.remove('hidden');
      statsPanel.removeAttribute('aria-hidden');
      completionMsg.classList.add('hidden');
      completionMsg.setAttribute('aria-hidden', 'true');
      sessionActive = true;
      resetState();
      
      // Set up global drag handlers
      setupGlobalDragHandlers();

      // start round + timer
      startRound();
      const mins = clamp(parseInt(document.getElementById('session-duration').value,10) || 3, 1, 10);
      startTimer(mins * 60);
    });

    restartBtn.addEventListener('click', () => {
      completionMsg.classList.add('hidden');
      completionMsg.setAttribute('aria-hidden', 'true');
      settingsPanel.classList.remove('hidden');
      settingsPanel.removeAttribute('aria-hidden');
    });

    // Update session enhancement when difficulty changes
    document.getElementById('difficulty').addEventListener('change', () => {
      updateHud();
      initializeSession();
    });

    // Accessibility: keyboard "drop" (Enter/Space) to nearest category center
    objectsContainer.addEventListener('keydown', (e) => {
      if (!sessionActive) return;
      const tgt = e.target.closest('.sort-object');
      if (!tgt) return;
      if (e.key === 'Enter' || e.key === ' '){
        e.preventDefault();
        // snap to closest category by distance
        const objRect = tgt.getBoundingClientRect();
        const oc = { x: objRect.left + objRect.width/2, y: objRect.top + objRect.height/2 };
        let best = null, bestD = Infinity;
        for (const b of categoriesContainer.children){
          const r = b.getBoundingClientRect();
          const bc = { x: r.left + r.width/2, y: r.top + r.height/2 };
          const d = Math.hypot(oc.x - bc.x, oc.y - bc.y);
          if (d < bestD){ bestD = d; best = b; }
        }
        
        // Simulate drag and drop
        dragging = tgt;
        dragClone = null; // Skip visual clone for keyboard interaction
        finalizeDrop(best);
      }
    });

    /* --------- Initialize session enhancement --------- */
    // Initialize on page load
    initializeSession();

  </script>
</body>
</html>