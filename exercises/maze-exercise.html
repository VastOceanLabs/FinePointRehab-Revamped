<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RVKCCWBFKE"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-RVKCCWBFKE', { 'anonymize_ip': true });
  </script>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Cosmic Maze — Fine Motor Skills Rehabilitation | Fine Point Rehab</title>

  <!-- Design System CSS -->
  <link rel="stylesheet" href="/css/tokens.css">
  <link rel="stylesheet" href="/css/base.css">
  <link rel="stylesheet" href="/css/components.css">

  <style>
    /* ===== Global background + starfield ===== */
    body {
      min-height: 100vh;
      background:
        radial-gradient(ellipse at 20% 30%, rgba(40,20,80,0.4) 0%, transparent 40%),
        radial-gradient(ellipse at 80% 70%, rgba(20,40,80,0.3) 0%, transparent 40%),
        radial-gradient(ellipse at 50% 50%, rgba(10,20,40,0.5) 0%, transparent 70%),
        linear-gradient(180deg, #0a0e1a 0%, #1a1f3a 50%, #0f1524 100%);
    }

    /* ===== Sticky Header & Navigation ===== */
    .site-header {
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(8px);
      background: rgba(8, 15, 35, 0.8);
      border-bottom: 1px solid var(--border);
    }
    .site-header .inner {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-3) var(--space-4);
      max-width: 1200px;
      margin: 0 auto;
    }
    .site-header h1 {
      margin: 0;
      font-size: var(--font-size-xl);
      line-height: 1.2;
    }
    .home-link {
      display: inline-flex;
      align-items: center;
      gap: .5ch;
      text-decoration: none;
    }

    /* ===== Two-column shared layout ===== */
    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: var(--space-4);
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: var(--space-4);
    }
    @media (max-width: 920px) {
      .page {
        grid-template-columns: 1fr;
      }
    }

    /* Left panel: settings (use .panel class) */
    .settings-panel.panel {
      position: relative;
      padding-bottom: var(--space-6);
    }
    .settings-panel h2 {
      margin: 0 0 var(--space-4);
      font-size: var(--font-size-lg);
      text-align: center;
    }
    .game-description {
      background: var(--bg-tertiary);
      border-radius: var(--radius);
      padding: var(--space-4);
      margin-bottom: var(--space-4);
      border: 1px solid var(--border);
    }
    .settings-group { margin-bottom: var(--space-4); }
    .settings-label {
      display: block;
      margin-bottom: var(--space-2);
      font-weight: var(--font-weight-semibold);
    }
    .setting-help {
      display: block;
      color: var(--text-muted);
      font-size: var(--font-size-xs);
      margin-top: var(--space-1);
      font-style: italic;
    }

    /* Right panel: HUD + game area */
    .right-col {
      display: grid;
      grid-template-rows: auto 1fr;
      gap: var(--space-3);
      min-height: 70vh;
    }

    /* HUD row (use .panel) */
    .hud.panel {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: 1fr;
      gap: var(--space-3);
      align-items: center;
      position: relative;
      padding-top: calc(var(--space-3) + 8px);
    }
    .hud-group {
      display: grid;
      gap: var(--space-1);
      text-align: center;
    }
    .hud-value {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--brand-aqua);
    }
    .hud-label {
      font-size: var(--font-size-xs);
      color: var(--text-secondary);
    }
    /* Timer bar (standardised) */
    .timer-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 8px;
      width: 100%;
      background: linear-gradient(90deg, var(--brand-aqua), rgba(111,211,245,.35));
      transform-origin: left center;
      transition: transform .1s linear;
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
    }
    /* Controls */
    .controls {
      display: flex;
      gap: var(--space-2);
      justify-content: center;
      flex-wrap: wrap;
    }

    /* Instructions text */
    .instructions {
      text-align: center;
      color: var(--text-secondary);
      margin: 0 0 var(--space-3);
      font-size: var(--font-size-base);
      padding: var(--space-3);
      background-color: rgba(8, 15, 35, 0.7);
      border-radius: var(--radius);
    }

    /* Game container */
    #game-container {
      position: relative;
      display: grid;
      place-items: center;
      padding: var(--space-3);
      background: rgba(0,0,0,0.15);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-lg);
      overflow: hidden;
    }
    #stars-container { position: absolute; inset: 0; pointer-events: none; }
    #maze-container {
      position: relative;
      background-color: rgba(0, 0, 0, 0.3);
      border: 2px solid var(--brand-aqua);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: 0 0 20px rgba(111, 211, 245, 0.2);
      touch-action: none;
      outline: none;
    }

    .maze-wall {
      position: absolute;
      background: linear-gradient(135deg, rgba(7, 25, 59, 0.9), rgba(11, 42, 88, 0.9));
      border: 1px solid var(--brand-aqua);
      box-shadow: 0 0 8px rgba(111, 211, 245, 0.2);
    }
    .path-line { position: absolute; z-index: 2; opacity: .5; }
    .path-line.horizontal {
      height: 2px;
      background-image: repeating-linear-gradient(90deg, transparent, transparent 4px, var(--brand-aqua) 4px, var(--brand-aqua) 8px);
    }
    .path-line.vertical {
      width: 2px;
      background-image: repeating-linear-gradient(0deg, transparent, transparent 4px, var(--brand-aqua) 4px, var(--brand-aqua) 8px);
    }
    .path-node {
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: var(--brand-aqua);
      border-radius: var(--radius-full);
      z-index: 3;
      transform: translate(-50%, -50%);
      opacity: 0.7;
    }

    /* Player + goal */
    #player {
      position: absolute;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40'%3E%3Cdefs%3E%3ClinearGradient id='bodyGrad' x1='0%25' y1='0%25' x2='0%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23e8eef5'/%3E%3Cstop offset='100%25' style='stop-color:%239fb5d4'/%3E%3C/linearGradient%3E%3ClinearGradient id='windowGrad' x1='0%25' y1='0%25' x2='0%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%236495ed'/%3E%3Cstop offset='100%25' style='stop-color:%232856a8'/%3E%3C/linearGradient%3E%3ClinearGradient id='flameGrad' x1='0%25' y1='0%25' x2='0%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23ffef00'/%3E%3Cstop offset='50%25' style='stop-color:%23ff8c00'/%3E%3Cstop offset='100%25' style='stop-color:%23ff4500'/%3E%3C/linearGradient%3E%3C/defs%3E%3Cellipse cx='20' cy='20' rx='12' ry='16' fill='url(%23bodyGrad)' stroke='%23364a69' stroke-width='1'/%3E%3Cellipse cx='20' cy='12' rx='6' ry='7' fill='url(%23windowGrad)' stroke='%231a3a6e' stroke-width='0.5'/%3E%3Cellipse cx='18' cy='10' rx='2' ry='3' fill='%23a8ccff' opacity='0.6'/%3E%3Cpath d='M8 18 L2 28 L8 26 Z' fill='%23536b8a' stroke='%23364a69' stroke-width='0.5'/%3E%3Cpath d='M32 18 L38 28 L32 26 Z' fill='%23536b8a' stroke='%23364a69' stroke-width='0.5'/%3E%3Crect x='14' y='32' width='4' height='3' rx='1' fill='%23434d5a'/%3E%3Crect x='22' y='32' width='4' height='3' rx='1' fill='%23434d5a'/%3E%3Cellipse cx='16' cy='36' rx='3' ry='5' fill='url(%23flameGrad)' opacity='0.9'/%3E%3Cellipse cx='24' cy='36' rx='3' ry='5' fill='url(%23flameGrad)' opacity='0.9'/%3E%3Cline x1='12' y1='20' x2='28' y2='20' stroke='%23536b8a' stroke-width='0.5'/%3E%3Cline x1='12' y1='24' x2='28' y2='24' stroke='%23536b8a' stroke-width='0.5'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transform: translate(-50%, -50%) rotate(90deg);
      box-shadow: 0 0 20px var(--brand-aqua);
      z-index: 10;
      cursor: pointer;
      touch-action: none;
      transition: box-shadow var(--duration-fast) var(--easing);
      animation: hover 2s ease-in-out infinite;
    }
    @keyframes hover {
      0%, 100% { transform: translate(-50%, -50%) rotate(90deg) translateY(0); }
      50%      { transform: translate(-50%, -50%) rotate(90deg) translateY(-2px); }
    }
    #goal {
      position: absolute;
      width: 44px; height: 44px;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 50 50'%3E%3Cdefs%3E%3CradialGradient id='earthGlow'%3E%3Cstop offset='70%25' style='stop-color:%2300ff00;stop-opacity:0'/%3E%3Cstop offset='100%25' style='stop-color:%2300ff00;stop-opacity:0.3'/%3E%3C/radialGradient%3E%3C/defs%3E%3Ccircle cx='25' cy='25' r='24' fill='url(%23earthGlow)'/%3E%3Ccircle cx='25' cy='25' r='20' fill='%232E86AB' stroke='%231a5a7a' stroke-width='0.5'/%3E%3Cpath d='M15 15 Q20 12 25 14 T35 18 Q33 25 30 28 Q25 30 20 28 Q15 25 15 20 Z' fill='%23228B22' opacity='0.8'/%3E%3Cpath d='M10 25 Q12 23 15 24 Q18 28 15 32 Q12 33 10 30 Z' fill='%23228B22' opacity='0.8'/%3E%3Cpath d='M30 10 Q35 12 37 15 Q35 18 32 16 Q30 13 30 10 Z' fill='%23228B22' opacity='0.8'/%3E%3Cpath d='M25 32 Q28 35 32 36 Q35 38 33 40 Q28 39 25 36 Z' fill='%23228B22' opacity='0.8'/%3E%3Cpath d='M12 18 Q15 17 18 18' stroke='white' stroke-width='1' fill='none' opacity='0.4'/%3E%3Cpath d='M28 22 Q31 21 34 22' stroke='white' stroke-width='1' fill='none' opacity='0.4'/%3E%3Cpath d='M20 35 Q23 34 26 35' stroke='white' stroke-width='1' fill='none' opacity='0.4'/%3E%3Cpath d='M10 20 Q10 10 20 7 Q30 5 38 12' stroke='%2387CEEB' stroke-width='1.5' fill='none' opacity='0.5'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      border-radius: var(--radius-full);
      z-index: 5;
      box-shadow: 0 0 30px rgba(46, 134, 171, 0.7);
      transform: translate(-50%, -50%);
    }

    /* START/FINISH labels + path trace */
    .point-label {
      position: absolute;
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius);
      transform: translate(-50%, -50%);
      z-index: 20;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
      white-space: nowrap;
    }
    #start-label { color: var(--brand-aqua); background-color: var(--bg-primary); border: 1px solid var(--brand-aqua); box-shadow: 0 0 8px rgba(111, 211, 245, 0.5); }
    #end-label   { color: var(--success);    background-color: var(--bg-primary); border: 1px solid var(--success);    box-shadow: 0 0 8px rgba(76, 175, 80, 0.5); }
    .path-trace { position: absolute; background-color: rgba(111, 211, 245, 0.3); border-radius: var(--radius-full); pointer-events: none; z-index: 2; }

    /* Completion modal (use .panel) */
    .completion.panel {
      position: fixed;
      inset: 50% auto auto 50%;
      transform: translate(-50%, -50%) scale(1);
      max-width: 90%;
      width: 560px;
      z-index: 1100;
      text-align: center;
      display: none;
    }
    .completion.panel.show { display: block; animation: pop .25s ease; }
    @keyframes pop { from { transform: translate(-50%, -50%) scale(.95); opacity: .6; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }
    .score-highlight { color: var(--brand-aqua); font-weight: var(--font-weight-bold); }

    /* Simple completion glow animation on maze */
    .maze-celebrate { animation: celebrate 900ms ease-out 1; }
    @keyframes celebrate {
      0%   { box-shadow: 0 0 0 rgba(111,211,245,0); }
      40%  { box-shadow: 0 0 40px rgba(111,211,245,.8); }
      100% { box-shadow: 0 0 20px rgba(111,211,245,.2); }
    }

    /* Error toast */
    #error-message {
      position: fixed;
      top: 20px; left: 50%; transform: translateX(-50%);
      background-color: var(--error-bg);
      color: var(--error);
      padding: var(--space-4) var(--space-6);
      border-radius: var(--radius);
      z-index: 1200;
      display: none;
      animation: slideDown 0.3s ease;
    }
    @keyframes slideDown { from { transform: translate(-50%, -100%); } to { transform: translate(-50%, 0); } }

    /* Utilities */
    .hidden { display: none !important; }
  </style>

<style id="maze-immersive-css">
/* === Site-consistent immersive layout for Maze (non-breaking) === */
:root { --vh: 1vh; }
@supports (height: 100dvh) { :root { --vh: 1dvh; } }

/* Full-bleed stage and hidden chrome while playing */
body.playing .site-header { display: none !important; }
body.playing .settings, 
body.playing .settings-panel, 
body.playing #settings { display: none !important; }

/* Main grid should collapse to a single column and fill viewport */
body.playing .page,
body.playing .main-grid,
body.playing main { 
  grid-template-columns: 1fr !important; 
  padding: 0 !important; 
  height: calc(var(--vh) * 100) !important; 
  max-width: none !important;
}

/* Stretch game frame */
body.playing #game-container,
body.playing .game-container, 
body.playing #stage, 
body.playing .frame {
  width: 100vw !important;
  height: calc(var(--vh) * 100) !important;
  max-height: none !important;
  border-radius: 0 !important;
  border: none !important;
  background: transparent !important;
  box-shadow: none !important;
  overflow: hidden !important;
}

/* Float HUD over the stage with translucent glass */
body.playing .hud, 
body.playing .hud-bar {
  position: absolute !important;
  z-index: 1000 !important;
  top: calc(env(safe-area-inset-top, 0px) + 10px) !important;
  left: 10px !important;
  right: 10px !important;
  margin: 0 !important;
  background: linear-gradient(180deg, rgba(6,10,24,0.65), rgba(6,10,24,0.35)) !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
  border-radius: 14px !important;
  box-shadow: 0 6px 16px rgba(0,0,0,.35) !important;
}

/* Keep timer bar visible at top if it's inside the HUD or frame */
#timer-bar { 
  position: absolute; 
  top: 0; left: 0; 
  height: 8px; width: 100%; 
  transform-origin: left center; 
}
</style>

</head>

<body>
  <!-- ===== Sticky Header ===== -->
  <header class="site-header" role="banner">
    <div class="inner">
      <a class="home-link btn btn-secondary" href="/" aria-label="Go to Home">← Home</a>
      <h1 id="page-title">Cosmic Maze</h1>
    </div>
  </header>

  <!-- ===== Main Layout ===== -->
  <main class="page" role="main">
    <!-- Left: Settings -->
    <aside class="settings-panel panel" role="complementary" aria-labelledby="settings-heading">
      <h2 id="settings-heading">Session Settings</h2>

      <div class="game-description" aria-describedby="about-p">
        <h3 class="sr-only">About This Exercise</h3>
        <p id="about-p">
          Navigate a spaceship through randomly generated mazes to reach Earth. Improves fine motor control,
          hand–eye coordination, and precision. Drag the spaceship or use arrow keys to follow the dotted paths.
        </p>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="difficulty-select">Difficulty</label>
        <select id="difficulty-select" aria-label="Select difficulty level">
          <option value="easy" selected>Easy — wide paths</option>
          <option value="medium">Medium — standard paths</option>
          <option value="hard">Hard — narrow paths</option>
        </select>
        <small class="setting-help">Higher difficulty increases precision demands.</small>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="session-duration">Session Duration (minutes)</label>
        <input class="input" type="number" id="session-duration" min="1" max="10" value="5" aria-label="Set session duration in minutes">
        <small class="setting-help">1–10 minutes recommended.</small>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="show-trace">Movement Trail</label>
        <select id="show-trace" aria-label="Enable or disable movement trail">
          <option value="yes" selected>Show trail</option>
          <option value="no">Hide trail</option>
        </select>
        <small class="setting-help">Trail helps visualize movement patterns.</small>
      </div>

      <div class="controls" aria-label="Session controls (left panel)">
        <button id="start-session" class="btn btn-primary" aria-label="Start session">Start</button>
        <button id="pause-session" class="btn btn-secondary" aria-pressed="false" aria-label="Pause session">Pause</button>
        <button id="restart-session" class="btn" aria-label="Restart session">Restart</button>
      </div>
    </aside>

    <!-- Right: HUD + Game -->
    <section class="right-col" aria-labelledby="page-title">
      <!-- HUD Row -->
      <div class="hud panel" role="region" aria-label="Session heads-up display">
        <div class="timer-bar" id="timer-bar" aria-hidden="true"></div>

        <div class="hud-group" aria-live="polite">
          <div id="hud-score" class="hud-value">0</div>
          <div class="hud-label">Score</div>
        </div>

        <div class="hud-group" aria-live="polite">
          <div id="hud-pb" class="hud-value">0</div>
          <div class="hud-label">Personal Best</div>
        </div>

        <div class="hud-group" aria-live="polite">
          <div id="hud-difficulty" class="hud-value">easy</div>
          <div class="hud-label">Difficulty</div>
        </div>

        <div class="hud-group" aria-live="polite">
          <div id="hud-completed" class="hud-value">0</div>
          <div class="hud-label">Mazes Completed</div>
        </div>

        <div class="hud-group" aria-live="polite">
          <div id="hud-moves" class="hud-value">0</div>
          <div class="hud-label">Moves (this maze)</div>
        </div>

        <div class="hud-group" aria-live="polite">
          <div id="hud-avg" class="hud-value">0.0s</div>
          <div class="hud-label">Avg. Completion</div>
        </div>

        <div class="hud-group" aria-live="polite">
          <div id="hud-time" class="hud-value">5:00</div>
          <div class="hud-label">Time Left</div>
        </div>
      </div>

      <!-- Game Area -->
      <div class="panel" id="game-container">
        <div id="stars-container" aria-hidden="true"></div>

        <p class="instructions" id="instructions">
          Guide the spaceship through the cosmic maze to reach Earth. Drag the ship or use arrow keys to follow the dotted lines.
        </p>

        <div id="maze-container"
             tabindex="0"
             role="application"
             aria-label="Cosmic maze game area. Use arrow keys or drag to move.">
        </div>
      </div>
    </section>
  </main>

  <!-- Completion Modal -->
  <div id="completion-message" class="completion panel" role="dialog" aria-modal="true" aria-labelledby="complete-title">
    <h2 id="complete-title">Therapy Session Complete!</h2>
    <div id="completion-scores" aria-live="polite">
      <p>Mazes Completed: <span id="final-completed" class="score-highlight">0</span></p>
      <p>Average Completion Time: <span id="final-avg-time" class="score-highlight">0.0s</span></p>
      <p>Motor Performance Score: <span id="final-score" class="score-highlight">0</span></p>
      <p>XP Earned: <span id="final-xp" class="score-highlight">0</span></p>
    </div>
    <div class="controls" aria-label="Completion controls">
      <button id="restart-button" class="btn btn-primary">Start New Therapy Session</button>
      <button class="btn" id="close-complete">Close</button>
    </div>
  </div>

  <div id="error-message" role="alert"></div>

  <!-- ===== Core JavaScript: Simplified and Fixed ===== -->
  <script type="module">
    // Simplified imports - match the pattern from other exercises
    const storage = {
      get: (key, defaultValue) => {
        try {
          const item = localStorage.getItem(key);
          return item ? JSON.parse(item) : defaultValue;
        } catch {
          return defaultValue;
        }
      },
      set: (key, value) => {
        try {
          localStorage.setItem(key, JSON.stringify(value));
        } catch (e) {
          console.error('Storage error:', e);
        }
      }
    };

    // Simple starfield generator
    const starfield = {
      generate: (container, count = 150) => {
        if (!container) return;
        container.innerHTML = '';
        for (let i = 0; i < count; i++) {
          const star = document.createElement('div');
          star.style.position = 'absolute';
          star.style.width = Math.random() * 3 + 'px';
          star.style.height = star.style.width;
          star.style.backgroundColor = 'white';
          star.style.borderRadius = '50%';
          star.style.left = Math.random() * 100 + '%';
          star.style.top = Math.random() * 100 + '%';
          star.style.opacity = Math.random() * 0.8 + 0.2;
          container.appendChild(star);
        }
      }
    };

    // Exercise metadata
    const EXERCISE_ID = 'maze';

    // DOM refs
    const starsContainer = document.getElementById('stars-container');
    const mazeContainer  = document.getElementById('maze-container');
    const gameContainer  = document.getElementById('game-container');
    const errorMessage   = document.getElementById('error-message');

    // Settings refs
    const difficultySelect   = document.getElementById('difficulty-select');
    const sessionDurationInp = document.getElementById('session-duration');
    const showTraceSelect    = document.getElementById('show-trace');

    // Controls
    const startBtn   = document.getElementById('start-session');
    const pauseBtn   = document.getElementById('pause-session');
    const restartBtn = document.getElementById('restart-session');

    // HUD refs
    const timerBarEl   = document.getElementById('timer-bar');
    const scoreEl      = document.getElementById('hud-score');
    const pbEl         = document.getElementById('hud-pb');
    const diffEl       = document.getElementById('hud-difficulty');
    const completedEl  = document.getElementById('hud-completed');
    const movesEl      = document.getElementById('hud-moves');
    const avgEl        = document.getElementById('hud-avg');
    const timeEl       = document.getElementById('hud-time');

    // Completion refs
    const completionModal = document.getElementById('completion-message');
    const finalCompleted  = document.getElementById('final-completed');
    const finalAvgTime    = document.getElementById('final-avg-time');
    const finalScore      = document.getElementById('final-score');
    const finalXP         = document.getElementById('final-xp');
    const completeClose   = document.getElementById('close-complete');
    const restartModalBtn = document.getElementById('restart-button');

    // Instructions
    const instructions = document.getElementById('instructions');

    // Stars!
    starfield.generate(starsContainer, 150);

    // State
    let isSessionActive = false;
    let isPaused = false;
    let sessionMs = 5 * 60 * 1000;
    let timeRemaining = 0;
    let timerInterval = null;

    let player = null, goal = null, startLabel = null, endLabel = null;
    let maze = [], pathNodes = [], pathTraces = [];
    let mazeWidth = 600, mazeHeight = 400;
    let cellSize = 60, wallThickness = 12;
    let currentDifficulty = 'easy';
    let showTrace = true;

    // Session stats
    let mazesCompleted = 0;
    let currentMaze = 1;
    let totalCompletionTime = 0;
    let mazeStartTime = 0;
    let score = 0;
    let personalBest = storage.get('mazePersonalBest', 0);
    let moveCountThisMaze = 0;

    // Event handler registry for cleanup
    const eventHandlers = { keydown:null, mousedown:null, touchstart:null, mousemove:null, touchmove:null, mouseup:null, touchend:null };

    // Difficulty settings
    const difficultySizes = {
      easy:   { cellSize: 60, wallThickness: 12 },
      medium: { cellSize: 45, wallThickness: 10 },
      hard:   { cellSize: 30, wallThickness:  8 }
    };

    // Initialize
    function getCurrentDifficulty() { return difficultySelect?.value || 'easy'; }
    
    difficultySelect.addEventListener('change', () => {
      diffEl.textContent = getCurrentDifficulty();
    });

    // Responsive maze size with debounce
    let resizeTimeout;
    function adjustMazeSize() {
      const ww = window.innerWidth, wh = window.innerHeight;
      mazeWidth = Math.min(600, ww * .9);
      mazeHeight = (ww <= 768) ? Math.min(400, wh * .6) : Math.min(400, wh * .6);
      mazeContainer.style.width  = `${mazeWidth}px`;
      mazeContainer.style.height = `${mazeHeight}px`;
    }
    adjustMazeSize();
    
    window.addEventListener('resize', () => {
      adjustMazeSize();
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        // Only rebuild when paused or not active to avoid disrupting gameplay
        if (!isSessionActive || isPaused) {
          generateMaze();
        }
      }, 150);
    });

    // Persist settings
    function saveSettings() {
      storage.set('mazeSessionDuration', sessionDurationInp.value);
      storage.set('mazeDifficulty', difficultySelect.value);
      storage.set('mazeShowTrace', showTraceSelect.value);
    }
    function loadSettings() {
      sessionDurationInp.value = storage.get('mazeSessionDuration', 5);
      difficultySelect.value   = storage.get('mazeDifficulty', 'easy');
      showTraceSelect.value    = storage.get('mazeShowTrace', 'yes');
      diffEl.textContent       = difficultySelect.value;
    }
    loadSettings();

    // HUD updates
    function updateHUD() {
      scoreEl.textContent = `${score}`;
      pbEl.textContent    = `${personalBest}`;
      completedEl.textContent = `${mazesCompleted}`;
      movesEl.textContent = `${moveCountThisMaze}`;

      const avg = (mazesCompleted > 0)
        ? (totalCompletionTime / mazesCompleted / 1000).toFixed(1) : '0.0';
      avgEl.textContent = `${avg}s`;

      const mins = Math.max(0, Math.floor(timeRemaining / 60000));
      const secs = Math.max(0, Math.floor((timeRemaining % 60000) / 1000));
      timeEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Error toast
    function showError(msg) {
      errorMessage.textContent = msg;
      errorMessage.style.display = 'block';
      setTimeout(() => errorMessage.style.display = 'none', 3000);
    }

    // ===== Session Flow =====
    startBtn.addEventListener('click', () => {
      if (isSessionActive) return; // Guard against multiple starts
      if (timerInterval) stopTimer(); // Belt-and-braces cleanup
      
      try {
        currentDifficulty = getCurrentDifficulty();
        
        // Validate and clamp duration
        const mins = Math.max(1, Math.min(10, Number(sessionDurationInp.value) || 5));
        sessionMs = mins * 60 * 1000;
        sessionDurationInp.value = mins; // Normalize UI
        
        showTrace = showTraceSelect.value === 'yes';
        saveSettings();

        // Reset state
        score = 0;
        mazesCompleted = 0;
        currentMaze = 1;
        totalCompletionTime = 0;
        timeRemaining = sessionMs;
        moveCountThisMaze = 0;
        isPaused = false;

        clearMaze(true);
        updateHUD();

        // Timer
        isSessionActive = true;
        startTimer();

        // Maze
        generateMaze();
        mazeStartTime = Date.now();

        // Focus for keyboard play
        mazeContainer.focus();
      } catch (e) {
        console.error(e);
        showError('Failed to start session: ' + e.message);
      }
    });

    pauseBtn.addEventListener('click', () => {
      if (!isSessionActive) return;
      isPaused = !isPaused;
      pauseBtn.setAttribute('aria-pressed', String(isPaused));
      pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
      if (isPaused) {
        stopTimer();
      } else {
        startTimer();
        mazeContainer.focus();
      }
    });

    restartBtn.addEventListener('click', () => {
      // Restart current session with same settings
      if (timerInterval) stopTimer();
      isSessionActive = false;
      isPaused = false;
      startBtn.click();
    });

    restartModalBtn.addEventListener('click', () => {
      completionModal.classList.remove('show');
      startBtn.click();
    });
    completeClose.addEventListener('click', () => {
      completionModal.classList.remove('show');
    });

    function startTimer() {
      // visual timer bar via transform (0..1)
      timerInterval = setInterval(() => {
        timeRemaining -= 100;
        const progress = Math.max(0, timeRemaining / sessionMs);
        timerBarEl.style.transform = `scaleX(${progress})`;
        updateHUD();
        if (timeRemaining <= 0) {
          endSession();
        }
      }, 100);
    }
    function stopTimer() {
      clearInterval(timerInterval);
      timerInterval = null;
    }

    // ===== Maze generation and play =====
    function clearMaze(skipHandlers = false) {
      if (!skipHandlers) removeAllEventListeners();
      while (mazeContainer.firstChild) mazeContainer.removeChild(mazeContainer.firstChild);
      pathTraces = [];
      pathNodes = [];
      player = goal = startLabel = endLabel = null;
    }

    function removeAllEventListeners() {
      if (eventHandlers.keydown)   { mazeContainer.removeEventListener('keydown', eventHandlers.keydown);   eventHandlers.keydown=null; }
      if (player) {
        if (eventHandlers.mousedown){ player.removeEventListener('mousedown', eventHandlers.mousedown); eventHandlers.mousedown=null; }
        if (eventHandlers.touchstart){ player.removeEventListener('touchstart', eventHandlers.touchstart); eventHandlers.touchstart=null; }
      }
      if (eventHandlers.mousemove) { document.removeEventListener('mousemove', eventHandlers.mousemove); eventHandlers.mousemove=null; }
      if (eventHandlers.touchmove) { document.removeEventListener('touchmove', eventHandlers.touchmove); eventHandlers.touchmove=null; }
      if (eventHandlers.mouseup)   { document.removeEventListener('mouseup',   eventHandlers.mouseup);   eventHandlers.mouseup=null; }
      if (eventHandlers.touchend)  { document.removeEventListener('touchend',  eventHandlers.touchend);  eventHandlers.touchend=null; }
    }

    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }

    function getUnvisitedNeighbors(x, y) {
      const n = [];
      const rows = maze.length, cols = maze[0].length;
      const dirs = shuffle([{dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}]);
      for (const d of dirs) {
        const nx = x + d.dx, ny = y + d.dy;
        if (nx>=0 && nx<cols && ny>=0 && ny<rows && !maze[ny][nx].visited) n.push({x:nx,y:ny});
      }
      return n;
    }

    function createMazeWalls(cols, rows) {
      const addWall = (top,left,w,h) => {
        const el = document.createElement('div');
        el.className = 'maze-wall';
        el.style.top = `${top}px`; el.style.left = `${left}px`;
        el.style.width = `${w}px`; el.style.height = `${h}px`;
        mazeContainer.appendChild(el);
      };
      // Outer walls
      addWall(0, 0, cols*cellSize, wallThickness); // top
      addWall(0, 0, wallThickness, rows*cellSize); // left
      addWall(0, cols*cellSize - wallThickness, wallThickness, rows*cellSize); // right
      addWall(rows*cellSize - wallThickness, 0, cols*cellSize, wallThickness); // bottom

      // Inner
      for (let i=0;i<rows;i++){
        for (let j=0;j<cols;j++){
          const c = maze[i][j];
          if (c.walls.right && j<cols-1) addWall(i*cellSize, (j+1)*cellSize - wallThickness/2, wallThickness, cellSize);
          if (c.walls.bottom && i<rows-1) addWall((i+1)*cellSize - wallThickness/2, j*cellSize, cellSize, wallThickness);
        }
      }
    }

    function connectPathNodes(cols, rows) {
      for (let y=0;y<rows;y++){
        for (let x=0;x<cols;x++){
          const idx = pathNodes.findIndex(n => n.gridX===x && n.gridY===y);
          if (idx === -1) continue;
          const cur = pathNodes[idx];
          if (x>0 && !maze[y][x].walls.left){
            const li = pathNodes.findIndex(n => n.gridX===x-1 && n.gridY===y);
            if (li!==-1 && !cur.connections.includes(li)){ cur.connections.push(li); pathNodes[li].connections.push(idx); }
          }
          if (x<cols-1 && !maze[y][x].walls.right){
            const ri = pathNodes.findIndex(n => n.gridX===x+1 && n.gridY===y);
            if (ri!==-1 && !cur.connections.includes(ri)){ cur.connections.push(ri); pathNodes[ri].connections.push(idx); }
          }
          if (y>0 && !maze[y][x].walls.top){
            const ti = pathNodes.findIndex(n => n.gridX===x && n.gridY===y-1);
            if (ti!==-1 && !cur.connections.includes(ti)){ cur.connections.push(ti); pathNodes[ti].connections.push(idx); }
          }
          if (y<rows-1 && !maze[y][x].walls.bottom){
            const bi = pathNodes.findIndex(n => n.gridX===x && n.gridY===y+1);
            if (bi!==-1 && !cur.connections.includes(bi)){ cur.connections.push(bi); pathNodes[bi].connections.push(idx); }
          }
        }
      }
    }

    function createPathLines(cols, rows) {
      for (let i=0;i<rows;i++){
        for (let j=0;j<cols;j++){
          const cx = j*cellSize + cellSize/2;
          const cy = i*cellSize + cellSize/2;
          const node = { x:cx,y:cy, gridX:j, gridY:i, connections:[] };
          pathNodes.push(node);
          const ne = document.createElement('div');
          ne.className='path-node'; ne.style.left=`${cx}px`; ne.style.top=`${cy}px`;
          mazeContainer.appendChild(ne);
        }
      }
      connectPathNodes(cols, rows);

      // draw lines
      for (let i=0;i<pathNodes.length;i++){
        const a = pathNodes[i];
        for (const idx of a.connections){
          if (i<idx){
            const b = pathNodes[idx];
            const line = document.createElement('div');
            line.className = 'path-line';
            if (a.gridX === b.gridX) {
              // vertical
              line.classList.add('vertical');
              const top = Math.min(a.y,b.y), h = Math.abs(a.y-b.y);
              line.style.left = `${a.x}px`; line.style.top=`${top}px`; line.style.height=`${h}px`;
            } else {
              // horizontal
              line.classList.add('horizontal');
              const left = Math.min(a.x,b.x), w = Math.abs(a.x-b.x);
              line.style.left = `${left}px`; line.style.top=`${a.y}px`; line.style.width=`${w}px`;
            }
            mazeContainer.appendChild(line);
          }
        }
      }
    }

    function createPlayer(x, y) {
      player = document.createElement('div');
      player.id = 'player';
      const w = Math.max(cellSize * 0.75, 24);
      const h = Math.max(cellSize * 0.85, 28);
      player.style.width = `${w}px`;
      player.style.height = `${h}px`;
      const px = x*cellSize + cellSize/2, py = y*cellSize + cellSize/2;
      player.style.left = `${px}px`; player.style.top = `${py}px`;
      mazeContainer.appendChild(player);
    }

    function createGoal(x, y) {
      goal = document.createElement('div');
      goal.id = 'goal';
      const px = x*cellSize + cellSize/2, py = y*cellSize + cellSize/2;
      goal.style.left = `${px}px`; goal.style.top = `${py}px`;
      goal.style.width = `${cellSize * 0.7}px`;
      goal.style.height= `${cellSize * 0.7}px`;
      mazeContainer.appendChild(goal);
    }

    function createPointLabels(sx, sy, ex, ey) {
      startLabel = document.createElement('div');
      startLabel.id='start-label'; startLabel.className='point-label'; startLabel.textContent='START';
      startLabel.style.left = `${sx*cellSize + cellSize/2}px`;
      startLabel.style.top  = `${sy*cellSize - 15}px`;

      endLabel = document.createElement('div');
      endLabel.id='end-label'; endLabel.className='point-label'; endLabel.textContent='FINISH';
      endLabel.style.left = `${ex*cellSize + cellSize/2}px`;
      endLabel.style.top  = `${ey*cellSize + cellSize + 15}px`;

      mazeContainer.appendChild(startLabel);
      mazeContainer.appendChild(endLabel);
    }

    function generateMaze() {
      // Difficulty dimensions
      const dims = difficultySizes[currentDifficulty] || difficultySizes.easy;
      cellSize = dims.cellSize; wallThickness = dims.wallThickness;

      // Grid
      const cols = Math.max(2, Math.floor(mazeWidth / cellSize));
      const rows = Math.max(2, Math.floor(mazeHeight / cellSize));

      clearMaze(true);
      maze = [];

      for (let i=0;i<rows;i++){
        const row=[];
        for (let j=0;j<cols;j++){
          row.push({ x:j,y:i,visited:false, walls:{top:true,right:true,bottom:true,left:true} });
        }
        maze.push(row);
      }

      // DFS carve
      const stack = [];
      let x=0,y=0;
      maze[y][x].visited=true; stack.push({x,y});
      while (stack.length>0){
        const cur = stack[stack.length-1];
        const neigh = getUnvisitedNeighbors(cur.x, cur.y);
        if (neigh.length===0) { stack.pop(); continue; }
        const nxt = neigh[Math.floor(Math.random()*neigh.length)];
        // knock walls
        if (nxt.x>cur.x){ maze[cur.y][cur.x].walls.right=false; maze[nxt.y][nxt.x].walls.left=false; }
        else if (nxt.x<cur.x){ maze[cur.y][cur.x].walls.left=false; maze[nxt.y][nxt.x].walls.right=false; }
        else if (nxt.y>cur.y){ maze[cur.y][cur.x].walls.bottom=false; maze[nxt.y][nxt.x].walls.top=false; }
        else if (nxt.y<cur.y){ maze[cur.y][cur.x].walls.top=false; maze[nxt.y][nxt.x].walls.bottom=false; }
        maze[nxt.y][nxt.x].visited=true; stack.push(nxt);
      }

      // visuals
      createMazeWalls(cols, rows);
      createPathLines(cols, rows);
      createPlayer(0,0);
      createGoal(cols-1, rows-1);
      createPointLabels(0,0, cols-1, rows-1);

      // movement
      setupPlayerMovement();
      // reset per-maze counters
      moveCountThisMaze = 0;
      updateHUD();
    }

    function findPath(startIndex, targetIndex) {
      if (startIndex === targetIndex) return [startIndex];
      const visited = new Set();
      const q = [[startIndex]];
      while (q.length){
        const p = q.shift();
        const cur = p[p.length-1];
        if (cur===targetIndex) return p;
        if (!visited.has(cur)){
          visited.add(cur);
          for (const nxt of pathNodes[cur].connections){
            if (!visited.has(nxt)) q.push([...p, nxt]);
          }
        }
      }
      return [];
    }

    function setupPlayerMovement() {
      if (!player || !pathNodes.length) return;

      let playerX = parseFloat(player.style.left);
      let playerY = parseFloat(player.style.top);
      let closestNodeIndex = 0;
      let isDragging = false;
      let dragPath = [];
      let lastVisitedNode = 0;

      function updateClosestNodeIndex() {
        let min = Infinity;
        for (let i=0;i<pathNodes.length;i++){
          const n = pathNodes[i];
          const dx = n.x - playerX, dy = n.y - playerY;
          const d = Math.hypot(dx,dy);
          if (d<min){ min=d; closestNodeIndex=i; }
        }
      }
      updateClosestNodeIndex();

      function addPathTrace(fromX, fromY, toX, toY) {
        if (!showTrace) return;
        const trace = document.createElement('div');
        trace.className = 'path-trace';
        const cx = (fromX+toX)/2, cy=(fromY+toY)/2;
        const w = Math.abs(toX-fromX)+10, h=Math.abs(toY-fromY)+10;
        trace.style.left=`${cx-w/2}px`; trace.style.top=`${cy-h/2}px`;
        trace.style.width=`${w}px`; trace.style.height=`${h}px`;
        mazeContainer.appendChild(trace);
        pathTraces.push(trace);
      }

      function checkGoalReached() {
        const gx = parseFloat(goal.style.left), gy = parseFloat(goal.style.top);
        const d = Math.hypot(playerX-gx, playerY-gy);
        const r = parseFloat(goal.style.width)/2;
        if (d < r) {
          // Celebrate!
          mazeContainer.classList.add('maze-celebrate');
          setTimeout(()=>mazeContainer.classList.remove('maze-celebrate'), 900);
          completeCurrentMaze();
        }
      }

      function moveToNode(nodeIndex) {
        if (nodeIndex<0 || nodeIndex>=pathNodes.length) return;
        const target = pathNodes[nodeIndex];
        addPathTrace(playerX, playerY, target.x, target.y);
        playerX = target.x; playerY = target.y;
        player.style.left = `${playerX}px`;
        player.style.top  = `${playerY}px`;
        closestNodeIndex = nodeIndex;
        moveCountThisMaze++;
        updateHUD();
        checkGoalReached();
      }

      function keyHandler(e) {
        if (!isSessionActive || isPaused) return;
        const cur = pathNodes[closestNodeIndex];
        let next = -1;
        switch (e.key) {
          case 'ArrowUp':
            next = cur.connections.find(i => pathNodes[i].y < cur.y && pathNodes[i].x === cur.x); break;
          case 'ArrowDown':
            next = cur.connections.find(i => pathNodes[i].y > cur.y && pathNodes[i].x === cur.x); break;
          case 'ArrowLeft':
            next = cur.connections.find(i => pathNodes[i].x < cur.x && pathNodes[i].y === cur.y); break;
          case 'ArrowRight':
            next = cur.connections.find(i => pathNodes[i].x > cur.x && pathNodes[i].y === cur.y); break;
          default:
            return;
        }
        if (next !== undefined && next !== -1) {
          moveToNode(next);
          e.preventDefault();
        }
      }

      function startDrag(e) {
        if (!isSessionActive || isPaused) return;
        isDragging = true;
        dragPath = [closestNodeIndex];
        lastVisitedNode = closestNodeIndex;
        player.style.boxShadow = '0 0 30px rgba(111, 211, 245, 1)';
        e.preventDefault();
      }

      function drag(e) {
        if (!isDragging || !isSessionActive || isPaused) return;
        const rect = mazeContainer.getBoundingClientRect();
        let cx, cy;
        if (e.type === 'mousemove') { cx = e.clientX - rect.left; cy = e.clientY - rect.top; }
        else { cx = e.touches[0].clientX - rect.left; cy = e.touches[0].clientY - rect.top; e.preventDefault(); }

        const cur = pathNodes[closestNodeIndex];
        const toCheck = new Set([closestNodeIndex, ...cur.connections.flatMap(i => [i, ...pathNodes[i].connections])]);
        let best=-1, min=Infinity;

        for (const idx of toCheck) {
          const n = pathNodes[idx];
          const d = Math.hypot(n.x-cx, n.y-cy) + (dragPath.includes(idx) ? cellSize*0.5 : 0);
          if (d < min && idx !== lastVisitedNode) { min=d; best=idx; }
        }
        if (best !== -1 && min < cellSize*0.7) {
          const path = findPath(closestNodeIndex, best);
          if (path.length){
            for (let i=1;i<path.length;i++){
              const ni = path[i];
              if (!dragPath.includes(ni)) dragPath.push(ni);
              moveToNode(ni);
              lastVisitedNode = ni;
            }
          }
        }
      }

      function endDrag() {
        isDragging = false;
        player.style.boxShadow = '0 0 20px rgba(111, 211, 245, 0.8)';
        dragPath = [];
        lastVisitedNode = closestNodeIndex;
      }

      eventHandlers.keydown    = keyHandler;
      eventHandlers.mousedown  = startDrag;
      eventHandlers.touchstart = startDrag;
      eventHandlers.mousemove  = drag;
      eventHandlers.touchmove  = drag;
      eventHandlers.mouseup    = endDrag;
      eventHandlers.touchend   = endDrag;

      mazeContainer.addEventListener('keydown', eventHandlers.keydown);
      player.addEventListener('mousedown', eventHandlers.mousedown);
      player.addEventListener('touchstart', eventHandlers.touchstart, { passive: false });
      document.addEventListener('mousemove', eventHandlers.mousemove);
      document.addEventListener('touchmove', eventHandlers.touchmove, { passive: false });
      document.addEventListener('mouseup',   eventHandlers.mouseup);
      document.addEventListener('touchend',  eventHandlers.touchend);
    }

    function completeCurrentMaze() {
      const ms = Date.now() - mazeStartTime;
      totalCompletionTime += ms;
      mazesCompleted++;
      currentMaze++;
      // Simple score: better with faster avg time
      const avg = (totalCompletionTime / mazesCompleted / 1000) || 1;
      score = Math.max(score, Math.round((mazesCompleted * 100) / avg));
      updateHUD();

      // New maze
      generateMaze();
      mazeStartTime = Date.now();
    }

    // ===== Session End =====
    function endSession() {
      if (timerInterval) stopTimer();
      isSessionActive = false;

      // Compute final stats
      const avgStr = (mazesCompleted > 0) ? (totalCompletionTime / mazesCompleted / 1000).toFixed(1) : '0.0';
      const avg = parseFloat(avgStr);
      const computedScore = Math.round((mazesCompleted * 100) / (avg > 0 ? avg : 1));

      // Update PB
      if (computedScore > personalBest) {
        personalBest = computedScore;
        storage.set('mazePersonalBest', personalBest);
      }
      updateHUD();

      // Completion modal + XP line
      finalCompleted.textContent = `${mazesCompleted}`;
      finalAvgTime.textContent   = `${avgStr}s`;
      finalScore.textContent     = `${computedScore}`;
      finalXP.textContent        = `${Math.max(10, Math.round(computedScore * 0.5))}`;
      completionModal.classList.add('show');

      // Clean up maze elements
      clearMaze();
    }

    // Accessibility / mobile tweaks
    document.addEventListener('touchstart', e => { if (e.touches.length>1) e.preventDefault(); }, { passive:false });
    let lastTouchEnd = 0;
    document.addEventListener('touchend', e => { const now=Date.now(); if (now-lastTouchEnd<=300) e.preventDefault(); lastTouchEnd=now; }, false);
    document.addEventListener('touchmove', e => { if (isSessionActive && !isPaused) e.preventDefault(); }, { passive:false });
    document.addEventListener('contextmenu', e => e.preventDefault());

    window.addEventListener('beforeunload', () => { if (timerInterval) stopTimer(); removeAllEventListeners(); });
  </script>

<script id="maze-immersive-js">
(function(){
  // Set mobile viewport custom unit
  function setVH(){ document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px'); }
  setVH(); window.addEventListener('resize', setVH, {passive:true});

  // Elements that already exist in Maze
  var startBtn = document.getElementById('start-session');
  var closeBtn = document.getElementById('close-complete') || document.querySelector('#completion-message [data-close], #completion-message .close');
  var completion = document.getElementById('completion-message');

  function enterPlaying(){ document.body.classList.add('playing'); }
  function exitPlaying(){ document.body.classList.remove('playing'); }

  // Enter immersive *after* game start handler finishes (2 RAFs avoids racing the game's start)
  if (startBtn) {
    startBtn.addEventListener('click', function(){
      requestAnimationFrame(function(){ requestAnimationFrame(enterPlaying); });
    }, {capture:false});
  }

  // Exit immersive when user closes completion
  if (closeBtn) {
    closeBtn.addEventListener('click', exitPlaying);
  }

  // Also watch the completion modal become visible (covers programmatic opens)
  if (completion && 'MutationObserver' in window) {
    var mo = new MutationObserver(function(){
      var open = completion.classList.contains('show') || completion.style.display === 'block';
      if (open) exitPlaying();
    });
    mo.observe(completion, {attributes:true, attributeFilter:['class','style']});
  }

  // Let Esc exit immersive without affecting gameplay
  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape') exitPlaying();
  });
})();
</script>

</body>
</html>