<!DOCTYPE html>
<html lang="en">
<head>
  <!-- BUILD: Cosmic Maze — Standalone immersive v2 (layout-safe) — 2025-09-18 -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Cosmic Maze — Fine Motor Skills Rehabilitation | Fine Point Rehab</title>
  <meta name="description" content="Guide the spaceship through a procedurally generated maze. Immersive, mobile-friendly, and self-contained." />

  <style>
    :root {
      --vh: 1vh;
      --bg-1: #070b16;
      --bg-2: #0f1630;
      --bg-3: #0b1024;
      --accent: #6fd3f5;
      --accent-soft: rgba(111,211,245,.15);
      --panel: rgba(10,16,36,.9);
      --panel-border: rgba(255,255,255,.08);
      --text: #eaf6ff;
      --muted: #a7c1d6;
      --radius: 14px;
    }

    * { box-sizing: border-box; }

    html, body { height: 100%; }

    body {
      margin: 0;
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 20% 25%, rgba(70,30,120,.35), transparent 60%),
        radial-gradient(900px 700px at 75% 65%, rgba(20,80,160,.25), transparent 55%),
        linear-gradient(180deg, var(--bg-2), var(--bg-1) 50%, var(--bg-3));
      min-height: calc(var(--vh) * 100);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height: 1.5;
      overflow: hidden;
    }

    header.app {
      position: fixed;
      inset: 0 0 auto 0;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 16px;
      z-index: 30;
      background: linear-gradient(180deg, rgba(5,8,18,.85), rgba(5,8,18,.35) 80%, transparent);
      -webkit-backdrop-filter: blur(6px);
      backdrop-filter: blur(6px);
      border-bottom: 1px solid var(--panel-border);
    }

    header .home {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 36px;
      padding: 0 14px;
      border-radius: 999px;
      text-decoration: none;
      color: var(--text);
      background: rgba(255,255,255,.06);
      border: 1px solid var(--panel-border);
    }

    header h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: .4px;
      font-weight: 650;
      color: #dff4ff;
      text-shadow: 0 1px 12px rgba(111,211,245,.35);
    }

    main.layout {
      position: relative;
      display: grid;
      grid-template-rows: 1fr;
      gap: 12px;
      height: calc(var(--vh) * 100);
      padding: 64px 12px 12px;
    }

    .panel {
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: var(--radius);
      box-shadow: 0 10px 50px rgba(0,0,0,.45);
    }

    #settings.panel {
      max-width: 980px;
      margin: 0 auto;
      padding: 16px;
    }

    .settings-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 14px;
    }

    .group {
      display: grid;
      gap: 6px;
      background: rgba(255,255,255,.02);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 12px;
    }

    .label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .6px;
      color: var(--muted);
    }

    input[type="number"], select {
      width: 100%;
      background: rgba(5,12,28,.7);
      color: var(--text);
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      padding: 10px 12px;
    }

    .settings-actions {
      margin-top: 10px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 44px;
      padding: 0 16px;
      border-radius: 12px;
      border: 1px solid var(--panel-border);
      background: rgba(255,255,255,.05);
      color: var(--text);
      cursor: pointer;
      user-select: none;
    }
    .btn-primary {
      background: linear-gradient(180deg, #39b8e5, #0780a8);
      border-color: rgba(0,0,0,.25);
      color: #001018;
      font-weight: 700;
      text-shadow: 0 1px 0 rgba(255,255,255,.25);
    }
    .btn-ghost {
      background: rgba(255,255,255,.08);
    }

    .stats-row {
      display: grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 10px;
      margin: 8px 0 4px;
    }
    .metric {
      display: grid;
      place-items: center;
      padding: 10px;
      border-radius: 10px;
      background: rgba(255,255,255,.04);
      border: 1px solid var(--panel-border);
      min-height: 70px;
    }
    .v { font-size: 22px; font-weight: 800; letter-spacing: .5px; }
    .t { font-size: 11px; color: var(--muted); text-transform: uppercase; letter-spacing: .7px; }

    /* HUD */
    .hud {
      position: fixed;
      inset: 56px 0 auto 0;
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(0, 1fr);
      gap: 10px;
      padding: 6px 12px;
      z-index: 25;
      pointer-events: none;
    }
    .hud .pill {
      pointer-events: auto;
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 8px;
      align-items: center;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid var(--panel-border);
      background: rgba(10,16,36,.8);
      backdrop-filter: blur(6px);
    }
    .hud .k { font-size: 11px; color: var(--muted); text-transform: uppercase; letter-spacing: .6px; }
    .hud .val { font-weight: 800; font-size: 16px; }

    /* Game frame */
    .frame.panel {
      position: relative;
      max-width: 1100px;
      height: min(70vh, 620px);
      margin: 0 auto;
      padding: 0;
      overflow: hidden;
    }

    #stars-container {
      position: absolute;
      inset: 0;
      z-index: 0;
    }
    #maze-container {
      position: absolute;
      inset: 0;
      margin: 60px 10px 10px;
      border-radius: 12px;
      background: radial-gradient(700px 400px at 80% 20%, rgba(111,211,245,.08), rgba(0,0,0,0) 60%),
                  rgba(4,8,20,.75);
      border: 1px solid var(--panel-border);
      overflow: hidden;
      z-index: 1;
      /* Give it a minimum height to avoid 0-height edge cases */
      min-height: 260px;
      min-width: 320px;
    }
    #maze-svg { width: 100%; height: 100%; display: block; }

    .instructions {
      position: absolute;
      inset: 12px auto auto 12px;
      z-index: 2;
      background: rgba(0,0,0,.35);
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      color: var(--muted);
    }

    /* Player & Goal */
    #player, #goal {
      position: absolute;
      width: 44px; height: 44px;
      border-radius: 50%;
      z-index: 3;
      display: grid; place-items: center;
      box-shadow: 0 6px 18px rgba(0,0,0,.45);
    }
    #player {
      background: radial-gradient(circle at 35% 30%, #ffe, #ffd34d 35%, #a06b00 70%);
      border: 1px solid rgba(0,0,0,.4);
    }
    #goal {
      border-radius: 10px;
      background: radial-gradient(circle at 50% 35%, #e5fff7, #3dd6a2 45%, #0a8c65 80%);
      border: 1px solid rgba(0,0,0,.35);
    }

    /* Celebration pulse */
    @keyframes celebrate {
      0% { box-shadow: 0 0 0 rgba(111,211,245,0); }
      40% { box-shadow: 0 0 40px rgba(111,211,245,.8); }
      100% { box-shadow: 0 0 20px rgba(111,211,245,.2); }
    }
    .maze-celebrate { animation: celebrate .5s ease; }

    /* Completion modal */
    #done {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0,0,0,.65);
      backdrop-filter: blur(4px);
      z-index: 10;
    }
    #doneCard { max-width: min(520px, 92vw); max-height: 80vh; overflow: auto; padding: 22px; }
    #done h2 { margin-top: 0; color: var(--accent); }
    .hi { color: #9ee7ff; font-weight: 900; }
    .hidden { display: none !important; }

    :focus-visible { outline: 3px solid rgba(111,211,245,.85); outline-offset: 2px; }

    @media (max-width: 768px) {
      .hud { font-size: 12px; }
      .v { font-size: 16px; }
      .t { font-size: 10px; }
      body.playing #maze-container { margin: 55px 5px 5px 5px; }
    }
    input, select, textarea, button { font-size: 16px; } /* prevent zoom on iOS */
    @supports (-webkit-touch-callout: none) { .layout { min-height: -webkit-fill-available; } }
  </style>
</head>

<body>
  <header class="app" role="banner">
    <a class="home" href="/">← Home</a>
    <h1>Cosmic Maze</h1>
  </header>

  <main class="layout">
    <!-- Settings Panel -->
    <section id="settings" class="panel">
      <h2 style="margin:8px 6px 10px 6px;">Settings</h2>
      <div class="settings-grid">
        <div class="group">
          <div class="label">Personal Best</div>
          <div id="pbSettings" class="v">0</div>
          <div class="t">Most mazes completed</div>
        </div>

        <div class="group">
          <label class="label" for="dur">Session Duration (minutes)</label>
          <input id="dur" type="number" min="1" step="0.5" max="20" value="5" />
        </div>

        <div class="group">
          <label class="label" for="difficulty">Difficulty</label>
          <select id="difficulty">
            <option value="easy" selected>Easy — wide paths</option>
            <option value="medium">Medium — standard paths</option>
            <option value="hard">Hard — narrow paths</option>
          </select>
        </div>
      </div>

      <div class="settings-actions">
        <div class="t">Drag the ship or use arrow keys. Reach the green goal.</div>
        <button id="start" class="btn btn-primary">Start Session</button>
      </div>
    </section>

    <!-- HUD -->
    <div class="hud">
      <div class="pill"><div class="k">Time</div><div id="time" class="val">05:00</div></div>
      <div class="pill"><div class="k">Score</div><div id="score" class="val">0</div></div>
      <div class="pill"><div class="k">Personal Best</div><div id="pb" class="val">0</div></div>
      <div class="pill" style="justify-self:end; gap:8px;">
        <button id="pauseHud" class="btn btn-ghost" style="height:32px;">Pause</button>
        <button id="exitHud"  class="btn btn-ghost" style="height:32px;">Exit</button>
      </div>
    </div>

    <!-- Game Frame -->
    <section class="frame panel" id="frame">
      <div id="stars-container"></div>
      <p class="instructions">Guide the spaceship through the maze to the green goal. Drag the ship or use arrow keys.</p>
      <div id="maze-container" tabindex="0">
        <!-- SVG maze goes here -->
      </div>

      <!-- Completion Modal -->
      <div id="done" class="hidden">
        <div id="doneCard" class="panel">
          <h2>Session Complete!</h2>
          <p>Mazes Completed: <span id="fCompleted" class="hi">0</span></p>
          <p>Average Time: <span id="fAvgTime" class="hi">0.0s</span></p>
          <p>Final Score: <span id="fScore" class="hi">0</span></p>
          <p>XP Earned: <span id="fXp" class="hi">0</span></p>
          <div class="settings-actions" style="grid-template-columns: 1fr 1fr;">
            <button id="doneBtn" class="btn btn-primary">New Session</button>
            <button id="homeBtn" class="btn">Home</button>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // --- Viewport height fix for mobile ---
    function setVH() { document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px'); }
    setVH();
    window.addEventListener('resize', setVH);
    window.addEventListener('orientationchange', () => setTimeout(setVH, 200));

    // --- Simple starfield ---
    (function makeStars(){
      const wrap = document.getElementById('stars-container');
      const frag = document.createDocumentFragment();
      for (let i=0;i<120;i++){
        const s = document.createElement('div');
        const size = Math.random() * 2 + 1;
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        s.style.cssText = 'position:absolute;border-radius:50%;opacity:'+ (Math.random()*0.7+0.2) +';'+
          'width:'+size+'px;height:'+size+'px;'+
          'left:'+x+'%;top:'+y+'%;background:#cfefff;';
        frag.appendChild(s);
      }
      wrap.appendChild(frag);
    })();

    // --- Game state ---
    let isPlaying = false;
    let isPaused = false;
    let sessionMs = 5 * 60 * 1000;
    let timeLeft = 0;
    let timerInterval = null;

    let score = 0;
    let mazesCompleted = 0;
    let totalCompletionTime = 0;
    let mazeStartTime = 0;

    let personalBest = parseInt(localStorage.getItem('maze_pb'), 10);
    if (isNaN(personalBest)) personalBest = 0;

    // --- DOM ---
    const startBtn = document.getElementById('start');
    const pauseBtn = document.getElementById('pauseHud');
    const exitBtn = document.getElementById('exitHud');
    const doneBtn = document.getElementById('doneBtn');
    const homeBtn = document.getElementById('homeBtn');

    const durInput = document.getElementById('dur');
    const difficultySelect = document.getElementById('difficulty');

    const scoreEl = document.getElementById('score');
    const pbEl = document.getElementById('pb');
    const pbSettingsEl = document.getElementById('pbSettings');
    const timeEl = document.getElementById('time');

    const frameEl = document.getElementById('frame');
    const mazeContainer = document.getElementById('maze-container');
    const doneModal = document.getElementById('done');

    let player = null;
    let goal = null;

    function formatTime(ms){
      const s = Math.max(0, Math.ceil(ms/1000));
      const m = Math.floor(s/60).toString().padStart(2,'0');
      const ss = (s%60).toString().padStart(2,'0');
      return m+':'+ss;
    }

    function updateHUD(){
      scoreEl.textContent = String(score);
      pbEl.textContent = String(personalBest);
      timeEl.textContent = formatTime(timeLeft);
    }

    function startTimer(){
      if (timerInterval) clearInterval(timerInterval);
      const start = performance.now();
      timerInterval = setInterval(()=>{
        if (!isPlaying || isPaused) return;
        const elapsed = performance.now() - start;
        timeLeft = Math.max(0, sessionMs - elapsed);
        timeEl.textContent = formatTime(timeLeft);
        if (timeLeft <= 0){
          clearInterval(timerInterval);
          endSession();
        }
      }, 250);
    }

    function beginSession(){
      // settings
      const mins = parseFloat(durInput.value) || 5;
      sessionMs = Math.min(20, Math.max(1, mins)) * 60 * 1000;
      isPlaying = true;
      isPaused = false;
      score = 0;
      mazesCompleted = 0;
      totalCompletionTime = 0;
      timeLeft = sessionMs;

      document.body.classList.add('playing');
      document.getElementById('settings').classList.add('hidden');
      doneModal.classList.add('hidden');
      updateHUD();

      // defer generation until layout has settled
      scheduleGenerateMaze();
      startTimer();
    }

    function endSession(){
      isPlaying = false;
      document.body.classList.remove('playing');
      // stats
      const avg = mazesCompleted ? (totalCompletionTime / mazesCompleted) : 0;
      document.getElementById('fCompleted').textContent = String(mazesCompleted);
      document.getElementById('fAvgTime').textContent = avg.toFixed(1)+'s';
      document.getElementById('fScore').textContent = String(score);
      const xp = Math.round(score/10);
      document.getElementById('fXp').textContent = String(xp);

      if (mazesCompleted > personalBest){
        personalBest = mazesCompleted;
        localStorage.setItem('maze_pb', String(personalBest));
      }
      pbEl.textContent = String(personalBest);
      pbSettingsEl.textContent = String(personalBest);

      doneModal.classList.remove('hidden');
    }

    function pauseSession(toggle){
      if (!isPlaying) return;
      isPaused = (toggle === undefined) ? !isPaused : !!toggle;
      pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
    }

    // --- Maze generation (recursive backtracker) ---
    function generateMaze(){
      // clear container
      mazeContainer.innerHTML = '';

      // measure with multiple fallbacks
      const rect = mazeContainer.getBoundingClientRect();
      let W = Math.floor(rect.width || mazeContainer.clientWidth || mazeContainer.offsetWidth || 0);
      let H = Math.floor(rect.height || mazeContainer.clientHeight || mazeContainer.offsetHeight || 0);

      if (W < 50 || H < 50){
        console.warn('[Maze] Container too small (W,H)=', W, H, 'retrying...');
        return false; // tell caller it failed
      }

      // difficulty -> cell size
      const diff = difficultySelect.value;
      const cell = (diff === 'easy') ? 56 : (diff === 'hard') ? 32 : 44;
      const cols = Math.max(3, Math.floor(W / cell));
      const rows = Math.max(3, Math.floor(H / cell));
      const pad = 10; // inner padding
      const wall = 4; // wall thickness

      // build grid of cells
      const grid = [];
      for (let y=0;y<rows;y++){
        const row = [];
        for (let x=0;x<cols;x++){
          row.push({x,y, visited:false, walls:[true,true,true,true]}); // top,right,bottom,left
        }
        grid.push(row);
      }
      function neigh(x,y){
        const list = [];
        if (y>0) list.push(grid[y-1][x]);           // up
        if (x<cols-1) list.push(grid[y][x+1]);      // right
        if (y<rows-1) list.push(grid[y+1][x]);      // down
        if (x>0) list.push(grid[y][x-1]);           // left
        return list;
      }
      function carve(a,b){
        if (a.x === b.x){
          if (a.y > b.y){ a.walls[0]=false; b.walls[2]=false; } else { a.walls[2]=false; b.walls[0]=false; }
        } else {
          if (a.x > b.x){ a.walls[3]=false; b.walls[1]=false; } else { a.walls[1]=false; b.walls[3]=false; }
        }
      }
      // DFS stack
      const stack = [];
      const start = grid[0][0];
      start.visited = true;
      stack.push(start);
      while (stack.length){
        const cur = stack[stack.length-1];
        const nbs = neigh(cur.x,cur.y).filter(c=>!c.visited);
        if (nbs.length === 0){ stack.pop(); continue; }
        const nxt = nbs[Math.floor(Math.random()*nbs.length)];
        carve(cur, nxt);
        nxt.visited = true;
        stack.push(nxt);
      }

      // draw SVG
      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.setAttribute('id','maze-svg');
      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
      svg.setAttribute('width', String(W));
      svg.setAttribute('height', String(H));
      svg.setAttribute('preserveAspectRatio', 'none');
      mazeContainer.appendChild(svg);

      // background grid glow
      const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
      const oxPad = 10;
      bg.setAttribute('x', oxPad); bg.setAttribute('y', oxPad);
      bg.setAttribute('width', Math.max(0, W - oxPad*2)); bg.setAttribute('height', Math.max(0, H - oxPad*2));
      bg.setAttribute('rx', 10);
      bg.setAttribute('fill', 'rgba(20,30,60,0.35)');
      bg.setAttribute('stroke', 'rgba(255,255,255,0.08)');
      svg.appendChild(bg);

      // draw cell walls
      const pathGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
      pathGroup.setAttribute('stroke', 'rgba(190,220,255,0.65)');
      pathGroup.setAttribute('stroke-width', String(wall));
      pathGroup.setAttribute('stroke-linecap', 'square');
      pathGroup.setAttribute('fill', 'none');
      svg.appendChild(pathGroup);

      const ox = oxPad + wall; // inner offset
      const oy = oxPad + wall;
      const step = ((W - oxPad*2) / cols);
      const stepY = ((H - oxPad*2) / rows);

      for (let y=0;y<rows;y++){
        for (let x=0;x<cols;x++){
          const c = grid[y][x];
          const x0 = ox + x*step;
          const y0 = oy + y*stepY;
          const x1 = x0 + step;
          const y1 = y0 + stepY;
          // top
          if (c.walls[0]){
            const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
            ln.setAttribute('x1', x0); ln.setAttribute('y1', y0);
            ln.setAttribute('x2', x1); ln.setAttribute('y2', y0);
            pathGroup.appendChild(ln);
          }
          // right
          if (c.walls[1]){
            const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
            ln.setAttribute('x1', x1); ln.setAttribute('y1', y0);
            ln.setAttribute('x2', x1); ln.setAttribute('y2', y1);
            pathGroup.appendChild(ln);
          }
          // bottom
          if (c.walls[2]){
            const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
            ln.setAttribute('x1', x0); ln.setAttribute('y1', y1);
            ln.setAttribute('x2', x1); ln.setAttribute('y2', y1);
            pathGroup.appendChild(ln);
          }
          // left
          if (c.walls[3]){
            const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
            ln.setAttribute('x1', x0); ln.setAttribute('y1', y0);
            ln.setAttribute('x2', x0); ln.setAttribute('y2', y1);
            pathGroup.appendChild(ln);
          }
        }
      }

      // place player and goal (centered within first/last cells)
      const playerX = ox + step*0.5;
      const playerY = oy + stepY*0.5;
      const goalX   = ox + (cols-0.5)*step - 22;
      const goalY   = oy + (rows-0.5)*stepY - 22;

      // goal
      const g = document.createElement('div');
      g.id = 'goal';
      g.style.left = goalX + 'px';
      g.style.top  = goalY + 'px';
      mazeContainer.appendChild(g);
      goal = g;

      // player
      const p = document.createElement('div');
      p.id = 'player';
      p.style.left = (playerX-22) + 'px';
      p.style.top  = (playerY-22) + 'px';
      mazeContainer.appendChild(p);
      player = p;

      // controls
      let dragging = false;
      function moveTo(clientX, clientY){
        const r = mazeContainer.getBoundingClientRect();
        const x = Math.min(r.right - 5, Math.max(r.left + 5, clientX)) - r.left;
        const y = Math.min(r.bottom - 5, Math.max(r.top + 5, clientY)) - r.top;
        player.style.left = (x-22) + 'px';
        player.style.top  = (y-22) + 'px';
        // goal check
        const dx = (x-22) - parseFloat(goal.style.left);
        const dy = (y-22) - parseFloat(goal.style.top);
        if (Math.hypot(dx, dy) < 30) {
          // one maze done
          mazesCompleted += 1;
          score += 100;
          totalCompletionTime += Math.min(999, (performance.now() - (mazeStartTime || performance.now())) / 1000);
          updateHUD();
          mazeContainer.classList.add('maze-celebrate');
          setTimeout(()=>mazeContainer.classList.remove('maze-celebrate'), 500);
          mazeStartTime = performance.now();
          scheduleGenerateMaze(true);
        }
      }
      p.addEventListener('mousedown', (e)=>{ if(!isPlaying||isPaused) return; dragging = true; e.preventDefault(); });
      document.addEventListener('mouseup', ()=> dragging=false);
      document.addEventListener('mousemove', (e)=>{ if (dragging) moveTo(e.clientX, e.clientY); });

      p.addEventListener('touchstart', (e)=>{ if(!isPlaying||isPaused) return; dragging = true; e.preventDefault(); }, {passive:false});
      document.addEventListener('touchend', ()=> dragging=false, {passive:false});
      document.addEventListener('touchmove', (e)=>{
        if (!dragging) return;
        const t = e.touches[0];
        moveTo(t.clientX, t.clientY);
      }, {passive:false});

      // keyboard
      mazeStartTime = performance.now();
      mazeContainer.tabIndex = 0;
      mazeContainer.focus();
      mazeContainer.addEventListener('keydown', (e)=>{
        if (!isPlaying || isPaused) return;
        const stepPix = 6;
        const left = parseFloat(player.style.left);
        const top  = parseFloat(player.style.top);
        if (e.key === 'ArrowLeft')  player.style.left = (left - stepPix) + 'px';
        if (e.key === 'ArrowRight') player.style.left = (left + stepPix) + 'px';
        if (e.key === 'ArrowUp')    player.style.top  = (top  - stepPix) + 'px';
        if (e.key === 'ArrowDown')  player.style.top  = (top  + stepPix) + 'px';
        // re-check goal
        const dx = parseFloat(player.style.left) - parseFloat(goal.style.left);
        const dy = parseFloat(player.style.top)  - parseFloat(goal.style.top);
        if (Math.hypot(dx, dy) < 30) {
          mazesCompleted += 1;
          score += 100;
          totalCompletionTime += Math.min(999, (performance.now() - (mazeStartTime || performance.now())) / 1000);
          updateHUD();
          mazeContainer.classList.add('maze-celebrate');
          setTimeout(()=>mazeContainer.classList.remove('maze-celebrate'), 500);
          mazeStartTime = performance.now();
          scheduleGenerateMaze(true);
        }
      });

      return true; // success
    }

    // Generate after a frame; retry up to N times if size is 0
    let genAttempts = 0;
    function scheduleGenerateMaze(isRetry=false){
      requestAnimationFrame(()=>{
        const ok = generateMaze();
        if (!ok){
          genAttempts++;
          if (genAttempts < 10){
            // Try again after a tick; also force a min-size style in case layout is collapsing
            mazeContainer.style.minHeight = '300px';
            mazeContainer.style.minWidth = '320px';
            setTimeout(()=>scheduleGenerateMaze(true), 50);
          } else {
            console.error('[Maze] Failed to render after retries. Check container sizing/CSS.');
          }
        } else {
          genAttempts = 0;
        }
      });
    }

    // Regenerate maze on resize/orientation (if playing)
    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      if (!isPlaying || isPaused) return;
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=> scheduleGenerateMaze(true), 150);
    });

    function endToHome(){ window.location.href = '/'; }

    // --- Wire up buttons ---
    startBtn?.addEventListener('click', beginSession);
    pauseBtn?.addEventListener('click', ()=> pauseSession());
    exitBtn?.addEventListener('click', ()=>{
      isPlaying = false;
      clearInterval(timerInterval);
      document.getElementById('settings').classList.remove('hidden');
      doneModal.classList.add('hidden');
      document.body.classList.remove('playing');
      timeLeft = 0;
      updateHUD();
    });
    doneBtn?.addEventListener('click', ()=>{
      document.getElementById('settings').classList.remove('hidden');
      doneModal.classList.add('hidden');
    });
    homeBtn?.addEventListener('click', endToHome);

    // initial PB display
    pbEl.textContent = String(personalBest);
    pbSettingsEl.textContent = String(personalBest);
    timeEl.textContent = formatTime(sessionMs);

    // Debug helper
    window.addEventListener('error', e => console.error('[Maze JS Error]:', e.message));
  </script>
</body>
</html>
