<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Cosmic Maze — Fine Motor Skills Rehabilitation</title>

  <style>
    :root {
      --bg-primary: #0f1629;
      --bg-secondary: #1a1f3a;
      --bg-tertiary: #252b47;
      --text-primary: #e8eef5;
      --text-secondary: #b8c5d1;
      --text-muted: #8a96a3;
      --brand-aqua: #6fd3f5;
      --success: #4caf50;
      --error: #ff6b6b;
      --error-bg: #2d1b1b;
      --border: #374151;
      --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.3);
      --radius: 8px;
      --radius-lg: 12px;
      --radius-xl: 16px;
      --radius-full: 50%;
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-6: 24px;
      --font-size-xs: 12px;
      --font-size-base: 16px;
      --font-size-lg: 20px;
      --font-size-xl: 24px;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;
      --duration-fast: 150ms;
      --easing: cubic-bezier(0.4, 0, 0.2, 1);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(180deg, #0a0e1a 0%, #1a1f3a 50%, #0f1524 100%);
      color: var(--text-primary);
      min-height: 100vh;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-4);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      font-size: var(--font-size-base);
      font-weight: var(--font-weight-semibold);
      text-decoration: none;
      cursor: pointer;
      transition: all var(--duration-fast) var(--easing);
    }

    .btn:hover {
      border-color: var(--brand-aqua);
      background-color: var(--bg-tertiary);
    }

    .btn-primary {
      background-color: var(--brand-aqua);
      color: #000;
      border-color: var(--brand-aqua);
    }

    .btn-primary:hover {
      background-color: #5bc2e7;
    }

    .btn-secondary {
      background-color: var(--bg-tertiary);
    }

    .input,
    select {
      width: 100%;
      padding: var(--space-2) var(--space-3);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      font-size: var(--font-size-base);
    }

    .panel {
      background: rgba(15, 22, 41, 0.8);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: var(--space-4);
      box-shadow: var(--shadow-lg);
    }

    .site-header {
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(8px);
      background: rgba(8, 15, 35, 0.8);
      border-bottom: 1px solid var(--border);
    }

    .site-header .inner {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-3) var(--space-4);
      max-width: 1200px;
      margin: 0 auto;
    }

    .site-header h1 {
      margin: 0;
      font-size: var(--font-size-xl);
      line-height: 1.2;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: var(--space-4);
    }

    /* Screen system - simple and reliable */
    [data-screen] {
      display: none !important;
    }

    [data-screen].active {
      display: block !important;
    }

    /* Settings screen styling */
    .settings-panel {
      max-width: 480px;
      margin: 0 auto;
      padding-top: var(--space-6);
    }

    .settings-panel h2 {
      margin: 0 0 var(--space-4);
      font-size: var(--font-size-lg);
      text-align: center;
    }

    .game-description {
      background: var(--bg-tertiary);
      border-radius: var(--radius);
      padding: var(--space-4);
      margin-bottom: var(--space-4);
      border: 1px solid var(--border);
    }

    .settings-group {
      margin-bottom: var(--space-4);
    }

    .settings-label {
      display: block;
      margin-bottom: var(--space-2);
      font-weight: var(--font-weight-semibold);
    }

    .setting-help {
      display: block;
      color: var(--text-muted);
      font-size: var(--font-size-xs);
      margin-top: var(--space-1);
      font-style: italic;
    }

    .right-col {
      display: grid;
      grid-template-rows: auto 1fr;
      gap: var(--space-3);
    }

    .hud {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: 1fr;
      gap: var(--space-2);
      align-items: center;
      position: relative;
      padding-top: calc(var(--space-3) + 8px);
      min-height: 60px; /* keep HUD from collapsing into maze on small screens */
    }

    @media (max-width: 768px) {
      .hud {
        grid-template-columns: 1fr 1fr 1fr;
        grid-auto-flow: row;
        gap: var(--space-1);
        padding: var(--space-2);
        padding-top: calc(var(--space-2) + 6px);
      }

      .hud-value {
        font-size: var(--font-size-base);
      }

      .hud-label {
        font-size: 11px;
      }

      .controls {
        grid-column: 1 / -1;
        display: flex;
        gap: var(--space-2);
        justify-content: center;
        margin-top: var(--space-1);
      }

      .controls .btn {
        padding: 6px 12px;
        font-size: 13px;
      }
    }

    .hud-group {
      display: grid;
      gap: var(--space-1);
      text-align: center;
    }

    .hud-value {
      font-size: var(--font-size-xl);
      font-weight: var(--font-weight-bold);
      color: var(--brand-aqua);
    }

    .hud-label {
      font-size: var(--font-size-xs);
      color: var(--text-secondary);
    }

    .timer-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 8px;
      width: 100%;
      background: linear-gradient(90deg, var(--brand-aqua), rgba(111, 211, 245, .35));
      transform-origin: left center;
      transition: transform .1s linear;
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
    }

    .controls {
      display: flex;
      gap: var(--space-2);
      justify-content: center;
      flex-wrap: wrap;
    }

    .instructions {
      text-align: center;
      color: var(--text-secondary);
      margin: 0 0 var(--space-3);
      font-size: var(--font-size-base);
      padding: var(--space-3);
      background-color: rgba(8, 15, 35, 0.7);
      border-radius: var(--radius);
    }

    #game-container {
      position: relative;
      display: grid;
      place-items: center;
      padding: var(--space-3);
      background: rgba(0, 0, 0, 0.15);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-lg);
      overflow: hidden;
    }

    #stars-container {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    #maze-container {
      position: relative;
      background-color: rgba(0, 0, 0, 0.3);
      border: 2px solid var(--brand-aqua);
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: 0 0 20px rgba(111, 211, 245, 0.2);
      touch-action: none;
      outline: none;
      width: 600px;
      height: 400px;
      margin: 0 auto;
      max-height: 70vh; /* ensure maze never exceeds viewport height on small screens */
    }

    @media (max-width: 768px) {
      #maze-container {
        width: 95vw;
        height: 70vw;
        max-width: 450px;
        max-height: 350px;
        min-width: 300px;
        min-height: 220px;
      }
    }

    .maze-wall {
      position: absolute;
      background: linear-gradient(135deg, rgba(7, 25, 59, 0.9), rgba(11, 42, 88, 0.9));
      border: 1px solid var(--brand-aqua);
      box-shadow: 0 0 8px rgba(111, 211, 245, 0.2);
    }

    .path-line {
      position: absolute;
      z-index: 2;
      opacity: .5;
    }

    .path-line.horizontal {
      height: 2px;
      background-image: repeating-linear-gradient(90deg, transparent, transparent 4px, var(--brand-aqua) 4px, var(--brand-aqua) 8px);
    }

    .path-line.vertical {
      width: 2px;
      background-image: repeating-linear-gradient(0deg, transparent, transparent 4px, var(--brand-aqua) 4px, var(--brand-aqua) 8px);
    }

    .path-node {
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: var(--brand-aqua);
      border-radius: var(--radius-full);
      z-index: 3;
      transform: translate(-50%, -50%);
      opacity: 0.7;
    }

    #player {
      position: absolute;
      width: 40px;
      height: 40px;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ff6b6b'%3E%3Cpath d='M12 2C10 5 10 9 12 12c2-3 2-7 0-10zM4 22l8-4 8 4-8-10-8 10z'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transform: translate(-50%, -50%) rotate(90deg);
      box-shadow: 0 0 20px var(--brand-aqua);
      z-index: 10;
      cursor: pointer;
      touch-action: none;
      transition: box-shadow var(--duration-fast) var(--easing);
      animation: hover 2s ease-in-out infinite;
    }

    @keyframes hover {
      0%, 100% { transform: translate(-50%, -50%) rotate(90deg) translateY(0); }
      50%      { transform: translate(-50%, -50%) rotate(90deg) translateY(-2px); }
    }

    #goal {
      position: absolute;
      width: 44px;
      height: 44px;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ff6b6b'%3E%3Cpath d='M12 2C10 5 10 9 12 12c2-3 2-7 0-10zM4 22l8-4 8 4-8-10-8 10z'/%3E%3C/svg%3E");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      border-radius: var(--radius-full);
      z-index: 5;
      box-shadow: 0 0 30px rgba(46, 134, 171, 0.7);
      transform: translate(-50%, -50%);
    }

    .point-label {
      position: absolute;
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius);
      transform: translate(-50%, -50%);
      z-index: 20;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
      white-space: nowrap;
    }

    #start-label {
      color: var(--brand-aqua);
      background-color: var(--bg-primary);
      border: 1px solid var(--brand-aqua);
      box-shadow: 0 0 8px rgba(111, 211, 245, 0.5);
    }

    #end-label {
      color: var(--success);
      background-color: var(--bg-primary);
      border: 1px solid var(--success);
      box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
    }

    .path-trace {
      position: absolute;
      background-color: rgba(111, 211, 245, 0.3);
      border-radius: var(--radius-full);
      pointer-events: none;
      z-index: 2;
    }

    .completion {
      position: fixed;
      inset: 50% auto auto 50%;
      transform: translate(-50%, -50%) scale(1);
      max-width: 90%;
      width: 560px;
      z-index: 1100;
      text-align: center;
      display: none;
    }

    .completion.show {
      display: block;
      animation: pop .25s ease;
    }

    @keyframes pop {
      from { transform: translate(-50%, -50%) scale(.95); opacity: .6; }
      to   { transform: translate(-50%, -50%) scale(1);   opacity: 1;  }
    }

    .score-highlight {
      color: var(--brand-aqua);
      font-weight: var(--font-weight-bold);
    }

    .maze-celebrate {
      animation: celebrate 900ms ease-out 1;
    }

    @keyframes celebrate {
      0%   { box-shadow: 0 0 0 rgba(111, 211, 245, 0); }
      40%  { box-shadow: 0 0 40px rgba(111, 211, 245, .8); }
      100% { box-shadow: 0 0 20px rgba(111, 211, 245, .2); }
    }

    #error-message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--error-bg);
      color: var(--error);
      padding: var(--space-4) var(--space-6);
      border-radius: var(--radius);
      z-index: 1200;
      display: none;
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from { transform: translate(-50%, -100%); }
      to   { transform: translate(-50%, 0); }
    }

    .hidden { display: none !important; }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="inner">
      <a class="btn btn-secondary" href="/" aria-label="Go to Home">← Home</a>
      <h1>Cosmic Maze</h1>
    </div>
  </header>

  <main class="page">
    <!-- Settings Screen -->
    <aside class="settings-panel panel active" data-screen="settings">
      <h2>Session Settings</h2>

      <div class="game-description">
        <p>
          Navigate a spaceship through randomly generated mazes to reach Earth. Improves fine motor control,
          hand-eye coordination, and precision. Drag the spaceship or use arrow keys to follow the dotted paths.
        </p>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="difficulty-select">Difficulty</label>
        <select id="difficulty-select">
          <option value="easy" selected>Easy — wide paths</option>
          <option value="medium">Medium — standard paths</option>
          <option value="hard">Hard — narrow paths</option>
        </select>
        <small class="setting-help">Higher difficulty increases precision demands.</small>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="session-duration">Session Duration (minutes)</label>
        <input class="input" type="number" id="session-duration" min="1" max="10" value="5">
        <small class="setting-help">1–10 minutes recommended.</small>
      </div>

      <div class="settings-group">
        <label class="settings-label" for="show-trace">Movement Trail</label>
        <select id="show-trace">
          <option value="yes" selected>Show trail</option>
          <option value="no">Hide trail</option>
        </select>
        <small class="setting-help">Trail helps visualize movement patterns.</small>
      </div>

      <div class="controls">
        <button id="start-session" class="btn btn-primary">Start</button>
        <button id="restart-session" class="btn">Restart</button>
      </div>
    </aside>

    <!-- Game Screen -->
    <section class="right-col" data-screen="game">
      <!-- HUD Row -->
      <div class="hud panel">
        <div class="timer-bar" id="timer-bar"></div>

        <div class="hud-group">
          <div id="hud-score" class="hud-value">0</div>
          <div class="hud-label">Score</div>
        </div>

        <div class="hud-group">
          <div id="hud-avg" class="hud-value">0.0s</div>
          <div class="hud-label">Avg. Completion</div>
        </div>

        <div class="hud-group">
          <div id="hud-time" class="hud-value">5:00</div>
          <div class="hud-label">Time Left</div>
        </div>

        <div class="controls">
          <button id="pause-session" class="btn btn-secondary">Pause</button>
          <button id="end-session" class="btn">End</button>
        </div>
      </div>

      <!-- Game Area -->
      <div class="panel" id="game-container">
        <div id="stars-container"></div>

        <p class="instructions" id="instructions">
          Guide the spaceship through the cosmic maze to reach Earth. Drag the ship or use arrow keys to follow the
          dotted lines.
        </p>

        <div id="maze-container" tabindex="0"></div>
      </div>
    </section>
  </main>

  <div id="completion-message" class="completion panel">
    <h2>Therapy Session Complete!</h2>
    <div id="completion-scores">
      <p>Mazes Completed: <span id="final-completed" class="score-highlight">0</span></p>
      <p>Average Completion Time: <span id="final-avg-time" class="score-highlight">0.0s</span></p>
      <p>Motor Performance Score: <span id="final-score" class="score-highlight">0</span></p>
      <p>XP Earned: <span id="final-xp" class="score-highlight">0</span></p>
    </div>
    <div class="controls">
      <button id="restart-button" class="btn btn-primary">Start New Therapy Session</button>
      <button class="btn" id="close-complete">Close</button>
    </div>
  </div>

  <div id="error-message"></div>

  <script>
    // Simple storage utility
    const storage = {
      get: (key, defaultValue) => {
        try {
          const item = localStorage.getItem(key);
          return item ? JSON.parse(item) : defaultValue;
        } catch {
          return defaultValue;
        }
      },
      set: (key, value) => {
        try {
          localStorage.setItem(key, JSON.stringify(value));
        } catch (e) {
          console.error('Storage error:', e);
        }
      }
    };

    // Generate starfield
    function generateStars(container, count = 150) {
      if (!container) return;
      container.innerHTML = '';
      const frag = document.createDocumentFragment();
      for (let i = 0; i < count; i++) {
        const star = document.createElement('div');
        star.style.position = 'absolute';
        star.style.width = Math.random() * 3 + 'px';
        star.style.height = star.style.width;
        star.style.backgroundColor = 'white';
        star.style.borderRadius = '50%';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.opacity = Math.random() * 0.8 + 0.2;
        frag.appendChild(star);
      }
      container.appendChild(frag);
    }

    // DOM elements
    const starsContainer = document.getElementById('stars-container');
    const mazeContainer = document.getElementById('maze-container');
    const difficultySelect = document.getElementById('difficulty-select');
    const sessionDurationInp = document.getElementById('session-duration');
    const showTraceSelect = document.getElementById('show-trace');
    const startBtn = document.getElementById('start-session');
    const pauseBtn = document.getElementById('pause-session');
    const restartBtn = document.getElementById('restart-session');
    const timerBarEl = document.getElementById('timer-bar');
    const scoreEl = document.getElementById('hud-score');
    const pbEl = document.getElementById('hud-pb');
    const diffEl = document.getElementById('hud-difficulty');
    const completedEl = document.getElementById('hud-completed');
    const movesEl = document.getElementById('hud-moves');
    const avgEl = document.getElementById('hud-avg');
    const timeEl = document.getElementById('hud-time');
    const completionModal = document.getElementById('completion-message');
    const finalCompleted = document.getElementById('final-completed');
    const finalAvgTime = document.getElementById('final-avg-time');
    const finalScore = document.getElementById('final-score');
    const finalXP = document.getElementById('final-xp');
    const completeClose = document.getElementById('close-complete');
    const restartModalBtn = document.getElementById('restart-button');
    const errorMessage = document.getElementById('error-message');

    // Generate initial stars
    generateStars(starsContainer, 150);

    // Game state
    let isSessionActive = false;
    let isPaused = false;
    let sessionMs = 5 * 60 * 1000;
    let timeRemaining = 0;
    let timerInterval = null;
    let player = null;
    let goal = null;
    let startLabel = null;
    let endLabel = null;
    let maze = [];
    let pathNodes = [];
    let pathTraces = [];
    let mazeWidth = 600;
    let mazeHeight = 400;
    let cellSize = 60;
    let wallThickness = 12;
    let currentDifficulty = 'easy';
    let showTrace = true;
    let mazesCompleted = 0;
    let currentMaze = 1;
    let totalCompletionTime = 0;
    let mazeStartTime = 0;
    let score = 0;
    let personalBest = storage.get('mazePersonalBest', 0);
    let moveCountThisMaze = 0;
    let eventHandlers = {};

    // Difficulty settings
    const difficultySizes = {
      easy: { cellSize: 60, wallThickness: 12 },
      medium: { cellSize: 45, wallThickness: 10 },
      hard: { cellSize: 30, wallThickness: 8 }
    };

    // Update difficulty display
    difficultySelect.addEventListener('change', () => {
      currentDifficulty = difficultySelect.value;
      if (diffEl) diffEl.textContent = currentDifficulty;
    });

    // Maze sizing function
    function getViewportHeight() {
      return window.visualViewport ? window.visualViewport.height : window.innerHeight;
    }

    function adjustMazeSize() {
      const containerWidth = mazeContainer.offsetWidth || 600;
      const containerHeight = getViewportHeight();
      const isLandscape = window.innerWidth > window.innerHeight;

      if (isLandscape) {
        // Wider than tall: respect height so HUD + chrome fit
        let w = Math.min(containerWidth * 0.95, containerHeight * 1.2);
        let h = Math.min(containerHeight * 0.70, w * 0.70);
        mazeWidth = Math.max(220, Math.round(w));
        mazeHeight = Math.max(180, Math.round(h));
      } else {
        // Portrait: taller than wide, but still leave space for HUD
        let w = Math.min(containerWidth * 0.95, containerHeight * 0.90);
        let h = Math.min(containerHeight * 0.70, w * 0.90);
        mazeWidth = Math.max(220, Math.round(w));
        mazeHeight = Math.max(220, Math.round(h));
      }

      mazeContainer.style.width = `${mazeWidth}px`;
      mazeContainer.style.height = `${mazeHeight}px`;
    }

    // Utility functions
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function showError(msg) {
      errorMessage.textContent = msg;
      errorMessage.style.display = 'block';
      setTimeout(() => errorMessage.style.display = 'none', 3000);
    }

    function saveSettings() {
      storage.set('mazeSessionDuration', sessionDurationInp.value);
      storage.set('mazeDifficulty', difficultySelect.value);
      storage.set('mazeShowTrace', showTraceSelect.value);
    }

    function loadSettings() {
      sessionDurationInp.value = storage.get('mazeSessionDuration', 5);
      difficultySelect.value = storage.get('mazeDifficulty', 'easy');
      showTraceSelect.value = storage.get('mazeShowTrace', 'yes');
      if (diffEl) diffEl.textContent = difficultySelect.value; // guard it
    }

    function updateHUD() {
      scoreEl.textContent = `${score}`;
      if (pbEl) pbEl.textContent = `${personalBest}`;
      if (completedEl) completedEl.textContent = `${mazesCompleted}`;
      if (movesEl) movesEl.textContent = `${moveCountThisMaze}`;
      if (diffEl) diffEl.textContent = currentDifficulty;

      const avg = (mazesCompleted > 0)
        ? (totalCompletionTime / mazesCompleted / 1000).toFixed(1) : '0.0';
      avgEl.textContent = `${avg}s`;

      const mins = Math.max(0, Math.floor(timeRemaining / 60000));
      const secs = Math.max(0, Math.floor((timeRemaining % 60000) / 1000));
      timeEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function startTimer() {
      timerInterval = setInterval(() => {
        timeRemaining -= 100;
        const progress = Math.max(0, timeRemaining / sessionMs);
        timerBarEl.style.transform = `scaleX(${progress})`;
        updateHUD();
        if (timeRemaining <= 0) {
          endSession();
        }
      }, 100);
    }

    function stopTimer() {
      clearInterval(timerInterval);
      timerInterval = null;
    }

    function clearMaze() {
      removeAllEventListeners();
      while (mazeContainer.firstChild) {
        mazeContainer.removeChild(mazeContainer.firstChild);
      }
      pathTraces = [];
      pathNodes = [];
      player = goal = startLabel = endLabel = null;
    }

    function removeAllEventListeners() {
      if (eventHandlers.keydown) {
        mazeContainer.removeEventListener('keydown', eventHandlers.keydown);
        eventHandlers.keydown = null;
      }
      if (player) {
        if (eventHandlers.mousedown) {
          player.removeEventListener('mousedown', eventHandlers.mousedown);
          eventHandlers.mousedown = null;
        }
        if (eventHandlers.touchstart) {
          player.removeEventListener('touchstart', eventHandlers.touchstart);
          eventHandlers.touchstart = null;
        }
      }
      if (eventHandlers.mousemove) {
        document.removeEventListener('mousemove', eventHandlers.mousemove);
        eventHandlers.mousemove = null;
      }
      if (eventHandlers.touchmove) {
        document.removeEventListener('touchmove', eventHandlers.touchmove);
        eventHandlers.touchmove = null;
      }
      if (eventHandlers.mouseup) {
        document.removeEventListener('mouseup', eventHandlers.mouseup);
        eventHandlers.mouseup = null;
      }
      if (eventHandlers.touchend) {
        document.removeEventListener('touchend', eventHandlers.touchend);
        eventHandlers.touchend = null;
      }
    }

    function getUnvisitedNeighbors(x, y) {
      const neighbors = [];
      const rows = maze.length;
      const cols = maze[0].length;
      const directions = shuffle([
        { dx: 0, dy: -1 },
        { dx: 1, dy: 0 },
        { dx: 0, dy: 1 },
        { dx: -1, dy: 0 }
      ]);

      for (const dir of directions) {
        const nx = x + dir.dx;
        const ny = y + dir.dy;
        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !maze[ny][nx].visited) {
          neighbors.push({ x: nx, y: ny });
        }
      }
      return neighbors;
    }

    function createMazeWalls(cols, rows) {
      function addWall(top, left, width, height) {
        const wall = document.createElement('div');
        wall.className = 'maze-wall';
        wall.style.top = `${top}px`;
        wall.style.left = `${left}px`;
        wall.style.width = `${width}px`;
        wall.style.height = `${height}px`;
        mazeContainer.appendChild(wall);
      }

      // Outer walls
      addWall(0, 0, cols * cellSize, wallThickness); // top
      addWall(0, 0, wallThickness, rows * cellSize); // left
      addWall(0, cols * cellSize - wallThickness, wallThickness, rows * cellSize); // right
      addWall(rows * cellSize - wallThickness, 0, cols * cellSize, wallThickness); // bottom

      // Inner walls
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const cell = maze[i][j];
          if (cell.walls.right && j < cols - 1) {
            addWall(i * cellSize, (j + 1) * cellSize - wallThickness / 2, wallThickness, cellSize);
          }
          if (cell.walls.bottom && i < rows - 1) {
            addWall((i + 1) * cellSize - wallThickness / 2, j * cellSize, cellSize, wallThickness);
          }
        }
      }
    }

    function connectPathNodes(cols, rows) {
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const currentIndex = pathNodes.findIndex(n => n.gridX === x && n.gridY === y);
          if (currentIndex === -1) continue;

          const currentNode = pathNodes[currentIndex];

          if (x > 0 && !maze[y][x].walls.left) {
            const leftIndex = pathNodes.findIndex(n => n.gridX === x - 1 && n.gridY === y);
            if (leftIndex !== -1 && !currentNode.connections.includes(leftIndex)) {
              currentNode.connections.push(leftIndex);
              pathNodes[leftIndex].connections.push(currentIndex);
            }
          }
          if (x < cols - 1 && !maze[y][x].walls.right) {
            const rightIndex = pathNodes.findIndex(n => n.gridX === x + 1 && n.gridY === y);
            if (rightIndex !== -1 && !currentNode.connections.includes(rightIndex)) {
              currentNode.connections.push(rightIndex);
              pathNodes[rightIndex].connections.push(currentIndex);
            }
          }
          if (y > 0 && !maze[y][x].walls.top) {
            const topIndex = pathNodes.findIndex(n => n.gridX === x && n.gridY === y - 1);
            if (topIndex !== -1 && !currentNode.connections.includes(topIndex)) {
              currentNode.connections.push(topIndex);
              pathNodes[topIndex].connections.push(currentIndex);
            }
          }
          if (y < rows - 1 && !maze[y][x].walls.bottom) {
            const bottomIndex = pathNodes.findIndex(n => n.gridX === x && n.gridY === y + 1);
            if (bottomIndex !== -1 && !currentNode.connections.includes(bottomIndex)) {
              currentNode.connections.push(bottomIndex);
              pathNodes[bottomIndex].connections.push(currentIndex);
            }
          }
        }
      }
    }

    function createPathLines(cols, rows) {
      // Create path nodes
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const centerX = j * cellSize + cellSize / 2;
          const centerY = i * cellSize + cellSize / 2;
          const node = { x: centerX, y: centerY, gridX: j, gridY: i, connections: [] };
          pathNodes.push(node);

          const nodeElement = document.createElement('div');
          nodeElement.className = 'path-node';
          nodeElement.style.left = `${centerX}px`;
          nodeElement.style.top = `${centerY}px`;
          mazeContainer.appendChild(nodeElement);
        }
      }

      // Connect nodes based on maze structure
      connectPathNodes(cols, rows);

      // Draw connection lines
      for (let i = 0; i < pathNodes.length; i++) {
        const nodeA = pathNodes[i];
        for (const connectionIndex of nodeA.connections) {
          if (i < connectionIndex) {
            const nodeB = pathNodes[connectionIndex];
            const line = document.createElement('div');
            line.className = 'path-line';

            if (nodeA.gridX === nodeB.gridX) {
              line.classList.add('vertical');
              const top = Math.min(nodeA.y, nodeB.y);
              const height = Math.abs(nodeA.y - nodeB.y);
              line.style.left = `${nodeA.x}px`;
              line.style.top = `${top}px`;
              line.style.height = `${height}px`;
            } else {
              line.classList.add('horizontal');
              const left = Math.min(nodeA.x, nodeB.x);
              const width = Math.abs(nodeA.x - nodeB.x);
              line.style.left = `${left}px`;
              line.style.top = `${nodeA.y}px`;
              line.style.width = `${width}px`;
            }
            mazeContainer.appendChild(line);
          }
        }
      }
    }

    function createPlayer(x, y) {
      player = document.createElement('div');
      player.id = 'player';
      const playerX = x * cellSize + cellSize / 2;
      const playerY = y * cellSize + cellSize / 2;
      player.style.left = `${playerX}px`;
      player.style.top = `${playerY}px`;
      mazeContainer.appendChild(player);
    }

    function createGoal(x, y) {
      goal = document.createElement('div');
      goal.id = 'goal';

      // goal graphic is 44px -> radius ≈ 22
      const r = 22;
      // stronger safety margin from walls/borders
      const margin = Math.max(6, wallThickness * 2);

      // raw centers
      let goalX = x * cellSize + cellSize / 2;
      let goalY = y * cellSize + cellSize / 2;

      // clamp within the visible maze area
      goalX = Math.min(Math.max(goalX, r + margin), mazeWidth  - (r + margin));
      goalY = Math.min(Math.max(goalY, r + margin), mazeHeight - (r + margin));

      goal.style.left = `${goalX}px`;
      goal.style.top = `${goalY}px`;
      mazeContainer.appendChild(goal);
    }

    function createPointLabels(startX, startY, endX, endY) {
      const labelOffsetTop = 15;
      const labelOffsetBottom = 15;

      const minTop = 10;
      const maxTop = mazeHeight - 10;

      // START label (above start; clamp)
      startLabel = document.createElement('div');
      startLabel.id = 'start-label';
      startLabel.className = 'point-label';
      startLabel.textContent = 'START';
      startLabel.style.left = `${startX * cellSize + cellSize / 2}px`;
      let startTop = startY * cellSize - labelOffsetTop;
      startTop = Math.max(minTop, Math.min(startTop, maxTop));
      startLabel.style.top = `${startTop}px`;

      // FINISH label — prefer below goal; flip above if it would clip
      endLabel = document.createElement('div');
      endLabel.id = 'end-label';
      endLabel.className = 'point-label';
      endLabel.textContent = 'FINISH';
      endLabel.style.left = `${endX * cellSize + cellSize / 2}px`;

      let endTop = endY * cellSize + cellSize + labelOffsetBottom; // below
      if (endTop > maxTop) endTop = endY * cellSize - labelOffsetBottom;     // above if needed
      endTop = Math.max(minTop, Math.min(endTop, maxTop));
      endLabel.style.top = `${endTop}px`;

      mazeContainer.appendChild(startLabel);
      mazeContainer.appendChild(endLabel);
    }

    function generateMaze() {
      // Set difficulty parameters
      const dims = difficultySizes[currentDifficulty] || difficultySizes.easy;
      cellSize = dims.cellSize;
      wallThickness = dims.wallThickness;

      // Calculate grid dimensions based on current mazeWidth/mazeHeight
      const cols = Math.max(3, Math.floor(mazeWidth / cellSize));
      const rows = Math.max(3, Math.floor(mazeHeight / cellSize));

      // Clear existing maze if any
      if (mazeContainer && mazeContainer.children.length > 0) clearMaze();

      maze = [];
      pathNodes = [];
      pathTraces = [];

      // Initialize maze grid
      for (let i = 0; i < rows; i++) {
        const row = [];
        for (let j = 0; j < cols; j++) {
          row.push({ x: j, y: i, visited: false, walls: { top: true, right: true, bottom: true, left: true } });
        }
        maze.push(row);
      }

      // Generate maze using depth-first search
      const stack = [];
      let currentX = 0;
      let currentY = 0;
      maze[currentY][currentX].visited = true;
      stack.push({ x: currentX, y: currentY });

      while (stack.length > 0) {
        const current = stack[stack.length - 1];
        const neighbors = getUnvisitedNeighbors(current.x, current.y);

        if (neighbors.length === 0) { stack.pop(); continue; }

        const next = neighbors[Math.floor(Math.random() * neighbors.length)];

        if (next.x > current.x) {
          maze[current.y][current.x].walls.right = false;
          maze[next.y][next.x].walls.left = false;
        } else if (next.x < current.x) {
          maze[current.y][current.x].walls.left = false;
          maze[next.y][next.x].walls.right = false;
        } else if (next.y > current.y) {
          maze[current.y][current.x].walls.bottom = false;
          maze[next.y][next.x].walls.top = false;
        } else if (next.y < current.y) {
          maze[current.y][current.x].walls.top = false;
          maze[next.y][next.x].walls.bottom = false;
        }

        maze[next.y][next.x].visited = true;
        stack.push(next);
      }

      // Create visual elements
      createMazeWalls(cols, rows);
      createPathLines(cols, rows);
      createPlayer(0, 0);
      createGoal(cols - 1, rows - 1);
      createPointLabels(0, 0, cols - 1, rows - 1);

      // Setup player movement
      setupPlayerMovement();

      // Reset maze-specific counters
      moveCountThisMaze = 0;
      updateHUD();
    }

    function findPath(startIndex, targetIndex) {
      if (startIndex === targetIndex) return [startIndex];
      const visited = new Set();
      const queue = [[startIndex]];
      while (queue.length > 0) {
        const path = queue.shift();
        const currentIndex = path[path.length - 1];
        if (currentIndex === targetIndex) return path;
        if (!visited.has(currentIndex)) {
          visited.add(currentIndex);
          for (const nextIndex of pathNodes[currentIndex].connections) {
            if (!visited.has(nextIndex)) queue.push([...path, nextIndex]);
          }
        }
      }
      return [];
    }

    function setupPlayerMovement() {
      if (!player || !pathNodes.length) return;

      let playerX = parseFloat(player.style.left);
      let playerY = parseFloat(player.style.top);
      let closestNodeIndex = 0;
      let isDragging = false;
      let dragPath = [];
      let lastVisitedNode = 0;

      function updateClosestNodeIndex() {
        let minDistance = Infinity;
        for (let i = 0; i < pathNodes.length; i++) {
          const node = pathNodes[i];
          const dx = node.x - playerX;
          const dy = node.y - playerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < minDistance) { minDistance = distance; closestNodeIndex = i; }
        }
      }
      updateClosestNodeIndex();

      function addPathTrace(fromX, fromY, toX, toY) {
        if (!showTrace) return;
        const trace = document.createElement('div');
        trace.className = 'path-trace';
        const centerX = (fromX + toX) / 2;
        const centerY = (fromY + toY) / 2;
        const width = Math.abs(toX - fromX) + 10;
        const height = Math.abs(toY - fromY) + 10;
        trace.style.left = `${centerX - width / 2}px`;
        trace.style.top = `${centerY - height / 2}px`;
        trace.style.width = `${width}px`;
        trace.style.height = `${height}px`;
        mazeContainer.appendChild(trace);
        pathTraces.push(trace);
      }

      function checkGoalReached() {
        const goalX = parseFloat(goal.style.left);
        const goalY = parseFloat(goal.style.top);
        const distance = Math.sqrt((playerX - goalX) ** 2 + (playerY - goalY) ** 2);
        const goalRadius = parseFloat(getComputedStyle(goal).width) / 2 || 22;
        if (distance < goalRadius) {
          mazeContainer.classList.add('maze-celebrate');
          setTimeout(() => mazeContainer.classList.remove('maze-celebrate'), 900);
          completeCurrentMaze();
        }
      }

      function moveToNode(nodeIndex) {
        if (nodeIndex < 0 || nodeIndex >= pathNodes.length) return;
        const targetNode = pathNodes[nodeIndex];
        addPathTrace(playerX, playerY, targetNode.x, targetNode.y);
        playerX = targetNode.x;
        playerY = targetNode.y;
        player.style.left = `${playerX}px`;
        player.style.top = `${playerY}px`;
        closestNodeIndex = nodeIndex;
        moveCountThisMaze++;
        updateHUD();
        checkGoalReached();
      }

      function handleKeyboard(e) {
        if (!isSessionActive || isPaused) return;
        const currentNode = pathNodes[closestNodeIndex];
        let nextNodeIndex = -1;
        switch (e.key) {
          case 'ArrowUp':
            nextNodeIndex = currentNode.connections.find(i => pathNodes[i].y < currentNode.y && pathNodes[i].x === currentNode.x);
            break;
          case 'ArrowDown':
            nextNodeIndex = currentNode.connections.find(i => pathNodes[i].y > currentNode.y && pathNodes[i].x === currentNode.x);
            break;
          case 'ArrowLeft':
            nextNodeIndex = currentNode.connections.find(i => pathNodes[i].x < currentNode.x && pathNodes[i].y === currentNode.y);
            break;
          case 'ArrowRight':
            nextNodeIndex = currentNode.connections.find(i => pathNodes[i].x > currentNode.x && pathNodes[i].y === currentNode.y);
            break;
          default: return;
        }
        if (nextNodeIndex !== undefined && nextNodeIndex !== -1) {
          moveToNode(nextNodeIndex);
          e.preventDefault();
        }
      }

      function startDrag(e) {
        if (!isSessionActive || isPaused) return;
        isDragging = true;
        dragPath = [closestNodeIndex];
        lastVisitedNode = closestNodeIndex;
        player.style.boxShadow = '0 0 30px rgba(111, 211, 245, 1)';
        e.preventDefault();
      }

      function handleDrag(e) {
        if (!isDragging || !isSessionActive || isPaused) return;
        const rect = mazeContainer.getBoundingClientRect();
        let clientX, clientY;
        if (e.type === 'mousemove') {
          clientX = e.clientX - rect.left;
          clientY = e.clientY - rect.top;
        } else {
          clientX = e.touches[0].clientX - rect.left;
          clientY = e.touches[0].clientY - rect.top;
          e.preventDefault();
        }

        const currentNode = pathNodes[closestNodeIndex];
        const nodesToCheck = new Set([
          closestNodeIndex,
          ...currentNode.connections.flatMap(i => [i, ...pathNodes[i].connections])
        ]);

        let bestNodeIndex = -1;
        let minDistance = Infinity;

        for (const nodeIndex of nodesToCheck) {
          const node = pathNodes[nodeIndex];
          const distance = Math.sqrt((node.x - clientX) ** 2 + (node.y - clientY) ** 2) +
            (dragPath.includes(nodeIndex) ? cellSize * 0.5 : 0);
          if (distance < minDistance && nodeIndex !== lastVisitedNode) {
            minDistance = distance; bestNodeIndex = nodeIndex;
          }
        }

        if (bestNodeIndex !== -1 && minDistance < cellSize * 0.7) {
          const path = findPath(closestNodeIndex, bestNodeIndex);
          if (path.length > 0) {
            for (let i = 1; i < path.length; i++) {
              const nodeIndex = path[i];
              if (!dragPath.includes(nodeIndex)) dragPath.push(nodeIndex);
              moveToNode(nodeIndex);
              lastVisitedNode = nodeIndex;
            }
          }
        }
      }

      function endDrag() {
        isDragging = false;
        player.style.boxShadow = '0 0 20px rgba(111, 211, 245, 0.8)';
        dragPath = [];
        lastVisitedNode = closestNodeIndex;
      }

      // Register event handlers
      eventHandlers.keydown = handleKeyboard;
      eventHandlers.mousedown = startDrag;
      eventHandlers.touchstart = startDrag;
      eventHandlers.mousemove = handleDrag;
      eventHandlers.touchmove = handleDrag;
      eventHandlers.mouseup = endDrag;
      eventHandlers.touchend = endDrag;

      mazeContainer.addEventListener('keydown', eventHandlers.keydown);
      player.addEventListener('mousedown', eventHandlers.mousedown);
      player.addEventListener('touchstart', eventHandlers.touchstart, { passive: false });
      document.addEventListener('mousemove', eventHandlers.mousemove);
      document.addEventListener('touchmove', eventHandlers.touchmove, { passive: false });
      document.addEventListener('mouseup', eventHandlers.mouseup);
      document.addEventListener('touchend', eventHandlers.touchend);
    }

    function completeCurrentMaze() {
      const completionTime = Date.now() - mazeStartTime;
      totalCompletionTime += completionTime;
      mazesCompleted++;
      currentMaze++;

      const averageTime = (totalCompletionTime / mazesCompleted / 1000) || 1;
      score = Math.max(score, Math.round((mazesCompleted * 100) / averageTime));
      updateHUD();

      generateMaze();
      mazeStartTime = Date.now();
    }

    function endSession() {
      if (timerInterval) stopTimer();
      isSessionActive = false;

      const averageTimeString = (mazesCompleted > 0)
        ? (totalCompletionTime / mazesCompleted / 1000).toFixed(1)
        : '0.0';
      const averageTime = parseFloat(averageTimeString);
      const computedScore = Math.round((mazesCompleted * 100) / (averageTime > 0 ? averageTime : 1));

      if (computedScore > personalBest) {
        personalBest = computedScore;
        storage.set('mazePersonalBest', personalBest);
      }
      updateHUD();

      finalCompleted.textContent = `${mazesCompleted}`;
      finalAvgTime.textContent = `${averageTimeString}s`;
      finalScore.textContent = `${computedScore}`;
      finalXP.textContent = `${Math.max(10, Math.round(computedScore * 0.5))}`;
      completionModal.classList.add('show');

      clearMaze();
      setScreen('settings');
    }

    function setScreen(screenName) {
      document.querySelectorAll('[data-screen]').forEach(el => el.classList.remove('active'));
      document.querySelector(`[data-screen="${screenName}"]`).classList.add('active');
    }

    // Event Listeners
    startBtn.addEventListener('click', () => {
      if (isSessionActive) return;
      if (timerInterval) stopTimer();

      try {
        currentDifficulty = difficultySelect.value;

        const minutes = Math.max(1, Math.min(10, Number(sessionDurationInp.value) || 5));
        sessionMs = minutes * 60 * 1000;
        sessionDurationInp.value = minutes;

        showTrace = showTraceSelect.value === 'yes';
        saveSettings();

        score = 0;
        mazesCompleted = 0;
        currentMaze = 1;
        totalCompletionTime = 0;
        timeRemaining = sessionMs;
        moveCountThisMaze = 0;
        isPaused = false;

        clearMaze();
        updateHUD();

        setScreen('game');

        isSessionActive = true;
        startTimer();

        setTimeout(() => {
          try {
            adjustMazeSize();
            clearMaze();
            generateMaze();
            mazeStartTime = Date.now();
            mazeContainer.focus();
          } catch (error) {
            console.error('Error generating maze:', error);
            showError('Failed to generate maze: ' + error.message);
          }
        }, 100);
      } catch (e) {
        console.error(e);
        showError('Failed to start session: ' + e.message);
      }
    });

    pauseBtn.addEventListener('click', () => {
      if (!isSessionActive) return;
      isPaused = !isPaused;
      pauseBtn.setAttribute('aria-pressed', String(isPaused));
      pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
      if (isPaused) {
        stopTimer();
      } else {
        startTimer();
        mazeContainer.focus();
      }
    });

    document.getElementById('end-session').addEventListener('click', endSession);

    restartBtn.addEventListener('click', () => {
      if (timerInterval) stopTimer();
      isSessionActive = false;
      isPaused = false;
      setScreen('settings');
    });

    restartModalBtn.addEventListener('click', () => {
      completionModal.classList.remove('show');
      setScreen('settings');
    });

    completeClose.addEventListener('click', () => {
      completionModal.classList.remove('show');
      setScreen('settings');
    });

    // Initialize
    loadSettings();
    updateHUD();
    setScreen('settings');

    // Touch event handling for mobile
    document.addEventListener('touchstart', e => {
      if (e.touches.length > 1) e.preventDefault();
    }, { passive: false });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', e => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, false);

    document.addEventListener('touchmove', e => {
      if (isSessionActive && !isPaused) e.preventDefault();
    }, { passive: false });

    document.addEventListener('contextmenu', e => e.preventDefault());

    // Resize/orientation: keep play area sized and reflow maze during sessions
    window.addEventListener('resize', () => {
      if (!isSessionActive) return;
      adjustMazeSize();
      clearMaze();
      generateMaze();
    });
  </script>
</body>

</html>